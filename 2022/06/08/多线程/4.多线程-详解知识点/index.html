<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>多线程-详解知识点 | Hexo</title>
  <meta name="description" content="多线程-详解知识点1. 线程:是 CPU 进行 运算调度的最⼩基本单位，包含在进程之中，没有 独立的资源，共享其进程中的资源，每个线程都有 自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小，系统不会为线程分配内存. 2.  线程安全和线程不安全？线程安全: 多线程访问时，采用加锁机制，当一个线程访问 该类的某个数据时，进行保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使用,">
<meta property="og:type" content="article">
<meta property="og:title" content="多线程-详解知识点">
<meta property="og:url" content="https://turbocome.github.io/TurboCome/2022/06/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%AF%A6%E8%A7%A3%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
<meta property="og:site_name" content="TurboCome">
<meta property="og:description" content="多线程-详解知识点1. 线程:是 CPU 进行 运算调度的最⼩基本单位，包含在进程之中，没有 独立的资源，共享其进程中的资源，每个线程都有 自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小，系统不会为线程分配内存. 2.  线程安全和线程不安全？线程安全: 多线程访问时，采用加锁机制，当一个线程访问 该类的某个数据时，进行保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使用,">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gursjuuz12j60ha08yjsg02.jpg">
<meta property="article:published_time" content="2022-06-08T13:55:19.000Z">
<meta property="article:modified_time" content="2022-04-19T06:43:43.408Z">
<meta property="article:author" content="TurboCome">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tva1.sinaimg.cn/large/008i3skNly1gursjuuz12j60ha08yjsg02.jpg">
  <!-- Canonical links -->
  <link rel="canonical" href="https://turbocome.github.io/TurboCome/2022/06/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%AF%A6%E8%A7%A3%E7%9F%A5%E8%AF%86%E7%82%B9/index.html">
  
    <link rel="alternate" href="/atom.xml" title="TurboCome" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/TurboCome/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.1.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/TurboCome" target="_blank">
          <img class="img-circle img-rotate" src="/TurboCome/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">TurboCome</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> HangZhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/TurboCome/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/TurboCome/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/TurboCome/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/TurboCome/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/TurboCome/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/TurboCome/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">关于</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/TurboCome" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/TurboCome/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>本站记录个人的成长经历，欢迎大家交流与分享!</p>
            </div>
        </div>
    </div>
</div>

    
      <!-- 
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Mysql/">Mysql</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">3</span></li></ul></li></ul>
    </div>
  </div>
 -->


  <div class="category-block">
    <h3 class="title">categories</h3>
       <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Mysql/">Mysql</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">3</span></li></ul></li></ul>
  </div>



<!-- 
  <div class="widget tag">
    <h3 class="title">categories</h3>
       <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><span class="category-list-count">25</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Mysql/">Mysql</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E7%BD%91%E7%BB%9C/">网络</a><span class="category-list-count">3</span></li></ul></li></ul> 
  </div>
  -->
    
      <!-- 
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>
 -->


  <div class="tags-block">
    <h3 class="asidetitle">tags</h3>
       <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/Mysql/" rel="tag">Mysql</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/Redis/" rel="tag">Redis</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" rel="tag">消息队列</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/TurboCome/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a><span class="tag-list-count">3</span></li></ul>
  </div>




    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/TurboCome/tags/Mysql/" style="font-size: 14px;">Mysql</a> <a href="/TurboCome/tags/Redis/" style="font-size: 13.5px;">Redis</a> <a href="/TurboCome/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 13.75px;">多线程</a> <a href="/TurboCome/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 13px;">操作系统</a> <a href="/TurboCome/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 13.25px;">消息队列</a> <a href="/TurboCome/tags/%E7%BD%91%E7%BB%9C/" style="font-size: 13.25px;">网络</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/TurboCome/archives/2022/07/">七月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/TurboCome/archives/2022/06/">六月 2022</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/TurboCome/archives/2022/05/">五月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/TurboCome/archives/2022/04/">四月 2022</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/TurboCome/archives/2022/03/">三月 2022</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/TurboCome/archives/2022/02/">二月 2022</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="icon icon-angle-right"></i><a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/TurboCome/2022/07/09/Redis/A4-Redis%E9%9B%86%E7%BE%A4%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/" class="title">集群一致性hash算法</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-09T13:55:19.000Z" itemprop="datePublished">2022-07-09</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="icon icon-angle-right"></i><a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/TurboCome/2022/07/08/Redis/A3-Redis%20%E4%BC%98%E5%8C%96/" class="title">Redis性能优化</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-08T13:55:19.000Z" itemprop="datePublished">2022-07-08</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="icon icon-angle-right"></i><a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/TurboCome/2022/07/07/Redis/A2-Redis-%E6%8C%81%E4%B9%85%E5%8C%96-%E5%93%A8%E5%85%B5:%E9%9B%86%E7%BE%A4/" class="title">持久化-哨兵/集群</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-07T13:55:19.000Z" itemprop="datePublished">2022-07-07</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="icon icon-angle-right"></i><a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/Redis/">Redis</a>
              </p>
              <p class="item-title">
                <a href="/TurboCome/2022/07/06/Redis/A1-Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="title">Redis数据结构</a>
              </p>
              <p class="item-date">
                <time datetime="2022-07-06T13:55:19.000Z" itemprop="datePublished">2022-07-06</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a><i class="icon icon-angle-right"></i><a class="category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
              </p>
              <p class="item-title">
                <a href="/TurboCome/2022/06/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.AQS%E8%AF%A6%E8%A7%A3/" class="title">多线程-AQS详解</a>
              </p>
              <p class="item-date">
                <time datetime="2022-06-09T13:55:19.000Z" itemprop="datePublished">2022-06-09</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-多线程/4.多线程-详解知识点" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      多线程-详解知识点
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/TurboCome/2022/06/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%AF%A6%E8%A7%A3%E7%9F%A5%E8%AF%86%E7%82%B9/" class="article-date">
	  <time datetime="2022-06-08T13:55:19.000Z" itemprop="datePublished">2022-06-08</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/">后端</a>►<a class="article-category-link" href="/TurboCome/categories/%E5%90%8E%E7%AB%AF/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/TurboCome/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a>
  </span>


        
	<span class="article-read hidden-xs">
	    <i class="icon icon-eye-fill" aria-hidden="true"></i>
	    <span id="busuanzi_container_page_pv">
			<span id="busuanzi_value_page_pv">0</span>
		</span>
	</span>


        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/TurboCome/2022/06/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%AF%A6%E8%A7%A3%E7%9F%A5%E8%AF%86%E7%82%B9/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>

    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="多线程-详解知识点"><a href="#多线程-详解知识点" class="headerlink" title="多线程-详解知识点"></a>多线程-详解知识点</h2><h4 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程:"></a><strong>1. 线程:</strong></h4><p>是 CPU 进行 运算调度的最⼩基本单位，包含在进程之中，没有 独立的资源，共享其进程中的资源，每个线程都有 自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小，系统不会为线程分配内存.</p>
<h4 id="2-线程安全和线程不安全？"><a href="#2-线程安全和线程不安全？" class="headerlink" title="2.  线程安全和线程不安全？"></a><strong>2.  线程安全和线程不安全？</strong></h4><p><strong>线程安全:</strong> 多线程访问时，采用加锁机制，当一个线程访问 该类的某个数据时，进行保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使用, 不会出现数据不一致问题。</p>
<p><strong>线程不安全：</strong>不提供数据访问保护，有可能出现 <strong>多个线程先后更改数据</strong> 造成所得到的数据是脏数据； </p>
<p>线程安全问题 都是由 全局变量，静态变量引起的，若有多个线程同时执行写操作，一般需要考虑线程同步，否则可能影响线程安全。</p>
<p><strong>多线程：</strong>是指从 软件或硬件上实现多个线程的并发技术。</p>
<h4 id="多线程的好处："><a href="#多线程的好处：" class="headerlink" title="多线程的好处："></a>多线程的好处：</h4><p>i. 使用 多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载</p>
<p>ii. 发挥 多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</p>
<h4 id="多线程的缺点："><a href="#多线程的缺点：" class="headerlink" title="多线程的缺点："></a>多线程的缺点：</h4><p>1.大量的 线程降低代码的可读性；</p>
<p>2.更多的 线程需要更多的内存空间</p>
<p>3.当 多个线程对同一个资源出现争夺时候要注意 线程安全的问题。</p>
<h4 id="3-⾃旋锁"><a href="#3-⾃旋锁" class="headerlink" title="3. ⾃旋锁"></a>3. ⾃旋锁</h4><p>1.当线程 A 想要获取一把自旋锁⽽该锁又被其它线程锁持有时，线程 A会在⼀个循环中自旋以检测锁是不是已经可用。</p>
<p><strong>2.自旋锁需要注意：</strong></p>
<ul>
<li>由于 自旋时不释放CPU，持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直自旋，浪费CPU时间。</li>
<li>持有自旋锁的线程在 sleep 之前应该释放自旋锁，以便其它线程可以获得自旋锁。</li>
</ul>
<p>3.目前的 JVM实现自旋会 消耗CPU，如果⻓时间不调用 doNotify方法，doWait方法会一直自旋，CPU会消耗太大</p>
<p>4.自旋锁比较适用于 锁使用者 ，保持锁时间比较短 的情况，这种情况自旋锁的效率比较高</p>
<p>5.自旋锁是一种对 多处理器相当有效的机制，⽽在单处理器非抢占式的系统中基本上没有作⽤</p>
<h4 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4. 乐观锁和悲观锁"></a>4. 乐观锁和悲观锁</h4><p><strong>悲观锁：</strong> 每次都加重锁，认为其他线程会访问共享变量</p>
<p><strong>乐观锁：</strong> 轻量级的锁，认为其他线程不会访问共享变量，修改时进行判断，通过 cas 乐观锁技术 保证数据⼀致性。</p>
<h4 id="5-原⼦操作"><a href="#5-原⼦操作" class="headerlink" title="5. 原⼦操作"></a><strong>5. 原⼦操作</strong></h4><p>在 Java Concurrency API中有些原⼦类(atomic classes)</p>
<p>原子操作：一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的⼿段。</p>
<p>int++： 并不不是一个原子操作，所以当⼀个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>解决问题：<strong>java.util.concurrent. atomic</strong> 包提供了int和long类型，它们可以自动的保证操作是原子的并且不需要使用同步。</p>
<h4 id="6-Executors框架"><a href="#6-Executors框架" class="headerlink" title="6. Executors框架"></a><strong>6.</strong> Executors框架</h4><p>Java通过 Executors 提供四种线程池，分别为：</p>
<p>1.newSingleThreadExecutor 创建一个单线程线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p>
<p>2.newFixedThreadPool 创建一个固定数量线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>3.newCachedThreadPool 创建一个可缓存线程池，如果 线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>4.newScheduledThreadPool 创建一个定⻓线程池，支持 定时及周期性任务执行。</p>
<h4 id="7-阻塞队列"><a href="#7-阻塞队列" class="headerlink" title="7. 阻塞队列"></a><strong>7. 阻塞队列</strong></h4><p> JDK7 提供了 7个阻塞队列（也属于并发容器）</p>
<ol>
<li>ArrayBlockingQueue ：一个由 数组结构组成的 有界阻塞队列</li>
<li>LinkedBlockingQueue ：一个由 链表结构组成的 有界阻塞队列</li>
<li>PriorityBlockingQueue ：一个 支持优先级排序的 无界阻塞队列。</li>
<li>DelayQueue：一个使用 优先级队列实现的 无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的 阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的 无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的 双向阻塞队列。</li>
</ol>
<p><strong>概念：</strong> 阻塞队列 是一个在队列基础上又支持 两个附加操作的队列。</p>
<p>附加操作：</p>
<p>支持阻塞的 插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>支持阻塞的 移除方法：队列空时，获取元素的线程会等待队列变为非空。</p>
<h4 id="8-Callable和Future"><a href="#8-Callable和Future" class="headerlink" title="8. Callable和Future"></a><strong>8. Callable和Future</strong></h4><p>获取线程的执行结果时使用，Callable 用于产生结果，Future用于获取结果；</p>
<p>Callable 接口使用 泛型去定义它的返回类型，Executors 类提供一些有用的方法在线程池中执⾏Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。</p>
<p>在线程池提交Callable任务后返回一个Future对象，使用它可以知道 Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p>
<h4 id="9-FutureTask"><a href="#9-FutureTask" class="headerlink" title="9. FutureTask"></a><strong>9. FutureTask</strong></h4><p>FutureTask 可用于 异步获取执行结果或取消执行任务的场景。</p>
<p>通过传入Runnable或 Callable的任务给 FutureTask，直接调用其 run方法或放入线程池执行，之后可以在外部通过 FutureTask的 get方法异步获取执行结果，因此 FutureTask 非常适合⽤于耗时的计算，主线程可以在完成⾃己的任务后，再去获取结果。另外，FutureTask还可以确保 即使调用多次 run方法，它都只会执行一次 Runnable或 Callable任务，或通过 cancel 取消 FutureTask的执行等。</p>
<p>FutureTask 可用于执行 多任务、以 避免高并发情况下多次创建数据锁的出现。</p>
<h4 id="10-同步容器-和-并发容器"><a href="#10-同步容器-和-并发容器" class="headerlink" title="10. 同步容器 和 并发容器"></a><strong>10. 同步容器 和 并发容器</strong></h4><p>同步容器：</p>
<ul>
<li>主要代表有 Vector和 Hashtable，以及 Collections.synchronizedXxx等；</li>
<li>锁的 粒度为当前对象整体；</li>
<li>迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛ConcurrentModificationException。</li>
</ul>
<p>并发容器：  </p>
<ul>
<li><p>主要代表有 ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。</p>
</li>
<li><p>锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。</p>
</li>
<li><p>迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</p>
</li>
</ul>
<h4 id="11-多线程的上下文切换"><a href="#11-多线程的上下文切换" class="headerlink" title="11. 多线程的上下文切换"></a><strong>11. 多线程的上下文切换</strong></h4><p>CPU 通过 时间片分配算法来循环执行任务，当前一个任务执行一个时间片后，会切换到下一个任务。但在切换前会保存上一个任务的状态，以便下次 切换回这个任务时，可以再次加载这个任务的状态。</p>
<h4 id="12-ThreadLocal的作用"><a href="#12-ThreadLocal的作用" class="headerlink" title="12.ThreadLocal的作用"></a><strong>12.ThreadLocal的作用</strong></h4><p>​        ThreadLocal 类允许 创建 只能被同一个线程读写的变量。因此，如果⼀段代码含有一个 ThreadLocal变量的引用，即使 两个线程同时执行这段代码，它们也 无法访问到对方的ThreadLocal变量量。</p>
<p><strong>线程局部变量:</strong>  在并发编程的时候，成员变量如果不做任何处理, 线程是不安全的，各个线程都在操作同⼀个变量，显然是不行的，volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，需要满足这样⼀个条件：变量是同一个，但每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下 ThreadLocal就⾮常适用，比如说 DAO的数据库连接，DAO是单例的，它的属性 Connection 就不是一个线程安全的变量。每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal 就比较好的解决了这个问题。</p>
<p>​        每个线程都维护了一个map，而这个map的 key就是 threadLocal，而值就是我们set的那个值，每次线程在 get的时候，都从⾃己的变量中取值，既然从⾃己的变量中取值，那肯定就不存在线程安全问题。ThreadLocal这个变量的状态根本没有发生变化，他仅是充当一个 key的⻆色，另外提供给每一个线程一个初始值。</p>
<h4 id="13-ThreadPool（线程池）用法与优势"><a href="#13-ThreadPool（线程池）用法与优势" class="headerlink" title="13. ThreadPool（线程池）用法与优势"></a><strong>13. ThreadPool（线程池）用法与优势</strong></h4><p>优点：</p>
<p>1.减少 创建和销毁线程的次数，每个工作线程都可以被重复利用，可执⾏多个任务</p>
<p>2.可以根据系统的承受能力，调整 线程池中工作线程的数目，防⽌因为消耗过多的内存，而把服务器累趴下</p>
<p>(每个线程需要⼤约 1MB内存，线程开的越多，消耗的内存也就越大，最后死机)；减少在 创建和销毁线程上所花的时间以及系统资源的开销</p>
<p>如不使⽤用线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存</p>
<p>Java⾥⾯线程池的顶级接口： Executor，但严格意义上讲 Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具，真正的线程池接⼜是 ExecutorService。</p>
<ul>
<li>当线程数 &lt; corePoolSize时，创建线程执⾏行行任务。</li>
<li>当线程数 &gt;&#x3D; corePoolSize并且 workQueue没有满时，放入workQueue中</li>
<li>线程数  &gt;&#x3D;corePoolSize并且 workQueue满时，新任务<strong>新建线程运行</strong>，线程总数要 &lt; maximumPoolSize</li>
<li>当线程总数 &#x3D;maximumPoolSize并且 workQueue满了的时候，执行 handler的rejectedExecution 拒绝策略</li>
</ul>
<h4 id="14-CAS-产生的ABA-问题"><a href="#14-CAS-产生的ABA-问题" class="headerlink" title="14.CAS 产生的ABA 问题"></a><strong>14.CAS 产生的ABA 问题</strong></h4><p>原节点 A ，改变头节点 2次， 先改为 B， 改变B 指针的指向（插入链表的表头，成为新头节点），最后再改回节点 A ，对于节点，其实际的 值没有改变，但此时 指针的指向 已经发生了改变</p>
<p>解决：</p>
<p>加入版本号，在内部维护一个状态戳（时间戳），每次修改对象值的同时，也改变状态戳，</p>
<p>在校验 CAS 时，同时校验  对象值+ 状态戳 的期望值（类似于MVCC 中记录数据的版本号操作）</p>
<h4 id="15-volatile关键字作用"><a href="#15-volatile关键字作用" class="headerlink" title="15. volatile关键字作用"></a><strong>15. volatile关键字作用</strong></h4><p>*从主内存中加载 最新的数据</p>
<p>*对共享变量修改后，立刻重写回主内存，即时刷新重写</p>
<p>*为了获取更好的性能 JVM可能会对指令进行重排序，volatile则会对 禁⽌语义重排序</p>
<hr>
<h4 id="1-如何获取-线程-dump-堆栈-⽂件"><a href="#1-如何获取-线程-dump-堆栈-⽂件" class="headerlink" title="1. 如何获取 线程 dump(堆栈)⽂件"></a><strong>1. 如何获取 线程 dump(堆栈)⽂件</strong></h4><p>线程 dump 堆栈； 死循环、死锁、阻塞、⻚面 打开慢等问题，查看线程 dump是最好的解决问题的途径。</p>
<p>获取到线程堆栈有两步：</p>
<p>1.获取到线程的 pid，通过 ps命令， ps -ef | grep java</p>
<p>2.打印线程堆栈，通过 jstack pid 命令，在 Linux环境下还可以使⽤用 kill -3 pid</p>
<p>3.Thread类提供了一个 getStackTrace()方法， 可以获取线程堆栈。此方法和具体线程实例绑定，每次获取到的是某个线程当前运行的堆栈。</p>
<h4 id="2-创建-线程的方式"><a href="#2-创建-线程的方式" class="headerlink" title="2. 创建 线程的方式"></a><strong>2. 创建 线程的方式</strong></h4><ul>
<li>继承 Thread类，重写 run方法</li>
<li>实现 Runnable接口并重写 run方法，实现Runnable接口实现类的实例对象，作为Thread构造函数的target</li>
<li>实现 Callable接口，通过 FutureTask包装器来创建Thread线程</li>
<li>通过 线程池创建线程</li>
</ul>
<h4 id="3-多线程线程数量设置"><a href="#3-多线程线程数量设置" class="headerlink" title="3.多线程线程数量设置"></a><strong>3.多线程线程数量设置</strong></h4><p>A. 高并发、任务执行时间短的业务： 线程池线程数可以设置为 CPU核数+1，减少线程上下⽂的切换。</p>
<p>B. 并发不高、任务执行时间长的业务：</p>
<p>*假如是业务时间长集中在 IO操作上，也就是 IO密集型的任务，因为IO操作并不占⽤用CPU，所以不要让所有的CPU 闲下来，可以加⼤线程池中的线程数目，让CPU处理更多的业务</p>
<p>*假如是业务时间长集中在计算操作上，也就是 计算密集型任务，这个就没办法了，和 (1)一样，线程池中的 线程数设置得少一些，减少线程上下文的切换</p>
<p>C. 并发高、业务执行时间长：解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，</p>
<p>第一步：看这些业务⾥面 某些数据是否能做缓存</p>
<p>第二步：增加服务器 </p>
<p>第三步：使用 中间件 对任务进行 拆分和解耦</p>
<h4 id="4-锁的等级：方法锁、对象锁、类锁"><a href="#4-锁的等级：方法锁、对象锁、类锁" class="headerlink" title="4. 锁的等级：方法锁、对象锁、类锁"></a><strong>4. 锁的等级：方法锁、对象锁、类锁</strong></h4><p>1.方法锁，synchronized修饰方法时</p>
<p>a. 通过在 <strong>方法声明中加入 synchronized 关键字</strong>来声明 synchronized 方法。</p>
<p>b. synchronized 方法控制对 类成员变量的访问：</p>
<p>c. 每个 类实例对应一把锁，每个 synchronized 方法都必须获得 调用该方法的 类实例的锁 方能执行，否则所属线程阻塞，⽅法一旦执行，就独占该锁，直到 从该方法返回时才将锁释放，此后被 阻塞的线程方能获得该锁，重新进⼊可执行状态。</p>
<p>这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从⽽有效避免了类成员变量的访问冲突。</p>
<p>2.对象锁，synchronized修饰方法或代码块</p>
<p>a. 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，必须先获得对象锁。如果对象锁已被其他调用者占用，则需要等待此锁被释放。（⽅法锁也是对象锁）</p>
<p>b. java的所有对象都含有 1个互斥锁，这个锁由 JVM自动获取和释放。线程进入 synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会⾃动释放对象锁。这里也体现了用 synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来自动释放。</p>
<p>3.类锁(synchronized 修饰静态的方法或代码块)</p>
<p>a. 由于一个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有一份。所以，一旦一个静态的⽅法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为 类锁。</p>
<p>4.对象锁 是用来控制实例方法之间的同步，类锁 是用来 控制静态方法（或静态变量互斥体）之间的同步</p>
<p>总结：</p>
<ol>
<li><p>在某个对象的所有synchronized方法中,在某个时刻只能有一个唯一的一个线程去访问这些synchronized方法</p>
</li>
<li><p>如果一个方法是synchronized方法,那么该synchronized关键字表示给当前对象上锁(即this)相当于</p>
</li>
</ol>
<p>synchronized(this){}</p>
<ol start="3">
<li>如果⼀个synchronized方法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管生成多少对象,其对应的class对象只有⼀个)</li>
</ol>
<h4 id="5-并行、并发的区别"><a href="#5-并行、并发的区别" class="headerlink" title="5.并行、并发的区别"></a><strong>5.并行、并发的区别</strong></h4><ol>
<li><p>并行指两个或多个事件在同一时刻发生； 并发指两个或多个事件在 同一时间间隔发生。</p>
</li>
<li><p>并行 是在不同实体上的多个事件，并发是在 同一实体上的多个事件。</p>
</li>
<li><p>并行是在多台处理器上同时处理多个任务；并发是在一台处理器上“同时”处理多个任务。</p>
</li>
</ol>
<p>并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能</p>
<h4 id="6-唤醒一个阻塞的线程"><a href="#6-唤醒一个阻塞的线程" class="headerlink" title="6.唤醒一个阻塞的线程"></a><strong>6.唤醒一个阻塞的线程</strong></h4><p>wait与notify：wait与notify 配合synchronized使用，调用之前持有锁，wait会立即释放锁，notify同步块执行完才释放。</p>
<p>await与singal：Condition类提供，由 new ReentLock().newCondition() 获得Condition对象，与 wait和 notify相同，因为在使用 Lock锁后无法使用wait方法。</p>
<p>park与 unpark：LockSupport 是一个线程阻塞工具，可以在 线程任意位置让线程阻塞。和 Thread.suspenf()相比，它弥补了由于 resume() 在前发生，导致线程⽆法继续执行的情况。和Object.wait()相⽐，它 不需要先获得某个对象的锁，也不会抛出 IException异常。可以唤醒指定线程。</p>
<h4 id="7-如何检测死锁，预防死锁"><a href="#7-如何检测死锁，预防死锁" class="headerlink" title="7. 如何检测死锁，预防死锁"></a><strong>7. 如何检测死锁，预防死锁</strong></h4><p>死锁：两个或两个以上的进程在执行过程中，因 争夺资源而造成一种互相等待 的现象，若无外力作用，它们都将⽆法推进下去。</p>
<p>产生死锁必要条件：</p>
<ol>
<li><p>互斥条件：进程对所 分配到的资源 不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至释放该资源</p>
</li>
<li><p>请求和保持：进程获得资源后，对其他资源发请求，但该资源可能被其他进程占有，此时请求阻塞，但它对已获得资源保持不放</p>
</li>
<li><p>不可剥夺：进程 已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
</li>
<li><p>循环等待：进程发⽣ 死锁后，若干进程之间形成⼀种 头尾相接的 循环等待资源关系</p>
</li>
</ol>
<p><strong>死锁产生原因：</strong></p>
<p>1.竞争资源发⽣死锁：多个进程共享的资源数目不足以满⾜全部进程的需要，引起对资源的竞争</p>
<p>2.进程 推进顺序不当发⽣死锁</p>
<h4 id="8-守护线程"><a href="#8-守护线程" class="headerlink" title="8. 守护线程"></a><strong>8. 守护线程</strong></h4><p>守护线程（daemon thread），是个服务线程，用于服务其他的线程</p>
<p>Java中线程分2种：</p>
<p>1.守护线程，⽐如 垃圾回收线程，最典型的守护线程</p>
<p>2.用户线程，应用程序里的自定义线程</p>
<h4 id="9-synchronized和ReentrantLock-区别"><a href="#9-synchronized和ReentrantLock-区别" class="headerlink" title="9. synchronized和ReentrantLock 区别"></a><strong>9. synchronized和ReentrantLock 区别</strong></h4><p><strong>可重入锁：</strong>同一个线程可以多次获取同一把锁，ReentrantLock和synchronized都是可重入锁。</p>
<p><strong>可中断锁：</strong>线程尝试获取锁的过程中，是否可以响应中断。synchronized 不可中断，ReentrantLock可中断</p>
<p><strong>公平锁：</strong>  多个线程 同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，</p>
<p><strong>非公****平锁：</strong>允许线程“插队”, synchronized：非公平锁，  ReentrantLock的默认：非公平锁，但可以设置为公平锁</p>
<p>Synchronized</p>
<p>Synchronized是  java内置的关键字，它提供了一种独占的加锁方式；Synchronized 的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</p>
<p>局限性：</p>
<ol>
<li><p>当线程尝试获取锁的时候，如果 获取不到锁会一直阻塞。</p>
</li>
<li><p>如果 获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</p>
</li>
</ol>
<p>ReentrantLock:</p>
<ol>
<li><p>ReentrantLock它是JDK 1.5之后提供的 API层面的互斥锁，需要 lock() 和 unlock()方法配合 try&#x2F;finally语句块来完成。</p>
</li>
<li><p>等待可中断避免，出现死锁的情况</p>
</li>
</ol>
<p>（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回 true，如果等待超时，返回false）</p>
<ol start="3">
<li><p>公平锁与非公平锁 多个线程等待同一个锁时，必须按照 申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁</p>
</li>
<li><p>选择性通知： Synchronized只能通过notify, notifyAll 随机唤醒一个或多个等待的线程； ReentrantLock可以和Contition实例配合，指定的线程注册到指定的Contition实例中，实现选择性唤醒。</p>
</li>
</ol>
<h4 id="10-Lock接⼝-Lock-interface"><a href="#10-Lock接⼝-Lock-interface" class="headerlink" title="10. Lock接⼝(Lock interface)"></a><strong>10. Lock接⼝(Lock interface)</strong></h4><p>Lock 接⼝比同步方法和同步块提供更具扩展性的锁操作，他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持 多个相关类的条件对象。</p>
<p>优势：</p>
<p>可以使 锁更公平</p>
<p>可以使 线程在等待锁的时候响应中断</p>
<p>可以让 线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>可以在 不同的范围，以不同的顺序获取和释放锁</p>
<h4 id="11-ConcurrentHashMap-并发度"><a href="#11-ConcurrentHashMap-并发度" class="headerlink" title="11. ConcurrentHashMap 并发度"></a><strong>11. ConcurrentHashMap 并发度</strong></h4><p>1、工作机制（分片思想）：它引入了一个 “分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的segment，</p>
<p>根据 key.hashCode()来决定把 key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>
<p>2、应用：当读 &gt; 写时使用，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；</p>
<p>hash冲突：HashMap中调用 hashCode()方法计算hashCode。由于在Java中两个不同的对象可能有一样的</p>
<p>hashCode,  所以不同的键可能有一样hashCode，从而导致冲突的产生。</p>
<p>hash冲突解决：使用平衡树来代替链表，当同一hash中的元素数量超过 8 时会由链表切换到平衡树</p>
<p>无锁读：ConcurrentHashMap 有较好的并发性，因为 ConcurrentHashMap是 无锁读和加锁写，并且利用分段锁（不是在所有的entry上加锁，而是在一部分entry上加锁）；</p>
<p>ConcurrentHashMap的并发度就是 segment的⼤小，默认为16，这意味着最多同时可以有16条线程操作</p>
<p>ConcurrentHashMap，这也是 ConcurrentHashMap对Hashtable的最⼤优势。 JDK 1.7 后，ConcurrentHashMap 升级为 数组首节点加锁</p>
<h4 id="12-CyclicBarrier-和-CountDownLatch-区别"><a href="#12-CyclicBarrier-和-CountDownLatch-区别" class="headerlink" title="12. CyclicBarrier 和 CountDownLatch 区别"></a><strong>12. CyclicBarrier 和 CountDownLatch 区别</strong></h4><p>CyclicBarrier  和  CountDownLatch 都位于  java.util.concurrent 这个包下</p>
<p>CountDownLatch:  减计数； 计算&#x3D;0时释放所有等待线程； 计数为0后无法重置，不可重复利用； 调用countDown() 方法计数-1，调用await() 方法只进行阻塞，对技术没有任何影响。</p>
<p>CyclicBarrier:  加计数； 计数&#x3D;指定值时，释放所有等待线程； 计数&#x3D;指定值，计数置为0重新开始，可重复利用； 调用await() 方法计数+1， +1后&lt; 指定值时，线程阻塞；</p>
<h4 id="13-Fork-x2F-Join作用"><a href="#13-Fork-x2F-Join作用" class="headerlink" title="13. Fork&#x2F;Join作用"></a><strong>13. Fork&#x2F;Join作用</strong></h4><p>1.Fork ： 把一个 大任务切分为若⼲子任务并行的执行。</p>
<p>2.Join ： 合并这些子任务的执行结果，最后得到这个⼤任务的结果。</p>
<h4 id="14-wait-和sleep-区别"><a href="#14-wait-和sleep-区别" class="headerlink" title="14. wait()和sleep() 区别"></a><strong>14. wait()和sleep() 区别</strong></h4><p>sleep()方法：  线程类（Thread）的静态方法，让调用 线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入 就绪状态和 其他线程一起竞争cpu的执⾏时间。</p>
<p>因为 sleep() 是 static静态的方法，它不能改变对象的锁，当一个 synchronized 块中调⽤ sleep()方法，线程虽然进入休眠，但是对象的锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()方法：  Object类的方法，当一个线程执行到 wait方法时，它就进入到一个和 该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll⽅法来唤醒等待的线程</p>
<h4 id="15-线程的五个状态（创建、就绪、运⾏、阻塞、死亡）"><a href="#15-线程的五个状态（创建、就绪、运⾏、阻塞、死亡）" class="headerlink" title="15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）"></a><strong>15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gursjuuz12j60ha08yjsg02.jpg" alt="A810BC90-DA3F-4760-9FC7-7AD666F47AC6" width="650" height="300" />

<ol>
<li><p>创建状态：生成线程对象，并 没有调用该对象的 start方法，这是线程处于创建状态。</p>
</li>
<li><p>就绪状态：调用线程对象的 start方法之后，进入就绪状态，没有获得时间片则不会执行，从等待或睡眠中醒来，也会处于就绪状态</p>
</li>
<li><p>运行状态： 线程调度程序将 就绪线程设置为当前线程，此时进入运行状态，开始运行 run()函数当中的代码。</p>
</li>
<li><p>阻塞状态： 线程正在运行时被暂停，为等待某个事件的发生(资源就绪)之后再继续运行，sleep, suspend,wait等方法可以导致线程阻塞。</p>
</li>
<li><p>死亡状态： 一个线程 run()方法执行结束或调用stop()方法后，该线程就会死亡，对于死亡的线程，无法再使用 start⽅法使其进入就绪。</p>
</li>
</ol>
<h4 id="16-start-和-run-方法区别"><a href="#16-start-和-run-方法区别" class="headerlink" title="16. start()和 run()方法区别"></a><strong>16. start()和 run()方法区别</strong></h4><p>1.start()方法来 启动一个线程，真正实现多线程运行。</p>
<p>2.如果直接调用 run(), 其实就相当于是调用一个普通函数而已，直接调用 run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本没有线程的特征，所以在多线程执行时要使用 start()方法而不是run()方法。</p>

      
      

      <!-- 修改 -->
      <!-- 
          
            <h2 id="多线程-详解知识点"><a href="#多线程-详解知识点" class="headerlink" title="多线程-详解知识点"></a>多线程-详解知识点</h2><h4 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程:"></a><strong>1. 线程:</strong></h4><p>是 CPU 进行 运算调度的最⼩基本单位，包含在进程之中，没有 独立的资源，共享其进程中的资源，每个线程都有 自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小，系统不会为线程分配内存.</p>
<h4 id="2-线程安全和线程不安全？"><a href="#2-线程安全和线程不安全？" class="headerlink" title="2.  线程安全和线程不安全？"></a><strong>2.  线程安全和线程不安全？</strong></h4><p><strong>线程安全:</strong> 多线程访问时，采用加锁机制，当一个线程访问 该类的某个数据时，进行保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使用, 不会出现数据不一致问题。</p>
<p><strong>线程不安全：</strong>不提供数据访问保护，有可能出现 <strong>多个线程先后更改数据</strong> 造成所得到的数据是脏数据； </p>
<p>线程安全问题 都是由 全局变量，静态变量引起的，若有多个线程同时执行写操作，一般需要考虑线程同步，否则可能影响线程安全。</p>
<p><strong>多线程：</strong>是指从 软件或硬件上实现多个线程的并发技术。</p>
<h4 id="多线程的好处："><a href="#多线程的好处：" class="headerlink" title="多线程的好处："></a>多线程的好处：</h4><p>i. 使用 多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载</p>
<p>ii. 发挥 多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</p>
<h4 id="多线程的缺点："><a href="#多线程的缺点：" class="headerlink" title="多线程的缺点："></a>多线程的缺点：</h4><p>1.大量的 线程降低代码的可读性；</p>
<p>2.更多的 线程需要更多的内存空间</p>
<p>3.当 多个线程对同一个资源出现争夺时候要注意 线程安全的问题。</p>
<h4 id="3-⾃旋锁"><a href="#3-⾃旋锁" class="headerlink" title="3. ⾃旋锁"></a>3. ⾃旋锁</h4><p>1.当线程 A 想要获取一把自旋锁⽽该锁又被其它线程锁持有时，线程 A会在⼀个循环中自旋以检测锁是不是已经可用。</p>
<p><strong>2.自旋锁需要注意：</strong></p>
<ul>
<li>由于 自旋时不释放CPU，持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直自旋，浪费CPU时间。</li>
<li>持有自旋锁的线程在 sleep 之前应该释放自旋锁，以便其它线程可以获得自旋锁。</li>
</ul>
<p>3.目前的 JVM实现自旋会 消耗CPU，如果⻓时间不调用 doNotify方法，doWait方法会一直自旋，CPU会消耗太大</p>
<p>4.自旋锁比较适用于 锁使用者 ，保持锁时间比较短 的情况，这种情况自旋锁的效率比较高</p>
<p>5.自旋锁是一种对 多处理器相当有效的机制，⽽在单处理器非抢占式的系统中基本上没有作⽤</p>
<h4 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4. 乐观锁和悲观锁"></a>4. 乐观锁和悲观锁</h4><p><strong>悲观锁：</strong> 每次都加重锁，认为其他线程会访问共享变量</p>
<p><strong>乐观锁：</strong> 轻量级的锁，认为其他线程不会访问共享变量，修改时进行判断，通过 cas 乐观锁技术 保证数据⼀致性。</p>
<h4 id="5-原⼦操作"><a href="#5-原⼦操作" class="headerlink" title="5. 原⼦操作"></a><strong>5. 原⼦操作</strong></h4><p>在 Java Concurrency API中有些原⼦类(atomic classes)</p>
<p>原子操作：一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的⼿段。</p>
<p>int++： 并不不是一个原子操作，所以当⼀个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>解决问题：<strong>java.util.concurrent. atomic</strong> 包提供了int和long类型，它们可以自动的保证操作是原子的并且不需要使用同步。</p>
<h4 id="6-Executors框架"><a href="#6-Executors框架" class="headerlink" title="6. Executors框架"></a><strong>6.</strong> Executors框架</h4><p>Java通过 Executors 提供四种线程池，分别为：</p>
<p>1.newSingleThreadExecutor 创建一个单线程线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p>
<p>2.newFixedThreadPool 创建一个固定数量线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>3.newCachedThreadPool 创建一个可缓存线程池，如果 线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>4.newScheduledThreadPool 创建一个定⻓线程池，支持 定时及周期性任务执行。</p>
<h4 id="7-阻塞队列"><a href="#7-阻塞队列" class="headerlink" title="7. 阻塞队列"></a><strong>7. 阻塞队列</strong></h4><p> JDK7 提供了 7个阻塞队列（也属于并发容器）</p>
<ol>
<li>ArrayBlockingQueue ：一个由 数组结构组成的 有界阻塞队列</li>
<li>LinkedBlockingQueue ：一个由 链表结构组成的 有界阻塞队列</li>
<li>PriorityBlockingQueue ：一个 支持优先级排序的 无界阻塞队列。</li>
<li>DelayQueue：一个使用 优先级队列实现的 无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的 阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的 无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的 双向阻塞队列。</li>
</ol>
<p><strong>概念：</strong> 阻塞队列 是一个在队列基础上又支持 两个附加操作的队列。</p>
<p>附加操作：</p>
<p>支持阻塞的 插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>支持阻塞的 移除方法：队列空时，获取元素的线程会等待队列变为非空。</p>
<h4 id="8-Callable和Future"><a href="#8-Callable和Future" class="headerlink" title="8. Callable和Future"></a><strong>8. Callable和Future</strong></h4><p>获取线程的执行结果时使用，Callable 用于产生结果，Future用于获取结果；</p>
<p>Callable 接口使用 泛型去定义它的返回类型，Executors 类提供一些有用的方法在线程池中执⾏Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。</p>
<p>在线程池提交Callable任务后返回一个Future对象，使用它可以知道 Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p>
<h4 id="9-FutureTask"><a href="#9-FutureTask" class="headerlink" title="9. FutureTask"></a><strong>9. FutureTask</strong></h4><p>FutureTask 可用于 异步获取执行结果或取消执行任务的场景。</p>
<p>通过传入Runnable或 Callable的任务给 FutureTask，直接调用其 run方法或放入线程池执行，之后可以在外部通过 FutureTask的 get方法异步获取执行结果，因此 FutureTask 非常适合⽤于耗时的计算，主线程可以在完成⾃己的任务后，再去获取结果。另外，FutureTask还可以确保 即使调用多次 run方法，它都只会执行一次 Runnable或 Callable任务，或通过 cancel 取消 FutureTask的执行等。</p>
<p>FutureTask 可用于执行 多任务、以 避免高并发情况下多次创建数据锁的出现。</p>
<h4 id="10-同步容器-和-并发容器"><a href="#10-同步容器-和-并发容器" class="headerlink" title="10. 同步容器 和 并发容器"></a><strong>10. 同步容器 和 并发容器</strong></h4><p>同步容器：</p>
<ul>
<li>主要代表有 Vector和 Hashtable，以及 Collections.synchronizedXxx等；</li>
<li>锁的 粒度为当前对象整体；</li>
<li>迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛ConcurrentModificationException。</li>
</ul>
<p>并发容器：  </p>
<ul>
<li><p>主要代表有 ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。</p>
</li>
<li><p>锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。</p>
</li>
<li><p>迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</p>
</li>
</ul>
<h4 id="11-多线程的上下文切换"><a href="#11-多线程的上下文切换" class="headerlink" title="11. 多线程的上下文切换"></a><strong>11. 多线程的上下文切换</strong></h4><p>CPU 通过 时间片分配算法来循环执行任务，当前一个任务执行一个时间片后，会切换到下一个任务。但在切换前会保存上一个任务的状态，以便下次 切换回这个任务时，可以再次加载这个任务的状态。</p>
<h4 id="12-ThreadLocal的作用"><a href="#12-ThreadLocal的作用" class="headerlink" title="12.ThreadLocal的作用"></a><strong>12.ThreadLocal的作用</strong></h4><p>​        ThreadLocal 类允许 创建 只能被同一个线程读写的变量。因此，如果⼀段代码含有一个 ThreadLocal变量的引用，即使 两个线程同时执行这段代码，它们也 无法访问到对方的ThreadLocal变量量。</p>
<p><strong>线程局部变量:</strong>  在并发编程的时候，成员变量如果不做任何处理, 线程是不安全的，各个线程都在操作同⼀个变量，显然是不行的，volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，需要满足这样⼀个条件：变量是同一个，但每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下 ThreadLocal就⾮常适用，比如说 DAO的数据库连接，DAO是单例的，它的属性 Connection 就不是一个线程安全的变量。每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal 就比较好的解决了这个问题。</p>
<p>​        每个线程都维护了一个map，而这个map的 key就是 threadLocal，而值就是我们set的那个值，每次线程在 get的时候，都从⾃己的变量中取值，既然从⾃己的变量中取值，那肯定就不存在线程安全问题。ThreadLocal这个变量的状态根本没有发生变化，他仅是充当一个 key的⻆色，另外提供给每一个线程一个初始值。</p>
<h4 id="13-ThreadPool（线程池）用法与优势"><a href="#13-ThreadPool（线程池）用法与优势" class="headerlink" title="13. ThreadPool（线程池）用法与优势"></a><strong>13. ThreadPool（线程池）用法与优势</strong></h4><p>优点：</p>
<p>1.减少 创建和销毁线程的次数，每个工作线程都可以被重复利用，可执⾏多个任务</p>
<p>2.可以根据系统的承受能力，调整 线程池中工作线程的数目，防⽌因为消耗过多的内存，而把服务器累趴下</p>
<p>(每个线程需要⼤约 1MB内存，线程开的越多，消耗的内存也就越大，最后死机)；减少在 创建和销毁线程上所花的时间以及系统资源的开销</p>
<p>如不使⽤用线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存</p>
<p>Java⾥⾯线程池的顶级接口： Executor，但严格意义上讲 Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具，真正的线程池接⼜是 ExecutorService。</p>
<ul>
<li>当线程数 &lt; corePoolSize时，创建线程执⾏行行任务。</li>
<li>当线程数 &gt;&#x3D; corePoolSize并且 workQueue没有满时，放入workQueue中</li>
<li>线程数  &gt;&#x3D;corePoolSize并且 workQueue满时，新任务<strong>新建线程运行</strong>，线程总数要 &lt; maximumPoolSize</li>
<li>当线程总数 &#x3D;maximumPoolSize并且 workQueue满了的时候，执行 handler的rejectedExecution 拒绝策略</li>
</ul>
<h4 id="14-CAS-产生的ABA-问题"><a href="#14-CAS-产生的ABA-问题" class="headerlink" title="14.CAS 产生的ABA 问题"></a><strong>14.CAS 产生的ABA 问题</strong></h4><p>原节点 A ，改变头节点 2次， 先改为 B， 改变B 指针的指向（插入链表的表头，成为新头节点），最后再改回节点 A ，对于节点，其实际的 值没有改变，但此时 指针的指向 已经发生了改变</p>
<p>解决：</p>
<p>加入版本号，在内部维护一个状态戳（时间戳），每次修改对象值的同时，也改变状态戳，</p>
<p>在校验 CAS 时，同时校验  对象值+ 状态戳 的期望值（类似于MVCC 中记录数据的版本号操作）</p>
<h4 id="15-volatile关键字作用"><a href="#15-volatile关键字作用" class="headerlink" title="15. volatile关键字作用"></a><strong>15. volatile关键字作用</strong></h4><p>*从主内存中加载 最新的数据</p>
<p>*对共享变量修改后，立刻重写回主内存，即时刷新重写</p>
<p>*为了获取更好的性能 JVM可能会对指令进行重排序，volatile则会对 禁⽌语义重排序</p>
<hr>
<h4 id="1-如何获取-线程-dump-堆栈-⽂件"><a href="#1-如何获取-线程-dump-堆栈-⽂件" class="headerlink" title="1. 如何获取 线程 dump(堆栈)⽂件"></a><strong>1. 如何获取 线程 dump(堆栈)⽂件</strong></h4><p>线程 dump 堆栈； 死循环、死锁、阻塞、⻚面 打开慢等问题，查看线程 dump是最好的解决问题的途径。</p>
<p>获取到线程堆栈有两步：</p>
<p>1.获取到线程的 pid，通过 ps命令， ps -ef | grep java</p>
<p>2.打印线程堆栈，通过 jstack pid 命令，在 Linux环境下还可以使⽤用 kill -3 pid</p>
<p>3.Thread类提供了一个 getStackTrace()方法， 可以获取线程堆栈。此方法和具体线程实例绑定，每次获取到的是某个线程当前运行的堆栈。</p>
<h4 id="2-创建-线程的方式"><a href="#2-创建-线程的方式" class="headerlink" title="2. 创建 线程的方式"></a><strong>2. 创建 线程的方式</strong></h4><ul>
<li>继承 Thread类，重写 run方法</li>
<li>实现 Runnable接口并重写 run方法，实现Runnable接口实现类的实例对象，作为Thread构造函数的target</li>
<li>实现 Callable接口，通过 FutureTask包装器来创建Thread线程</li>
<li>通过 线程池创建线程</li>
</ul>
<h4 id="3-多线程线程数量设置"><a href="#3-多线程线程数量设置" class="headerlink" title="3.多线程线程数量设置"></a><strong>3.多线程线程数量设置</strong></h4><p>A. 高并发、任务执行时间短的业务： 线程池线程数可以设置为 CPU核数+1，减少线程上下⽂的切换。</p>
<p>B. 并发不高、任务执行时间长的业务：</p>
<p>*假如是业务时间长集中在 IO操作上，也就是 IO密集型的任务，因为IO操作并不占⽤用CPU，所以不要让所有的CPU 闲下来，可以加⼤线程池中的线程数目，让CPU处理更多的业务</p>
<p>*假如是业务时间长集中在计算操作上，也就是 计算密集型任务，这个就没办法了，和 (1)一样，线程池中的 线程数设置得少一些，减少线程上下文的切换</p>
<p>C. 并发高、业务执行时间长：解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，</p>
<p>第一步：看这些业务⾥面 某些数据是否能做缓存</p>
<p>第二步：增加服务器 </p>
<p>第三步：使用 中间件 对任务进行 拆分和解耦</p>
<h4 id="4-锁的等级：方法锁、对象锁、类锁"><a href="#4-锁的等级：方法锁、对象锁、类锁" class="headerlink" title="4. 锁的等级：方法锁、对象锁、类锁"></a><strong>4. 锁的等级：方法锁、对象锁、类锁</strong></h4><p>1.方法锁，synchronized修饰方法时</p>
<p>a. 通过在 <strong>方法声明中加入 synchronized 关键字</strong>来声明 synchronized 方法。</p>
<p>b. synchronized 方法控制对 类成员变量的访问：</p>
<p>c. 每个 类实例对应一把锁，每个 synchronized 方法都必须获得 调用该方法的 类实例的锁 方能执行，否则所属线程阻塞，⽅法一旦执行，就独占该锁，直到 从该方法返回时才将锁释放，此后被 阻塞的线程方能获得该锁，重新进⼊可执行状态。</p>
<p>这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从⽽有效避免了类成员变量的访问冲突。</p>
<p>2.对象锁，synchronized修饰方法或代码块</p>
<p>a. 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，必须先获得对象锁。如果对象锁已被其他调用者占用，则需要等待此锁被释放。（⽅法锁也是对象锁）</p>
<p>b. java的所有对象都含有 1个互斥锁，这个锁由 JVM自动获取和释放。线程进入 synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会⾃动释放对象锁。这里也体现了用 synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来自动释放。</p>
<p>3.类锁(synchronized 修饰静态的方法或代码块)</p>
<p>a. 由于一个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有一份。所以，一旦一个静态的⽅法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为 类锁。</p>
<p>4.对象锁 是用来控制实例方法之间的同步，类锁 是用来 控制静态方法（或静态变量互斥体）之间的同步</p>
<p>总结：</p>
<ol>
<li><p>在某个对象的所有synchronized方法中,在某个时刻只能有一个唯一的一个线程去访问这些synchronized方法</p>
</li>
<li><p>如果一个方法是synchronized方法,那么该synchronized关键字表示给当前对象上锁(即this)相当于</p>
</li>
</ol>
<p>synchronized(this){}</p>
<ol start="3">
<li>如果⼀个synchronized方法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管生成多少对象,其对应的class对象只有⼀个)</li>
</ol>
<h4 id="5-并行、并发的区别"><a href="#5-并行、并发的区别" class="headerlink" title="5.并行、并发的区别"></a><strong>5.并行、并发的区别</strong></h4><ol>
<li><p>并行指两个或多个事件在同一时刻发生； 并发指两个或多个事件在 同一时间间隔发生。</p>
</li>
<li><p>并行 是在不同实体上的多个事件，并发是在 同一实体上的多个事件。</p>
</li>
<li><p>并行是在多台处理器上同时处理多个任务；并发是在一台处理器上“同时”处理多个任务。</p>
</li>
</ol>
<p>并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能</p>
<h4 id="6-唤醒一个阻塞的线程"><a href="#6-唤醒一个阻塞的线程" class="headerlink" title="6.唤醒一个阻塞的线程"></a><strong>6.唤醒一个阻塞的线程</strong></h4><p>wait与notify：wait与notify 配合synchronized使用，调用之前持有锁，wait会立即释放锁，notify同步块执行完才释放。</p>
<p>await与singal：Condition类提供，由 new ReentLock().newCondition() 获得Condition对象，与 wait和 notify相同，因为在使用 Lock锁后无法使用wait方法。</p>
<p>park与 unpark：LockSupport 是一个线程阻塞工具，可以在 线程任意位置让线程阻塞。和 Thread.suspenf()相比，它弥补了由于 resume() 在前发生，导致线程⽆法继续执行的情况。和Object.wait()相⽐，它 不需要先获得某个对象的锁，也不会抛出 IException异常。可以唤醒指定线程。</p>
<h4 id="7-如何检测死锁，预防死锁"><a href="#7-如何检测死锁，预防死锁" class="headerlink" title="7. 如何检测死锁，预防死锁"></a><strong>7. 如何检测死锁，预防死锁</strong></h4><p>死锁：两个或两个以上的进程在执行过程中，因 争夺资源而造成一种互相等待 的现象，若无外力作用，它们都将⽆法推进下去。</p>
<p>产生死锁必要条件：</p>
<ol>
<li><p>互斥条件：进程对所 分配到的资源 不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至释放该资源</p>
</li>
<li><p>请求和保持：进程获得资源后，对其他资源发请求，但该资源可能被其他进程占有，此时请求阻塞，但它对已获得资源保持不放</p>
</li>
<li><p>不可剥夺：进程 已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
</li>
<li><p>循环等待：进程发⽣ 死锁后，若干进程之间形成⼀种 头尾相接的 循环等待资源关系</p>
</li>
</ol>
<p><strong>死锁产生原因：</strong></p>
<p>1.竞争资源发⽣死锁：多个进程共享的资源数目不足以满⾜全部进程的需要，引起对资源的竞争</p>
<p>2.进程 推进顺序不当发⽣死锁</p>
<h4 id="8-守护线程"><a href="#8-守护线程" class="headerlink" title="8. 守护线程"></a><strong>8. 守护线程</strong></h4><p>守护线程（daemon thread），是个服务线程，用于服务其他的线程</p>
<p>Java中线程分2种：</p>
<p>1.守护线程，⽐如 垃圾回收线程，最典型的守护线程</p>
<p>2.用户线程，应用程序里的自定义线程</p>
<h4 id="9-synchronized和ReentrantLock-区别"><a href="#9-synchronized和ReentrantLock-区别" class="headerlink" title="9. synchronized和ReentrantLock 区别"></a><strong>9. synchronized和ReentrantLock 区别</strong></h4><p><strong>可重入锁：</strong>同一个线程可以多次获取同一把锁，ReentrantLock和synchronized都是可重入锁。</p>
<p><strong>可中断锁：</strong>线程尝试获取锁的过程中，是否可以响应中断。synchronized 不可中断，ReentrantLock可中断</p>
<p><strong>公平锁：</strong>  多个线程 同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，</p>
<p><strong>非公****平锁：</strong>允许线程“插队”, synchronized：非公平锁，  ReentrantLock的默认：非公平锁，但可以设置为公平锁</p>
<p>Synchronized</p>
<p>Synchronized是  java内置的关键字，它提供了一种独占的加锁方式；Synchronized 的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</p>
<p>局限性：</p>
<ol>
<li><p>当线程尝试获取锁的时候，如果 获取不到锁会一直阻塞。</p>
</li>
<li><p>如果 获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</p>
</li>
</ol>
<p>ReentrantLock:</p>
<ol>
<li><p>ReentrantLock它是JDK 1.5之后提供的 API层面的互斥锁，需要 lock() 和 unlock()方法配合 try&#x2F;finally语句块来完成。</p>
</li>
<li><p>等待可中断避免，出现死锁的情况</p>
</li>
</ol>
<p>（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回 true，如果等待超时，返回false）</p>
<ol start="3">
<li><p>公平锁与非公平锁 多个线程等待同一个锁时，必须按照 申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁</p>
</li>
<li><p>选择性通知： Synchronized只能通过notify, notifyAll 随机唤醒一个或多个等待的线程； ReentrantLock可以和Contition实例配合，指定的线程注册到指定的Contition实例中，实现选择性唤醒。</p>
</li>
</ol>
<h4 id="10-Lock接⼝-Lock-interface"><a href="#10-Lock接⼝-Lock-interface" class="headerlink" title="10. Lock接⼝(Lock interface)"></a><strong>10. Lock接⼝(Lock interface)</strong></h4><p>Lock 接⼝比同步方法和同步块提供更具扩展性的锁操作，他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持 多个相关类的条件对象。</p>
<p>优势：</p>
<p>可以使 锁更公平</p>
<p>可以使 线程在等待锁的时候响应中断</p>
<p>可以让 线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>可以在 不同的范围，以不同的顺序获取和释放锁</p>
<h4 id="11-ConcurrentHashMap-并发度"><a href="#11-ConcurrentHashMap-并发度" class="headerlink" title="11. ConcurrentHashMap 并发度"></a><strong>11. ConcurrentHashMap 并发度</strong></h4><p>1、工作机制（分片思想）：它引入了一个 “分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的segment，</p>
<p>根据 key.hashCode()来决定把 key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>
<p>2、应用：当读 &gt; 写时使用，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；</p>
<p>hash冲突：HashMap中调用 hashCode()方法计算hashCode。由于在Java中两个不同的对象可能有一样的</p>
<p>hashCode,  所以不同的键可能有一样hashCode，从而导致冲突的产生。</p>
<p>hash冲突解决：使用平衡树来代替链表，当同一hash中的元素数量超过 8 时会由链表切换到平衡树</p>
<p>无锁读：ConcurrentHashMap 有较好的并发性，因为 ConcurrentHashMap是 无锁读和加锁写，并且利用分段锁（不是在所有的entry上加锁，而是在一部分entry上加锁）；</p>
<p>ConcurrentHashMap的并发度就是 segment的⼤小，默认为16，这意味着最多同时可以有16条线程操作</p>
<p>ConcurrentHashMap，这也是 ConcurrentHashMap对Hashtable的最⼤优势。 JDK 1.7 后，ConcurrentHashMap 升级为 数组首节点加锁</p>
<h4 id="12-CyclicBarrier-和-CountDownLatch-区别"><a href="#12-CyclicBarrier-和-CountDownLatch-区别" class="headerlink" title="12. CyclicBarrier 和 CountDownLatch 区别"></a><strong>12. CyclicBarrier 和 CountDownLatch 区别</strong></h4><p>CyclicBarrier  和  CountDownLatch 都位于  java.util.concurrent 这个包下</p>
<p>CountDownLatch:  减计数； 计算&#x3D;0时释放所有等待线程； 计数为0后无法重置，不可重复利用； 调用countDown() 方法计数-1，调用await() 方法只进行阻塞，对技术没有任何影响。</p>
<p>CyclicBarrier:  加计数； 计数&#x3D;指定值时，释放所有等待线程； 计数&#x3D;指定值，计数置为0重新开始，可重复利用； 调用await() 方法计数+1， +1后&lt; 指定值时，线程阻塞；</p>
<h4 id="13-Fork-x2F-Join作用"><a href="#13-Fork-x2F-Join作用" class="headerlink" title="13. Fork&#x2F;Join作用"></a><strong>13. Fork&#x2F;Join作用</strong></h4><p>1.Fork ： 把一个 大任务切分为若⼲子任务并行的执行。</p>
<p>2.Join ： 合并这些子任务的执行结果，最后得到这个⼤任务的结果。</p>
<h4 id="14-wait-和sleep-区别"><a href="#14-wait-和sleep-区别" class="headerlink" title="14. wait()和sleep() 区别"></a><strong>14. wait()和sleep() 区别</strong></h4><p>sleep()方法：  线程类（Thread）的静态方法，让调用 线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入 就绪状态和 其他线程一起竞争cpu的执⾏时间。</p>
<p>因为 sleep() 是 static静态的方法，它不能改变对象的锁，当一个 synchronized 块中调⽤ sleep()方法，线程虽然进入休眠，但是对象的锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()方法：  Object类的方法，当一个线程执行到 wait方法时，它就进入到一个和 该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll⽅法来唤醒等待的线程</p>
<h4 id="15-线程的五个状态（创建、就绪、运⾏、阻塞、死亡）"><a href="#15-线程的五个状态（创建、就绪、运⾏、阻塞、死亡）" class="headerlink" title="15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）"></a><strong>15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gursjuuz12j60ha08yjsg02.jpg" alt="A810BC90-DA3F-4760-9FC7-7AD666F47AC6" width="650" height="300" />

<ol>
<li><p>创建状态：生成线程对象，并 没有调用该对象的 start方法，这是线程处于创建状态。</p>
</li>
<li><p>就绪状态：调用线程对象的 start方法之后，进入就绪状态，没有获得时间片则不会执行，从等待或睡眠中醒来，也会处于就绪状态</p>
</li>
<li><p>运行状态： 线程调度程序将 就绪线程设置为当前线程，此时进入运行状态，开始运行 run()函数当中的代码。</p>
</li>
<li><p>阻塞状态： 线程正在运行时被暂停，为等待某个事件的发生(资源就绪)之后再继续运行，sleep, suspend,wait等方法可以导致线程阻塞。</p>
</li>
<li><p>死亡状态： 一个线程 run()方法执行结束或调用stop()方法后，该线程就会死亡，对于死亡的线程，无法再使用 start⽅法使其进入就绪。</p>
</li>
</ol>
<h4 id="16-start-和-run-方法区别"><a href="#16-start-和-run-方法区别" class="headerlink" title="16. start()和 run()方法区别"></a><strong>16. start()和 run()方法区别</strong></h4><p>1.start()方法来 启动一个线程，真正实现多线程运行。</p>
<p>2.如果直接调用 run(), 其实就相当于是调用一个普通函数而已，直接调用 run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本没有线程的特征，所以在多线程执行时要使用 start()方法而不是run()方法。</p>

          
        
    </div> -->


    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://turbocome.github.io/TurboCome/2022/06/08/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%AF%A6%E8%A7%A3%E7%9F%A5%E8%AF%86%E7%82%B9/" title="多线程-详解知识点" target="_blank" rel="external">https://turbocome.github.io/TurboCome/2022/06/08/多线程/4.多线程-详解知识点/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/TurboCome" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/TurboCome/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/TurboCome" target="_blank"><span class="text-dark">TurboCome</span><small class="ml-1x">Java Developer</small></a></h3>
        <div>淡泊明志，宁静致远</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/TurboCome/2022/06/09/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.AQS%E8%AF%A6%E8%A7%A3/" title="多线程-AQS详解"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/TurboCome/2022/06/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/" title="多线程-编程实战"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  <!-- Button trigger modal -->
  <button type="button" class="btn btn-fancy btn-donate pop-onhover bg-gradient-warning" data-toggle="modal" data-target="#donateModal"><span>赏</span></button>
  <!-- <div class="wave-icon wave-icon-danger btn-donate" data-toggle="modal" data-target="#donateModal">
    <div class="wave-circle"><span class="icon"><i class="icon icon-bill"></i></span></div>
  </div> -->
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat" data-mobile-sites="weibo,qq"></div>
    
  </div>
  </div>
</nav>
  
<!-- Modal -->
<div class="modal modal-center modal-small modal-xs-full fade" id="donateModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content donate">
      <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
      <div class="modal-body">
        <div class="donate-box">
          <div class="donate-head">
            <p>感谢您的支持，我会继续努力的!</p>
          </div>
          <div class="tab-content">
            <div role="tabpanel" class="tab-pane fade active in" id="alipay">
              <div class="donate-payimg">
                <img src="/TurboCome/images/donate/alipayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开支付宝扫一扫，即可进行扫码打赏哦</p>
            </div>
            <div role="tabpanel" class="tab-pane fade" id="wechatpay">
              <div class="donate-payimg">
                <img src="/TurboCome/images/donate/wechatpayimg.png" alt="扫码支持" title="扫一扫" />
              </div>
              <p class="text-muted mv">扫码打赏，你说多少就多少</p>
              <p class="text-grey">打开微信扫一扫，即可进行扫码打赏哦</p>
            </div>
          </div>
          <div class="donate-footer">
            <ul class="nav nav-tabs nav-justified" role="tablist">
              <li role="presentation" class="active">
                <a href="#alipay" id="alipay-tab" role="tab" data-toggle="tab" aria-controls="alipay" aria-expanded="true"><i class="icon icon-alipay"></i> 支付宝</a>
              </li>
              <li role="presentation" class="">
                <a href="#wechatpay" role="tab" id="wechatpay-tab" data-toggle="tab" aria-controls="wechatpay" aria-expanded="false"><i class="icon icon-wepay"></i> 微信支付</a>
              </li>
            </ul>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>



</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/TurboCome" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/TurboCome/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/TurboCome/js/plugin.min.js"></script>


<script src="/TurboCome/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/TurboCome/',
        CONTENT_URL: '/TurboCome/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/TurboCome/js/insight.js"></script>






   
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>