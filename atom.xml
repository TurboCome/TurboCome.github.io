<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TurboCome</title>
  
  <subtitle>Wang Hongqiang</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-08-07T15:05:05.125Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TurboCome</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>多种限流方式实现</title>
    <link href="http://example.com/2022/08/07/H-%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%A7%8D%E9%99%90%E6%B5%81/"/>
    <id>http://example.com/2022/08/07/H-%E9%AB%98%E5%B9%B6%E5%8F%91/%E5%A4%9A%E7%A7%8D%E9%99%90%E6%B5%81/</id>
    <published>2022-08-07T15:41:19.000Z</published>
    <updated>2022-08-07T15:05:05.125Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多种限流方式实现"><a href="#多种限流方式实现" class="headerlink" title="多种限流方式实现"></a>多种限流方式实现</h2><p>在高并发系统中，出于对系统的保护，通常会对流量进行限制，即限流。常见的限流有以下五种方式：</p><h3 id="一、固定窗口"><a href="#一、固定窗口" class="headerlink" title="一、固定窗口"></a><strong>一、固定窗口</strong></h3><p>​    又称计数器算法（Fixed Window），是最简单的限流算法，通过在单位时间内维护的计数器来控制该时间单位内的最大访问量。</p><p>​    假设限制每分钟请求量不超过60，设置一个计数器，当请求到达时，如果计数器到达阈值，则拒绝请求，否则计数器 +1；每分钟重置计数器为0。实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CounterRateLimiter</span> <span class="keyword">extends</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line">    <span class="comment">// 每秒限制请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> permitsPerSecond;</span><br><span class="line">    <span class="comment">// 上一个窗口的开始时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> counter;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CounterRateLimiter</span><span class="params">(<span class="type">long</span> permitsPerSecond)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerSecond = permitsPerSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 窗口内请求数量小于阈值，更新计数放行，否则拒绝请求</span></span><br><span class="line">        <span class="keyword">if</span> (now - timestamp &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter &lt; permitsPerSecond) &#123;</span><br><span class="line">                counter++;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 时间窗口过期，重置计数器和时间戳</span></span><br><span class="line">        counter = <span class="number">0</span>;</span><br><span class="line">        timestamp = now;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>固定窗口: </p><p>优点:  <strong>易于实现</strong>;  <strong>内存占用小</strong>，只需存储时间窗口中的计数即可；能够确保处理更多的最新请求，不会因为旧请求的堆积导致新请求被饿死。</p><p>缺点：<strong>临界问题</strong>，当两个窗口交界处，瞬时流量可能为2n，但在边界处可能被均分、放行，没有实现流量的限制。</p><h3 id="二、滑动窗口"><a href="#二、滑动窗口" class="headerlink" title="二、滑动窗口"></a><strong>二、滑动窗口</strong></h3><p>​    为解决固定窗口处的临界问题，可以把固定窗口近一步划分成多个小格子，每次向后移动一小格，而不是固定窗口大小。</p><p>比如每分钟可以分为 6个10秒中的单元格，每个格子中分别维护一个计数器，窗口每次向前滑动一个单元格。每当请求到达时，只要窗口中所有单元格的计数总和不超过阈值都可以放行。TCP协议中数据包的传输，同样也是采用滑动窗口来进行流量控制。</p><h5 id="具体代码实现："><a href="#具体代码实现：" class="headerlink" title="具体代码实现："></a>具体代码实现：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SlidingWindowRateLimiter</span> <span class="keyword">extends</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line">    <span class="comment">// 每分钟限制请求数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> permitsPerMinute;</span><br><span class="line">    <span class="comment">// 计数器, k-为当前窗口的开始时间值秒，value为当前窗口的计数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TreeMap&lt;Long, Integer&gt; counters;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SlidingWindowRateLimiter</span><span class="params">(<span class="type">long</span> permitsPerMinute)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerMinute = permitsPerMinute;</span><br><span class="line">        <span class="built_in">this</span>.counters = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取当前时间的所在子窗口值； 10s一个窗口</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">currentWindowTime</span> <span class="operator">=</span> LocalDateTime.now().toEpochSecond(ZoneOffset.UTC) / <span class="number">10</span> * <span class="number">10</span>;</span><br><span class="line">        <span class="comment">// 获取当前窗口的请求总量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">currentWindowCount</span> <span class="operator">=</span> getCurrentWindowCount(currentWindowTime);</span><br><span class="line">        <span class="keyword">if</span> (currentWindowCount &gt;= permitsPerMinute) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计数器 + 1</span></span><br><span class="line">        counters.merge(currentWindowTime, <span class="number">1</span>, Integer::sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前窗口中的所有请求数（并删除所有无效的子窗口计数器）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> currentWindowTime 当前子窗口时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 当前窗口中的计数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getCurrentWindowCount</span><span class="params">(<span class="type">long</span> currentWindowTime)</span> &#123;</span><br><span class="line">        <span class="comment">// 计算出窗口的开始位置时间</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> currentWindowTime - <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 遍历当前存储的计数器，删除无效的子窗口计数器，并累加当前窗口中的所有计数器之和</span></span><br><span class="line">        Iterator&lt;Map.Entry&lt;Long, Integer&gt;&gt; iterator = counters.entrySet().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;Long, Integer&gt; entry = iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (entry.getKey() &lt; startTime) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result += entry.getValue();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="滑动窗口："><a href="#滑动窗口：" class="headerlink" title="滑动窗口："></a>滑动窗口：</h5><p>优点：解决了计数器中的临界问题。当窗口划分的粒度越细，则流量控制更加精准和严格。</p><p>缺点：当窗口中流量到达阈值时，流量会瞬间切断，在实际应用中的限流效果往往不是把流量一下子掐断，而是让流量平滑地进入系统当中。</p><h3 id="三、漏桶算法"><a href="#三、漏桶算法" class="headerlink" title="三、漏桶算法"></a><strong>三、漏桶算法</strong></h3><p>​    漏桶算法（Leaky Bucket），请求就像水一样以任意速度注入漏桶，而桶会按照固定的速率将水漏掉；当注入速度大于漏出的速度时，漏桶会变满，此时新进入的请求会被丢弃。<strong>限流</strong>和<strong>整形</strong>是漏桶算法的两个核心能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeakyBucketRateLimiter</span> <span class="keyword">extends</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line">    <span class="comment">// 桶的容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="comment">// 漏出速率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> permitsPerSecond;</span><br><span class="line">    <span class="comment">// 剩余水量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> leftWater;</span><br><span class="line">    <span class="comment">// 上次注入时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> <span class="variable">timeStamp</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LeakyBucketRateLimiter</span><span class="params">(<span class="type">int</span> permitsPerSecond, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="built_in">this</span>.permitsPerSecond = permitsPerSecond;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1. 计算剩余水量</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeGap</span> <span class="operator">=</span> (now - timeStamp) / <span class="number">1000</span>;</span><br><span class="line">        leftWater = Math.max(<span class="number">0</span>, leftWater - timeGap * permitsPerSecond);</span><br><span class="line">        timeStamp = now;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果未满，则放行；否则限流</span></span><br><span class="line">        <span class="keyword">if</span> (leftWater &lt; capacity) &#123;</span><br><span class="line">            leftWater += <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    以恒定的速率漏出流量，需要配合一个 FIFO队列来实现，当 tryAcquire返回true时，将请求入队，然后再以固定频率从队列中取出请求进行处理。实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testLeakyBucketRateLimiter</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">scheduledExecutorService</span> <span class="operator">=</span> Executors.newSingleThreadScheduledExecutor();</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">singleThread</span> <span class="operator">=</span> Executors.newSingleThreadExecutor();</span><br><span class="line"></span><br><span class="line">    <span class="type">LeakyBucketRateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LeakyBucketRateLimiter</span>(<span class="number">20</span>, <span class="number">20</span>);</span><br><span class="line">    <span class="comment">// 存储流量的队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 模拟请求  不确定速率注水</span></span><br><span class="line">    singleThread.execute(() -&gt; &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> rateLimiter.tryAcquire();</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                queue.offer(count);</span><br><span class="line">                System.out.println(count + <span class="string">&quot;--------流量被放行--------&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(count + <span class="string">&quot;流量被限制&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep((<span class="type">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 模拟处理请求 固定速率漏水</span></span><br><span class="line">    scheduledExecutorService.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            System.out.println(queue.poll() + <span class="string">&quot;被处理&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="number">0</span>, <span class="number">100</span>, TimeUnit.MILLISECONDS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证主线程不会退出</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="漏桶算法："><a href="#漏桶算法：" class="headerlink" title="漏桶算法："></a>漏桶算法：</h4><p>优点：<strong>平滑突发的流量</strong>，提供一种机制来确保网络中的突发流量被整合成平滑稳定的流量。</p><p>缺点：由于漏桶对流量的控制过于严格，有些场景下<strong>不能充分使用系统资源</strong>，因为漏桶的漏出速率是固定的，即使在某一时刻下游能够处理更大的流量，漏桶也不允许突发流量通过。</p><h3 id="四、令牌桶"><a href="#四、令牌桶" class="headerlink" title="四、令牌桶"></a><strong>四、令牌桶</strong></h3><p>​    以恒定速率向令牌桶发送令牌，请求到达时，尝试从令牌桶中拿令牌，只有拿到令牌才能够放行，否则将会被拒绝。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h4yllhoxnyj215o0o6769.jpg" alt="image-20220807230218927" style="zoom:40%;" /><h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><h5 id="1-以恒定的速率发放令牌，假设限流速率为-v-x2F-s，则表示每-1-x2F-v-秒发放一个令牌"><a href="#1-以恒定的速率发放令牌，假设限流速率为-v-x2F-s，则表示每-1-x2F-v-秒发放一个令牌" class="headerlink" title="1.以恒定的速率发放令牌，假设限流速率为 v&#x2F;s，则表示每 1&#x2F;v 秒发放一个令牌"></a>1.以恒定的速率发放令牌，假设限流速率为 v&#x2F;s，则表示每 1&#x2F;v 秒发放一个令牌</h5><h5 id="2-令牌桶容量是b，如果令牌桶已满，则新的令牌会被丢弃"><a href="#2-令牌桶容量是b，如果令牌桶已满，则新的令牌会被丢弃" class="headerlink" title="2.令牌桶容量是b，如果令牌桶已满，则新的令牌会被丢弃"></a>2.令牌桶容量是b，如果令牌桶已满，则新的令牌会被丢弃</h5><h5 id="3-请求能够通过限流器的前提是令牌桶中有令牌"><a href="#3-请求能够通过限流器的前提是令牌桶中有令牌" class="headerlink" title="3.请求能够通过限流器的前提是令牌桶中有令牌"></a>3.请求能够通过限流器的前提是令牌桶中有令牌</h5><p>令牌桶算法中有两个参数：限流速率a 、令牌桶容量b；比如 b&#x3D;10，当令牌桶满的时候有10个可用令牌，此时允许10个请求同时通过限流器（<strong>允许流量一定程度的突发</strong>），这10个请求瞬间消耗完令牌后，后续的流量只能按照速率 a 通过限流器。</p><p><strong>代码实现:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenBucketRateLimiter</span> <span class="keyword">extends</span> <span class="title class_">MyRateLimiter</span> &#123;</span><br><span class="line">    <span class="comment">// 令牌桶的容量「限流器允许的最大突发流量」</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> capacity;</span><br><span class="line">    <span class="comment">// 令牌发放速率</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">long</span> generatedPerSeconds;</span><br><span class="line">    <span class="comment">// 最后一个令牌发放的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">lastTokenTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 当前令牌数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> currentTokens;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TokenBucketRateLimiter</span><span class="params">(<span class="type">long</span> generatedPerSeconds, <span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.generatedPerSeconds = generatedPerSeconds;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 尝试获取令牌</span></span><br><span class="line"><span class="comment">     * true表示获取到令牌，放行；否则为限流</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line">          <span class="comment">/**</span></span><br><span class="line"><span class="comment">           * 计算令牌当前数量</span></span><br><span class="line"><span class="comment">           * 请求时间在最后令牌是产生时间相差大于等于额1s（为啥时1s？因为生成令牌的最小时间单位时s），</span></span><br><span class="line"><span class="comment">           * 1. 重新计算令牌桶中的令牌数</span></span><br><span class="line"><span class="comment">           * 2. 将最后一个令牌发放时间重置为当前时间</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (now - lastTokenTime &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">newPermits</span> <span class="operator">=</span> (now - lastTokenTime) / <span class="number">1000</span> * generatedPerSeconds;</span><br><span class="line">            currentTokens = Math.min(currentTokens + newPermits, capacity);</span><br><span class="line">            lastTokenTime = now;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (currentTokens &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            currentTokens--;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：在限制流量速率的前提下，又能够允许突发流量。</p><h3 id="分布式限流"><a href="#分布式限流" class="headerlink" title="分布式限流"></a><strong>分布式限流</strong></h3><p>​    以上几种限流算法的实现都仅适合单机限流。虽然给每台机器平均分配限流配额可以达到限流的目的，但是由于机器性能，流量分布不均以及计算数量动态变化等问题，单机限流在分布式场景中的效果总是差强人意。</p><p>​    在分布式系统中，仅仅使用单机的性能为指标作为限流的依据，极有可能将数据库、redis这种集中式的服务打挂，并且很难进行全局范围内的精确流量限制。因此需要一套分布式限流器在分布式环境中，对资源整体的QPS进行限流，解决因单机流量不均、实例数变化等场景造成的限流不准确、不易维护的问题。</p><p>​    分布式限流最简单的实现就是利用中心化存储，将 单机限流存储在本地的数据存储到同一个存储空间中，如常见的Redis等。比较方便的一种实现方式是借助 Redis&#x2F;Memcache做统一Token存储管理，然后实现上述所介绍的各种算法如令牌桶、计数器算法等来作为一个分布式限流器。</p><h3 id="更高QPS的分布式限流器："><a href="#更高QPS的分布式限流器：" class="headerlink" title="更高QPS的分布式限流器："></a><strong>更高QPS的分布式限流器：</strong></h3><p>​    这类分布式精准限流器普遍存在的问题是由于依赖Redis&#x2F;Memcache而存在一个QPS限流值较高情况下达到资源极限无法满足需求（Redis单机10W上限）。因此对于类似于春节这种大型活动，需要一个能提供更高QPS限流上限的分布式限流器。</p><p>​    一种常见的做法是在令牌桶算法的基础上引入Step的概念，依然基于 Redis&#x2F; Memcache作为中心存储，但是 取令牌的时候每次以步长为单位去获取令牌并存储到本地缓存，新的请求进入需要先去本地缓存桶中获取令牌，如果本地令牌桶中消耗完后需要到Redis&#x2F;Memcache中再次去获取令牌，直到令牌耗尽，相当于依靠远端Redis&#x2F;Memcache+本地结合的方式来支持大QPS的分布式限流。</p><h3 id="限流的难点："><a href="#限流的难点：" class="headerlink" title="限流的难点："></a>限流的难点：</h3><p>​    每个限流都有个阈值，这个阈值如何定是个难点。如果阈值定大了，服务器可能顶不住，如果阈值定小了，有些请求就被“误杀”了，达不到资源利用最大化，并且对用户体验也不好。</p><p>​    估算阈值的一个简单的方法是 限流上线后，先预估个大概的阈值，然后不执行真正的限流操作，而是采取打点，即记录日志的方式，然后对日志进行分析，查看限流的效果，一步一步调整阈值，推算出每台机器的处理能力和集群总的处理能力；将线上的流量进行重放，测试真正的限流效果，最终确定阈值并上线。</p><h3 id="限流实战："><a href="#限流实战：" class="headerlink" title="限流实战："></a><strong>限流实战：</strong></h3><p>在Atom项目中，使用的是Google的Guava工具包中提供的限流工具类RateLimiter，用该工具类来实现限流功能。RateLimiter是基于“令牌通算法”来实现限流的。</p><p>pom引入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;<span class="number">23.0</span>&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="项目中的使用："><a href="#项目中的使用：" class="headerlink" title="项目中的使用："></a><strong>项目中的使用：</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component(&quot;rateLimitInterceptor&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RateLimitInterceptor</span> <span class="keyword">extends</span> <span class="title class_">AbstractInterceptor</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单机全局限流器(限制QPS为1)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">RateLimiter</span> <span class="variable">rateLimiter</span> <span class="operator">=</span> RateLimiter.create(<span class="number">1</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> ResponseEnum <span class="title function_">preFilter</span><span class="params">(HttpServletRequest request)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!rateLimiter.tryAcquire()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;限流中......&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> ResponseEnum.RATE_LIMIT;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;请求成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ResponseEnum.OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="内部实现原理："><a href="#内部实现原理：" class="headerlink" title="内部实现原理："></a><strong>内部实现原理：</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">// 默认获取一个令牌, 超时时间设置为0</span></span><br><span class="line">    <span class="keyword">return</span> tryAcquire(<span class="number">1</span>, <span class="number">0</span>, MICROSECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> timeout, TimeUnit unit)</span> &#123;</span><br><span class="line">    <span class="comment">// 从tryAcquire()方法进来，这里timeoutMicros=0</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">timeoutMicros</span> <span class="operator">=</span> max(unit.toMicros(timeout), <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查获要获取的令牌个数，permits&gt;0才合法</span></span><br><span class="line">    checkPermits(permits);</span><br><span class="line">    <span class="type">long</span> microsToWait;</span><br><span class="line">    <span class="comment">// RateLimiter实例中的所有操作都使用同一个对象来加锁</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">      <span class="comment">// 获取当前微秒时间戳</span></span><br><span class="line">      <span class="type">long</span> <span class="variable">nowMicros</span> <span class="operator">=</span> stopwatch.readMicros();</span><br><span class="line">      <span class="keyword">if</span> (!canAcquire(nowMicros, timeoutMicros)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// permits在这里为1，nowMicros是当前微秒时间戳，</span></span><br><span class="line">        <span class="comment">// reserveAndGetWaitLength方法用来计算：从现在开始获取一个令牌需要等待的时间</span></span><br><span class="line">        microsToWait = reserveAndGetWaitLength(permits, nowMicros);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用SleepingStopwatch去等待指定实现，当时间到了，就表示获取到锁，返回true</span></span><br><span class="line">    stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断当前时间（微秒时间戳），在等待指定时间后是否晚于“能获取令牌的时间”，如果晚于，返回true，表示能够获取到令牌。</span></span><br><span class="line"><span class="comment">// “能获取令牌的时间”保存在SmoothRateLimiter的nextFreeTicketMicros上，如果时间在nextFreeTicketMicros之前，不能获取令牌，反之，则可以。</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canAcquire</span><span class="params">(<span class="type">long</span> nowMicros, <span class="type">long</span> timeoutMicros)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> queryEarliestAvailable(nowMicros) - timeoutMicros &lt;= nowMicros;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveAndGetWaitLength</span><span class="params">(<span class="type">int</span> permits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">momentAvailable</span> <span class="operator">=</span> reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">    <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">long</span> <span class="title function_">reserveEarliestAvailable</span><span class="params">(<span class="type">int</span> requiredPermits, <span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="comment">// resync方法是guava的SmoothRateLimiter的精髓, 采用“惰性”方式创建令牌</span></span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="comment">// 返回上一个“能够开始创建令牌的时间”</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">returnValue</span> <span class="operator">=</span> nextFreeTicketMicros;</span><br><span class="line">    <span class="comment">// storedPermitsToSpend = 请求令牌数和令牌桶中令牌数较小的那一个</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">storedPermitsToSpend</span> <span class="operator">=</span> min(requiredPermits, <span class="built_in">this</span>.storedPermits);</span><br><span class="line">    <span class="comment">// 当令牌桶中的令牌足够的话，freshPermits = 0，当令牌桶中令牌不够的话，freshPermits = 还缺少的令令牌数</span></span><br><span class="line">    <span class="type">double</span> <span class="variable">freshPermits</span> <span class="operator">=</span> requiredPermits - storedPermitsToSpend;</span><br><span class="line">    <span class="comment">// 生产出不够部分的令牌所需要的时间</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">waitMicros</span> <span class="operator">=</span></span><br><span class="line">        storedPermitsToWaitTime(<span class="built_in">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">            + (<span class="type">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关键: 限流器并没有让当前线程继续阻塞等待在这里$&#123;waitMicros&#125;微秒，</span></span><br><span class="line">  <span class="comment">// 而是将$&#123;waitMicros&#125;的等待时间加到了nextFreeTicketMicros，这样，</span></span><br><span class="line">    <span class="comment">// “下一个开始生产令牌的时间”就往后推迟了，相当于是当前请求超前消费了，然后这笔费用由之后的请求去埋单。</span></span><br><span class="line">    <span class="built_in">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">    <span class="comment">// 从令牌桶中减去实际消费掉的令牌数</span></span><br><span class="line">    <span class="built_in">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">    <span class="keyword">return</span> returnValue;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">resync</span><span class="params">(<span class="type">long</span> nowMicros)</span> &#123;</span><br><span class="line">    <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">    <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">      <span class="comment">// coolDownIntervalMicros()返回的是SmoothRateLimiter中的stableIntervalMicros属性</span></span><br><span class="line">      <span class="comment">// stableIntervalMicros 属性表示的是当前的限流器，每隔多长创建一个令牌需要的微秒数</span></span><br><span class="line">      <span class="comment">// 计算出来的newPermits，表示从下一个能够开始创建令牌的时间到当前时间，一共创建出来的令牌数。</span></span><br><span class="line">      <span class="type">double</span> <span class="variable">newPermits</span> <span class="operator">=</span> (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">      <span class="comment">// 将令牌数加到SmoothRateLimiter#storedPermits上</span></span><br><span class="line">      storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">      <span class="comment">// 将下一个能够开始创建令牌的时间更新为当前时间</span></span><br><span class="line">      nextFreeTicketMicros = nowMicros;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>​    可以发现，RateLimiter虽然也采用令牌桶的方式，但是它没有单独采用一个线程来作为provider，定时去生成令牌。而是采用了一种“惰性加载”的方式，只有当请求令牌的时候，才会去根据当前的时间戳，和令牌开始生产的时间戳，来计算当前令牌桶中应该有多少个令牌：</p><p>​    创建令牌的时间间隔&#x3D;1秒 &#x2F; qps   &#x2F;&#x2F;qps即每秒钟允许被消费的令牌个数 </p><p>​    令牌桶中的令牌数量 &#x3D; Math.min{ 令牌桶的容量, ( 当前时时间戳 - 令牌开始生产的时间戳 ) &#x2F; 创建令牌的时间间隔 }</p><p>计算出当前令牌桶中的令牌数量之后，再让consumer来消费，假如令牌数不够，就让consumer提前消费，再计算出生产这些不够的令牌数需要的时间：</p><p>​    生产不够的令牌数所需要的时间 &#x3D; 创建令牌的时间间隔 * 不够的令牌数</p><p>然后更新令牌开始生产的时间戳，即在 {令牌开始生产的时间戳}之前，令牌桶中是没有令牌的，只有到了{令牌开始生产的时间戳}后，才会生产出第一个令牌：</p><p>​    令牌开始生产的时间戳 &#x3D; 当前的时间戳 + 生产不够的令牌数所需要的时间</p><p>之后如果要再从这个RateLimiter中请求令牌数，就会判断当前时间是否在${令牌开始生产的时间戳}之前，如果是，就请求不到令牌。</p><p>GUAVA 的RateLimiter这种方式就是“惰性加载”思想的一种体现，当需要请求令牌的时候，再去根据时间戳来计算出当前令牌桶中应该要有的令牌数量。避免了在RateLimiter不工作的时候，系统还要分配资源给 RateLimiter去进行运算的情况。</p><h4 id="思想总结："><a href="#思想总结：" class="headerlink" title="思想总结："></a><strong>思想总结：</strong></h4><p>在日常编码中有很多地方可以使用这种思想来编码，比如当一个资源不难获取，但是获取之后很占用空间或者获取之后还会继续消耗系统资源，这种情况下我们就可以使用“惰性加载”。</p><p>参考：</p><p><a href="https://zhuanlan.zhihu.com/p/38100340">https://zhuanlan.zhihu.com/p/38100340</a></p><p><a href="https://juejin.cn/post/6918350807901569037">https://juejin.cn/post/6918350807901569037</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;多种限流方式实现&quot;&gt;&lt;a href=&quot;#多种限流方式实现&quot; class=&quot;headerlink&quot; title=&quot;多种限流方式实现&quot;&gt;&lt;/a&gt;多种限流方式实现&lt;/h2&gt;&lt;p&gt;在高并发系统中，出于对系统的保护，通常会对流量进行限制，即限流。常见的限流有以下五种方式：&lt;</summary>
      
    
    
    
    <category term="高并发" scheme="http://example.com/categories/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    
    <category term="高并发" scheme="http://example.com/tags/%E9%AB%98%E5%B9%B6%E5%8F%91/"/>
    
    <category term="限流" scheme="http://example.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>六大原则</title>
    <link href="http://example.com/2022/06/17/G-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://example.com/2022/06/17/G-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/</id>
    <published>2022-06-17T08:41:19.000Z</published>
    <updated>2022-08-07T14:58:58.850Z</updated>
    
    <content type="html"><![CDATA[<h2 id="六个原则："><a href="#六个原则：" class="headerlink" title="六个原则："></a><strong>六个原则：</strong></h2><h3 id="一、单一职责"><a href="#一、单一职责" class="headerlink" title="一、单一职责"></a>一、单一职责</h3><h4 id="一个对象只有一个单独的职责"><a href="#一个对象只有一个单独的职责" class="headerlink" title="一个对象只有一个单独的职责"></a><strong>一个对象只有一个单独的职责</strong></h4><p>如果一个类承担职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或抑制这个类完成其他职责的能力。当变化发生时，设计会遭受到意想不到的破坏；软件设计真正要做的许多内容就是发现职责，并把那些职责相互分离。</p><p><strong>优点：</strong></p><p>1.类的复杂性降低，实现什么职责都有清晰明确的定义；</p><p>2.可读性提高，复杂性降低；</p><p>3.可维护性提高，可读性提高，更容易维护；</p><p>4.变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口的修改只对相应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助。</p><p>单一职责原则：要求一个接口或类只有一个原因引起变化，就是一个接口或类只有一个职责，它就负责一件事情，设计尽量做到只有一个原因引起变化。</p><p>在项目中可以用“职责”或“变化原因”来衡量接口或类设计得是否优良。项目要考虑可变因素和不可变因素，以及相关的收益成本比率。</p><h3 id="二、开闭原则"><a href="#二、开闭原则" class="headerlink" title="二、开闭原则"></a>二、开闭原则</h3><h4 id="一个对象对扩展开放，对修改关闭"><a href="#一个对象对扩展开放，对修改关闭" class="headerlink" title="一个对象对扩展开放，对修改关闭"></a>一个对象对扩展开放，对修改关闭</h4><p>这个原则可以带来面向对象技术的可维护、可扩展、可复用、灵活性好。</p><p>设计人员在设计模块时，应该对模块的变化做出选择，先猜测出最有可能发生的变化种类，然后构造抽象来隔离这些变化。最初编写程序时假设变化不会发生，当变化发生时，就创建抽象来隔离，以后发生的同类变化，拒绝不成熟的抽象。</p><p>1.开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。</p><p>2.开闭原则可以提高复用性：所有逻辑都是从原子逻辑组合而来的，不是在一个类中独立实现一个业务逻辑。只有这样代码才可以复用，粒度越小，被复用的可能性就越大。</p><p>3.开闭原则可以提高可维护性。</p><p>4.面向对象开发的要求：在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。</p><h4 id="开闭原则的应用："><a href="#开闭原则的应用：" class="headerlink" title="开闭原则的应用："></a>开闭原则的应用：</h4><p>1.抽象约束</p><p>抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。</p><p>通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放：</p><p>*通过接口或抽象类约束扩展，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法；</p><p>*参数类型、引用对象尽量使用接口或者抽象类，而不是实现类；</p><p>*抽象层尽量保持稳定，一旦确定即不允许修改；</p><p>2.元数据（metadata）控制模块行为</p><p>尽量使用元数据来控制程序的行为，减少重复开发。</p><p>元数据：指描述环境和数据的数据，通常就是配置参数，参数可以从文件中获得，也可以从数据库中获得。</p><p>3.制定项目章程</p><p>4.封装变化</p><p>*将相同的变化封装到一个接口或抽象类中；</p><p>*将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中；</p><h3 id="三、依赖倒置原则"><a href="#三、依赖倒置原则" class="headerlink" title="三、依赖倒置原则"></a>三、依赖倒置原则</h3><h4 id="依赖于抽象，不要依赖于具体的实现；核心：“面向接口编程”"><a href="#依赖于抽象，不要依赖于具体的实现；核心：“面向接口编程”" class="headerlink" title="依赖于抽象，不要依赖于具体的实现；核心：“面向接口编程”"></a>依赖于抽象，不要依赖于具体的实现；核心：“面向接口编程”</h4><p>调用其他类时，只调用该类的接口或抽象类，不是调用该类的实现类。针对接口编程、而不是针对实现类编程。</p><p>  1.高层模块不应该依赖低层模块，两个都应该依赖抽象（接口）；</p><p>  2.抽象不应该依赖细节，细节应该依赖抽象。</p><p>  3.针对接口编程，不要针对实现编程。</p><p>该原则是面向对象设计的标志，编写时考虑的是如何对抽象编程，而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或接口。</p><p>解释：</p><p>  1.模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；</p><p>  2.接口或抽象类不依赖于实现类；</p><p>  3.实现类依赖接口或抽象类。</p><h4 id="对象的依赖关系有三种方式来传递："><a href="#对象的依赖关系有三种方式来传递：" class="headerlink" title="对象的依赖关系有三种方式来传递："></a>对象的依赖关系有三种方式来传递：</h4><p><strong>1.构造函数传递依赖对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDriver</span> &#123;</span><br><span class="line">   <span class="comment">//是司机就应该会驾驶汽车</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">IDriver</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ICar car;</span><br><span class="line">  <span class="comment">//构造函数注入</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Driver</span><span class="params">(ICar _car)</span>&#123;</span><br><span class="line">​     <span class="built_in">this</span>.car = _car;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//司机的主要职责就是驾驶汽车</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">​     <span class="built_in">this</span>.car.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.Setter方法传递依赖对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">IDriver</span> &#123;</span><br><span class="line">   <span class="comment">//车辆型号</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCar</span><span class="params">(ICar car)</span>;<span class="comment">//是司机就应该会驾驶汽车</span></span><br><span class="line">​     <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Driver</span> <span class="keyword">implements</span> <span class="title class_">IDriver</span>&#123;</span><br><span class="line">   <span class="keyword">private</span> ICar car;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCar</span><span class="params">(ICar car)</span>&#123;</span><br><span class="line">​     <span class="built_in">this</span>.car = car;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//司机的主要职责就是驾驶汽车</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drive</span><span class="params">()</span>&#123;</span><br><span class="line">​     <span class="built_in">this</span>.car.run();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="3-接口声明依赖对象："><a href="#3-接口声明依赖对象：" class="headerlink" title="3.接口声明依赖对象："></a>3.接口声明依赖对象：</h6><p>在接口的方法中声明依赖对象，也叫做接口注入</p><p>依赖倒置原则的本质就是通过抽象（接口或抽象类）使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合，在项目中应该遵循的规则：</p><p>  1.每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备。</p><p>  2.变量的表面类型尽量是接口或者是抽象类。</p><p>IDriver zhangSan &#x3D; new Driver();</p><p>表面类型是 IDriver，实际类型是 Driver； </p><p>表面类型是：接口&#x2F;抽象类，实际类型是：实现类</p><p>  3.任何类都不应该从具体类派生。</p><p>  4.尽量不要覆写基类的方法：如果基类是一个抽象类，而且这个方法已经实现，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会产生一定的影响。</p><p>  5.结合里氏替换原则使用</p><p>接口负责定义 public属性和方法，并且声明与其他对象的依赖关系；</p><p>抽象类负责公共构造部分的实现；</p><p>实现类负责实现准确的业务逻辑，同时在适当的时候对父类进行细化；</p><h3 id="四、里氏代换原则"><a href="#四、里氏代换原则" class="headerlink" title="四、里氏代换原则"></a>四、里氏代换原则</h3><p><strong>任何抽象类出现的地方都可以用它的实现类替代。</strong></p><p>子类型必须能够替换掉它们的父类型。由于子类型的可替换性才使得父类类型的模块在无需修改的情况下就可以扩展。</p><p>父类范围更小（HashMap），子类范围大（Map），无论何处子类都可以替换父类。</p><p>只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本就不需要知道是父类还是子类。但是，反过来就不行了，有子类出现的地方，父类未必就能适应。</p><p>1.子类必须完全实现父类的方法</p><p>如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。</p><p>2.子类可以有自己的个性</p><p>在子类出现的地方，父类未必就可以胜任。</p><p>会在运行期抛出java.lang.ClassCastException异常，这也是经常说的向下转型（downcast）是不安全的，从里氏替换原则来看，就是有子类出现的地方父类未必就可以出现</p><p>sanMao.setRifle( (AUG)(new Rifle()) );</p><p>传参传入父类，通过子类进行强制类型转换，这种向下转型是不安全的。</p><p>3.覆盖或实现父类的方法时输入参数可以被放大</p><p>里氏替换原则要求制定一个契约，就是父类或接口。这种设计方法也叫做Design by Contract（契约设计），契约的制定也就同时制定了前置条件和后置条件，前置条件是你要让我执行，就必须满足我的条件；后置条件是我执行完了需要反馈，标准是什么。</p><p>重载（Overload）：方法名相同，但方法的输入参数不同。</p><p>子类中方法的前置条件必须与超类中被覆写的方法的前置条件相同或者更宽松</p><p>4.覆写或实现父类的方法时输出结果可以被缩小</p><p>如果是覆写，父类和子类的同名方法的输入参数是相同的，两个方法的范围值S小于等于T，这是覆写的要求，这才是重中之重，子类覆写父类的方法，天经地义。</p><p>如果是重载，则要求方法的输入参数类型或数量不相同，在里氏替换原则要求下，就是子类的输入参数宽于或等于父类的输入参数，也就是说你写的这个方法是不会被调用的。</p><h3 id="五、迪迷特原则（最少知识原则）"><a href="#五、迪迷特原则（最少知识原则）" class="headerlink" title="五、迪迷特原则（最少知识原则）"></a>五、迪迷特原则（最少知识原则）</h3><p><strong>一个对象应当对其他对象尽可能少的了解，从而降低各个对象之间的耦合，提高系统的可维护性。</strong></p><p>如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用；</p><p>如果其中一个类需要调用另一个类的某个方法，可以通过第三者转发这个调用。</p><p>该原则的根本思想：是强调类之间的松耦合；类之间的耦合越弱，越利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。在类的结构设计上，每一个类都应当尽量降低成员的访问权限。</p><p>迪米特法则要求类“羞涩”一点，尽量不要对外公布太多的 public方法和非静态的public变量，尽量内敛，多使用private、package-private、protected等访问权限。</p><p>迪米特法则的核心观念就是类间解耦，弱耦合，只有弱耦合以后，类的复用率才可以提高。要求的结果就是产生大量的中转或跳转类，导致系统的复杂性提高，同时也为维护带来了难度。在采用迪米特法则时需要反复权衡，既做到让结构清晰，又做到高内聚低耦合。</p><p>两个原则：</p><p>1.只和朋友交流</p><p>朋友类的定义：出现在成员变量、方法的输入输出参数中的类称为成员朋友类，而出现在方法体内部的类不属于朋友类。</p><p>一个类只和朋友交流，不与陌生类交流；类与类之间的关系是建立在类间的，而不是方法间，因此一个方法尽量不引入一个类中不存在的对象，当然，JDK API提供的类除外。</p><p>2.朋友间也是有距离的</p><p>一个类公开的public属性或方法越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private、package-private（包类型，在类、方法、变量前不加访问权限，则默认为包类型）、protected等访问权限，是否可以加上final关键字等。</p><p>3.是自己的就是自己的</p><p>如果一个方法放在本类中，既不增加类间关系，也对本类不产生负面影响，那就放置在本类中。</p><h3 id="六、接口分离原则"><a href="#六、接口分离原则" class="headerlink" title="六、接口分离原则"></a>六、接口分离原则</h3><p><strong>不应该强迫客户程序依赖他们不需要使用的方法。</strong></p><p>一个接口应该只提供一种对外功能，不应该把所有的操作都封装到一个接口当中。</p><p>把一个臃肿的接口变更为两个独立的接口所依赖的原则就是接口分离原则，让一个实现类依赖两个专用的接口比依赖一个综合的接口要灵活。接口是我们设计时对外提供的契约，通过分散定义多个接口，可以预防未来变更的扩散，提高系统的灵活性和可维护性。</p><p>接口分离原则是对接口的定义：</p><p>  1.一个接口只服务于一个子模块或业务逻辑；</p><p>  2.通过业务逻辑压缩接口中的public方法，尽量让接口达到“满身筋骨肉”，而不是“肥嘟嘟”的一大堆方法；</p><p>  3.已经被污染的接口，尽量去修改，若变更的风险较大，则采用适配器模式进行转化处理；</p><p>  4.环境不同，接口拆分的标准就不同，需要深入了解业务逻辑，以适度的方式来进行接口的拆分。</p><p>根据经验和常识决定接口的粒度大小，接口粒度太小，导致接口数据剧增，开发人员呛死在接口的海洋里；</p><p>接口粒度太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</p><h4 id="补充原则："><a href="#补充原则：" class="headerlink" title="补充原则："></a>补充原则：</h4><p>合成&#x2F;聚合 复用原则（少用继承）</p><p>**尽量使用 合成&#x2F;聚合，不要使用类的继承。</p><p>聚合：表示一种弱的 “拥有”关系，体现的是A对象可以包含 B对象，但 B对象不是 A对象的一部分；</p><p>合成：一种强的 “拥有”关系，体现了严格的 部分和整体的关系，部分和整体的生命周期一样。</p><p>优先使用对象的 合成&#x2F;聚合 将有助于保持每个类被封装，并被击中在单个任务上，这样类和类继承层次会保持较小规模，并且不太可能增长为不可控制的庞然大物。</p><p>参考：</p><p><a href="https://mp.weixin.qq.com/s/E2MzyB9-LaRFJwS_IqN4eA">https://mp.weixin.qq.com/s/E2MzyB9-LaRFJwS_IqN4eA</a></p><p>《设计模式之禅》书籍</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;六个原则：&quot;&gt;&lt;a href=&quot;#六个原则：&quot; class=&quot;headerlink&quot; title=&quot;六个原则：&quot;&gt;&lt;/a&gt;&lt;strong&gt;六个原则：&lt;/strong&gt;&lt;/h2&gt;&lt;h3 id=&quot;一、单一职责&quot;&gt;&lt;a href=&quot;#一、单一职责&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="设计模式" scheme="http://example.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
    <category term="设计模式" scheme="http://example.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>git命令</title>
    <link href="http://example.com/2022/06/15/F-Linux%E7%B3%BB%E7%BB%9F/git%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/06/15/F-Linux%E7%B3%BB%E7%BB%9F/git%E5%91%BD%E4%BB%A4/</id>
    <published>2022-06-15T14:31:19.000Z</published>
    <updated>2022-06-15T14:42:16.127Z</updated>
    
    <content type="html"><![CDATA[<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h39avg5vmxj20rw0bmq3r.jpg" alt="470C2702-5AAA-401A-98F4-41C407B441AC" style="zoom:80%;" /><p><strong>1.创建仓库：</strong> git init </p><p><strong>2.克隆一个仓库：</strong></p><p>  检出本地仓库： git clone  &#x2F;path&#x2F;to&#x2F;repository</p><p>  远端服务器：   git clone username@host: &#x2F;path&#x2F;to&#x2F;repository</p><p>3.每次修改代码前一定要 <strong>git pull</strong> 一遍，保证此时本地工作区代码是最新版本，与远端仓库保存同步。</p><p>4.每写一个新需求最好创建一个新分支，不要一直在一个分支上修改；</p><p>master默认为主分支，在其他的分支上开发，完成后将它提交到主分支。</p><p><strong>创建分支：</strong>git branch branch_name;    表示在本地创建了分支branch_name</p><p><strong>切换分支：</strong> git checkout branch_name;  表示切换至分支branch_name</p><p>创建feature_x 分支并切换过去： git checkout -b feature_x</p><p>拉取远程分支branch_name并创建为同名的本地分支 branch_name：git fetch origin branch_name(remote): branch_name(local)</p><p><strong>5.查看修改：</strong> git  status </p><p>提交修改： 分三步：</p><p>添加： git add <filename> ;  </p><p>git add .  将工作区间修改的文件提交至暂存区；</p><p>实际提交改动：git commit -m “代码提交信息” ；此处是提交到 head 上（本地）；</p><p>git commit -m “commit_message” 将暂存区域生成快照并提交。</p><p>在工作目录中， 获取、合并远端改动，合并其他分支到当前分支：git merge <branch></p><p><strong>合并分支：</strong> git merge branch_name.   ex: git merge member-E   表示当前分支与分支member-E进行合并</p><p>合并改动前，可以使用如下命令看差异： git diff <source_branch>  <target_branch></p><p><strong>6.提交改动到远端仓库：</strong>  push的代码一定要是对的，不然容易被人打</p><p>git push origin master;    强制推到 master 上： git push origin HEAD:refs&#x2F;for&#x2F;master</p><h5 id="7-每次需求写完代码提交完毕后，最好删除本地和远程的分支"><a href="#7-每次需求写完代码提交完毕后，最好删除本地和远程的分支" class="headerlink" title="7.每次需求写完代码提交完毕后，最好删除本地和远程的分支"></a>7.每次需求写完代码提交完毕后，最好删除本地和远程的分支</h5><p>删除本地分支： git branch -d branch_name</p><p>删除远程分支： git push origin -delete branch_name</p><p>删掉新建分支： git branch -d feature_x</p><h5 id="8-项目版本回退"><a href="#8-项目版本回退" class="headerlink" title="8.项目版本回退"></a>8.项目版本回退</h5><p>命令行：git reset –hard head^；   回退至上一版本</p><p>命令行：git reset –hard head^^；  回退至前两个版本，当回退的版本较多时可以写为： git reset –hard head-10； 10表示前十个版本</p><p>命令行：git reset –hard revision_number 表示直接回退至当前版本号对应的版本，版本号怎么获取自行百度</p><p>git reflog  查看所有 git 操作记录</p><p>git reset –hard HEAD@{17}：  恢复到某一个版本</p><h5 id="9-文件版本回退（撤销修改）"><a href="#9-文件版本回退（撤销修改）" class="headerlink" title="9.文件版本回退（撤销修改）"></a>9.文件版本回退（撤销修改）</h5><p>git checkout – modefied_file  此时文件写的是路径，想确定修改文件的具体路径可以使用git status查看</p><p><strong>10.修改远程仓库地址：</strong>git remote set-url origin new_url</p><h5 id="11-创建标签："><a href="#11-创建标签：" class="headerlink" title="11.创建标签："></a>11.创建标签：</h5><p>git  tag. 1.0.0.  1b2e1d63ff (id 前10位);  </p><p>git  log 获取提交到id</p><p><strong>12.替换本地改动：</strong>  git checlename&gt; St</p><p>*在项目根目录下执行以下git命令： git config –global credential.helper store</p><p>*执行上述命令后，在 idea中第一次pull或push需要输入用户名和密码，之后就不用再输入了。</p><h4 id="如何将本地一个项目推的github中："><a href="#如何将本地一个项目推的github中：" class="headerlink" title="如何将本地一个项目推的github中："></a>如何将本地一个项目推的github中：</h4><ul><li>首先在github中创建一个仓库，并copy仓库的链接，比如 <a href="mailto:git@github.com">git@github.com</a>:TurboCome&#x2F;lstm_improve.git</li><li>然后再本地项目中，初始化git 仓库：git init</li><li>将项目中需要添加到远端仓库的文件进行添加：git add whq.txt  （git add . 全部添加）</li><li>将暂存区域生成快照并提交: git commit -m “first commit”</li><li>添加远程仓库连接，并为其命名为”origin”(也可自定义名字)：git remote add origin <a href="mailto:git@github.com">git@github.com</a>:TurboCome&#x2F;lstm_improve.git</li><li>将本地项目推送到远端仓库中：git push -u origin master</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h39avg5vmxj20rw0bmq3r.jpg&quot; alt=&quot;470C2702-5AAA-401A-98F4-41C407B441AC&quot; style=&quot;zoom:80%;&quot; /</summary>
      
    
    
    
    <category term="Linux系统" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Linux系统" scheme="http://example.com/tags/Linux%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>研究生科研总结</title>
    <link href="http://example.com/2022/06/15/Z-%E9%9A%8F%E7%AC%94/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%A7%91%E7%A0%94%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/15/Z-%E9%9A%8F%E7%AC%94/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%A7%91%E7%A0%94%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-15T08:28:19.000Z</published>
    <updated>2022-06-16T12:14:44.137Z</updated>
    
    <content type="html"><![CDATA[<h2 id="研究生科研工作总结"><a href="#研究生科研工作总结" class="headerlink" title="研究生科研工作总结"></a>研究生科研工作总结</h2><h3 id="一、-整体经验分享："><a href="#一、-整体经验分享：" class="headerlink" title="一、 整体经验分享："></a>一、 整体经验分享：</h3><p>1.首先要多看论文，多找一些相关性较强的论文，感觉可以有改进，就把文章进行详细的解析，包括公式，模型可以考虑在本子上写下来，一点一点推导研究，在模型中寻找改进的点。</p><p>2.找相关文章时，最好挑选一些高质量的论文，英文的，IEEE、ACM等会议论文，做改进。</p><p>3.在挑选对比算法时，一定要找相关性强的算法，要是你所做方面的。比如：资源分配，要找大背景是卫星网络的，在卫星网络下所做的资源分配。另外，挑选对比算法时尽量找新的算法，最好是近3年的。</p><p>4.大论文：围绕自己的创新点来写，特别是相关研究部分。在介绍相关算法时，明确阐述前人没做好的方面，自己改进的地方，在其他人的基础上的创新，优势有哪些。</p><p>5.提早发小论文，尽量发一些高质量的，这样对自己以后答辩时是有优势的，后边有更多的时间来准备找工作，考公等。</p><p>6.要勤于思考，看论文的时候，不必局限于卫星通信领域，可以考虑针对自己的领域，在整个业内有哪些处理方式。</p><p>比如：我做的基于任务拆分资源分配，传统都是在卫星下研究如何对任务进行拆分的，在找创新点时，可以单独把任务拆分拿出来，调研一下任务拆分都在哪些领域有使用，去找相关论文，再结合卫星网络的背景特点，看看是否有改进的地方，以此寻找创新。</p><h3 id="二、每个时间节点的完成内容："><a href="#二、每个时间节点的完成内容：" class="headerlink" title="二、每个时间节点的完成内容："></a>二、每个时间节点的完成内容：</h3><p>1.研二上学期，尽量多阅读相关论文，调研自己的研究方向，最新的研究进展。</p><p>2.研二下学期，在自己的研究方向上寻找一个创新点，发一篇专利。</p><p>3.研三上学期，根据已发的专利，撰写小论文，争取发一篇高水平的学术论文。如有额外精力，可以根据新的创新点，发第二篇专利。</p><p>4.研三下学期，撰写大论文。</p><h3 id="三、答辩经验："><a href="#三、答辩经验：" class="headerlink" title="三、答辩经验："></a>三、答辩经验：</h3><p>1.对自己所做的研究内容，一定要特别熟悉。包括：背景，解决的问题，相关研究，对比算法等。答辩老师主要是围绕你的工作进行展开，提问的。</p><p>2.不要顶撞老师，如果老师说你哪方面没做好，积极回应，说后续进行改进。</p><p>3.对于盲审意见，包括修改建议、质询问题，都要在答辩PPT上体现，并做详细的解答。这些内容答辩老师会额外关注。</p><p>4.答辩时需要携带各种资料，事前一定要把各种资料填写完整，不要遗漏。</p><p>5.答辩PPT有时间限制，老师们都很反感过长的PPT，事前可以模拟一下，尽量控制在15分钟以内，避免超时。</p><h3 id="四、个人总结："><a href="#四、个人总结：" class="headerlink" title="四、个人总结："></a>四、个人总结：</h3><p>​    时光荏苒，转瞬即逝，转眼之间，三年的硕士生活即将结束。朦胧间，我还清晰的记得，第一天踏进校园，在细雨蒙蒙的苏州独墅湖旁的那一幕。一晃已是三年， 有些时候曾后悔自己的选择，但迫于现实的压力也让我不得不做出选择。曾和老师们聊过这些话题，然而他们却把问题看的很淡，他们给我的答复是要把更多的心思放在个人的能力上，而不是出身、曾经。既然你已经选择了，就要勇于去面对，为你的选择负责，更要为你以后的人生负责。你曾经拥有的一切，或许仅能给你提供一个平台，这个平台无论高低也仅此而已，至于以后的一切，能走多高、多远，完全取决于以后的你。我深刻的记得孔老师对我说的那句话：“一个优秀的人，无论做什么都会很优秀！”。这句话让我想了很多，也让我明白了很多。以后的路还很长，很远，很多时候我都在怀疑自己选择的路是对是错，但后来，慢慢的我明白了一个道理，你若是一个优秀的人，无论走哪条路都不会太差！正逢毕业之际，身边的同学各奔东西，有的去了外企，有的去了银行，有的去了公务员。回首间有些羡慕，也有些对自己未来的担忧。这可能是从学校到社会的过度期，那种恐慌吧，但这又能怎么样呢？每个人都要经历的，我也不会例外。生活的齿轮永不停息的向前滚动着，每个人都在时时刻刻的现场直播，如果你不想埋没在茫茫人海中，那请你以一种高傲的态度来看待以后的点点滴滴！</p><p>​    路漫漫其修远兮，吾将上下而求索！未来道路漫长，勿忘初心，做好自己，加油小强！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;研究生科研工作总结&quot;&gt;&lt;a href=&quot;#研究生科研工作总结&quot; class=&quot;headerlink&quot; title=&quot;研究生科研工作总结&quot;&gt;&lt;/a&gt;研究生科研工作总结&lt;/h2&gt;&lt;h3 id=&quot;一、-整体经验分享：&quot;&gt;&lt;a href=&quot;#一、-整体经验分享：&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>DFS版0-1背包问题</title>
    <link href="http://example.com/2022/05/10/Y-LeetCode/M-DFS/4.0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/10/Y-LeetCode/M-DFS/4.0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-10T13:55:19.000Z</published>
    <updated>2022-04-20T11:22:48.670Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/207796">https://ac.nowcoder.com/acm/problem/207796</a><br>有 n个物品，每个物品有一个体积  v[i] ，重量  g[i], 选择其中总体积恰好为 V的若干个物品，最大总重量为多少？<br>（如果不存在合法方案，返回-1）</p><p>输入： v &#x3D; [1,2,3]； g &#x3D; [2,3,4]； V &#x3D; 3<br>输出： 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Maximumweight</span> <span class="params">(<span class="type">int</span>[] v, <span class="type">int</span>[] g, <span class="type">int</span> V)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> DFS(V, v, g, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> V, <span class="type">int</span>[] v, <span class="type">int</span>[] g, <span class="type">int</span> id, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(V==<span class="number">0</span>) <span class="keyword">return</span> item;</span><br><span class="line">    <span class="keyword">if</span>(V&lt;<span class="number">0</span> || id==v.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> DFS(V,   v, g, id+<span class="number">1</span>, item);     <span class="comment">// id 物品不要</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> DFS(V-v[id],   v, g, id+<span class="number">1</span>, item+g[id]); <span class="comment">// id 物品要</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/207796&quot;&gt;https://ac.nowcoder.com/acm/problem/207796&lt;/a&gt;&lt;br&gt;有 n个物品，每个物品有一个体积  v[i] ，重量  g[i</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>全排列_46/47</title>
    <link href="http://example.com/2022/05/09/Y-LeetCode/M-DFS/1.%E5%85%A8%E6%8E%92%E5%88%97_4647/"/>
    <id>http://example.com/2022/05/09/Y-LeetCode/M-DFS/1.%E5%85%A8%E6%8E%92%E5%88%97_4647/</id>
    <published>2022-05-09T13:55:19.000Z</published>
    <updated>2022-04-20T11:11:02.066Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 **<em>*没有重复 数字*<em>的序列，返回其所有可能的全排列。</em></em></p><p>输入: [1,2,3]<br>输出:</p><p>[[1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1] ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    int l=nums.length;</span><br><span class="line">    if(l==0) return new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;lists=new ArrayList&lt;&gt;();</span><br><span class="line">    for(int v:nums) lists.add(v);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; item=new ArrayList&lt;&gt;();</span><br><span class="line">    DFS(lists, item);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>47</p><p>给定一个 <strong><em>*可包含重复数字的序列 nums*</em> ，按任意顺序 返回所有不重复的全排列。</strong></p><p>输入：nums &#x3D; [1,1,2]<br>输出：<br>[[1,1,2],<br>[1,2,1],<br>[2,1,1]]</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private Set&lt;List&lt;Integer&gt;&gt; res=new HashSet&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0) return new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt;lists = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int v:nums) lists.add(v);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;item = new ArrayList&lt;&gt;();</span><br><span class="line">    DFS2(lists, item);</span><br><span class="line">    return new ArrayList&lt;&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void DFS2(List&lt;Integer&gt; lists, List&lt;Integer&gt; item) &#123;</span><br><span class="line">    if(lists.size()==0)&#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(item));</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int id=0;id&lt;lists.size();id++)&#123;</span><br><span class="line">        int v=lists.get(id);</span><br><span class="line">        lists.remove(id);</span><br><span class="line">        item.add(v);</span><br><span class="line"></span><br><span class="line">        DFS2(lists, item);</span><br><span class="line"></span><br><span class="line">        lists.add(id,v);</span><br><span class="line">        item.remove(item.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个 **&lt;em&gt;*没有重复 数字*&lt;em&gt;的序列，返回其所有可能的全排列。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;输入: [1,2,3]&lt;br&gt;输出:&lt;/p&gt;
&lt;p&gt;[[1,2,3],&lt;br&gt; [1,3,2],&lt;br&gt; [2,1,3],&lt;br&gt; [2,3,1],&lt;br&gt; </summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="http://example.com/2022/05/09/Y-LeetCode/M-DFS/2.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://example.com/2022/05/09/Y-LeetCode/M-DFS/2.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2022-05-09T13:55:19.000Z</published>
    <updated>2022-04-20T11:13:24.331Z</updated>
    
    <content type="html"><![CDATA[<p>输入：<br>[[1,1,0,0,0],<br>[0,1,0,1,1],<br>[0,0,0,1,1],<br>[0,0,0,0,0],<br>[0,0,1,1,1] ]</p><p>返回值：3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length, col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=grid.length || j&lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].length || grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i-<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入：&lt;br&gt;[[1,1,0,0,0],&lt;br&gt;[0,1,0,1,1],&lt;br&gt;[0,0,0,1,1],&lt;br&gt;[0,0,0,0,0],&lt;br&gt;[0,0,1,1,1] ]&lt;/p&gt;
&lt;p&gt;返回值：3&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>整数二进制拆解-Pow50</title>
    <link href="http://example.com/2022/05/09/Y-LeetCode/M-DFS/3.%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E8%A7%A3-Pow50/"/>
    <id>http://example.com/2022/05/09/Y-LeetCode/M-DFS/3.%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E8%A7%A3-Pow50/</id>
    <published>2022-05-09T13:55:19.000Z</published>
    <updated>2022-04-20T11:15:27.769Z</updated>
    
    <content type="html"><![CDATA[<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><p>输入: 2.00000, 10<br>输出: 1024.00000</p><p>输入: 2.10000, 3<br>输出: 9.26100</p><p>输入: 2.00000, -2<br>输出: 0.25000</p><p>解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25<br>说明:<br>-100.0 &lt;  x  &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] </p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>把指数 n n 做「二进制分解」，在底数不断自身乘以自身的过程中，将最终结果需要的部分保存下来</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gegtwt4tj20hq05tt91.jpg" alt="FA5A6E3C-3205-45CD-B1F3-01A343C29506"  /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span>? fun2(x,N) : <span class="number">1.</span>/fun2(x,-N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> fun(x*x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x*fun(x*x, n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1.</span>/x;</span><br><span class="line">            m = -m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">1</span>) res *= x;  <span class="comment">//碰到1，res扩展</span></span><br><span class="line">            m = m/<span class="number">2</span>;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现 pow(x, n) ，即计算 x 的 n 次幂函数。&lt;/p&gt;
&lt;p&gt;输入: 2.00000, 10&lt;br&gt;输出: 1024.00000&lt;/p&gt;
&lt;p&gt;输入: 2.10000, 3&lt;br&gt;输出: 9.26100&lt;/p&gt;
&lt;p&gt;输入: 2.00000, -2&lt;br&gt;输出:</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>字符串相加</title>
    <link href="http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</id>
    <published>2022-05-08T13:55:19.000Z</published>
    <updated>2022-04-20T11:02:06.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串形式实现数字相加"><a href="#字符串形式实现数字相加" class="headerlink" title="字符串形式实现数字相加"></a>字符串形式实现数字相加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;  <span class="comment">//进位</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] chs=s.toCharArray(), cht=t.toCharArray();</span><br><span class="line">    <span class="type">int</span> l1=s.length(), l2=t.length();</span><br><span class="line">    <span class="type">int</span> i=l1-<span class="number">1</span>, j=l2-<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + chs[i]-<span class="string">&#x27;0&#x27;</span> + cht[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + chs[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + cht[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) res.append(carry); <span class="comment">//记录最后进位值</span></span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;字符串形式实现数字相加&quot;&gt;&lt;a href=&quot;#字符串形式实现数字相加&quot; class=&quot;headerlink&quot; title=&quot;字符串形式实现数字相加&quot;&gt;&lt;/a&gt;字符串形式实现数字相加&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-05-08T13:55:19.000Z</published>
    <updated>2022-04-20T11:03:11.954Z</updated>
    
    <content type="html"><![CDATA[<p>寻找一个字符串中的 <strong>最长递增子序列</strong></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.对 <strong>字符串按字母排序</strong><br>2.排序后的字符串，和 原字符串的 *<strong>*最长公共子*</strong>*序列****，即为所求的 <strong>字符串中最长递增子序列</strong></p><p>In:  bacdgat;  aabcdgt<br>Out:  acdgt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums_i = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> l=nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp= <span class="keyword">new</span> <span class="title class_">int</span>[l+<span class="number">1</span>][l+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums_i[i-<span class="number">1</span>]==nums[j-<span class="number">1</span>] ) dp[i][j] =dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l][l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寻找一个字符串中的 &lt;strong&gt;最长递增子序列&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h4&gt;&lt;p&gt;1.对 &lt;strong&gt;字符串按字母排序&lt;/st</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子串-公共子序列</title>
    <link href="http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-05-08T13:55:19.000Z</published>
    <updated>2022-04-20T11:07:58.338Z</updated>
    
    <content type="html"><![CDATA[<p>最长公共子串：字串要保证连续</p><p>s1[i] ，s2[j] 表示以 s1 以下标 i 结尾， s2 以下标 j 结尾<br>dp(i)(j) 表示分别以s1[i], s2[j] 结尾的 公共子串的长度<br>dp(0)(j)&#x3D;0, dp(i)(0) &#x3D;0;</p><p>1.s1[i-1]!&#x3D;s2[j-1]    dp(i)(j)&#x3D; 0     当前位置不等，子串要连续，则此位置&#x3D;&#x3D;0<br>2.s1[i-1]&#x3D;&#x3D;s2[j-1]   dp(i)(j)&#x3D;dp(i-1)(j-1)+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 2 个字符串中的最长公共子串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonSubstring</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1=s1.length(),l2=s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> max_v=<span class="number">0</span>, start_id=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l2;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(max_v&lt;dp[i][j])&#123;</span><br><span class="line">                    max_v=dp[i][j];</span><br><span class="line">                    start_id=i-max_v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.substring(start_id,start_id+max_v);</span><br></pre></td></tr></table></figure><h4 id="求最长公共子序列：可以不是连续的"><a href="#求最长公共子序列：可以不是连续的" class="headerlink" title="求最长公共子序列：可以不是连续的"></a><strong>求最长公共子序列：可以不是连续的</strong></h4><p>1.s1[i-1]!&#x3D;s2[j-1]  dp(i)(j) &#x3D; Math.max(dp(i-1)(j) , dp(i)(j-1) ) 当前位置不等，依次 -1 看 <strong>其他子序列是否相等，取最大</strong> </p><p>2.s1[i-1]&#x3D;&#x3D;s2[j-1]  dp(i)(j)&#x3D;dp(i-1)(j-1)+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 2 个字符串中的最长公共子序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonLxlie</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1=s1.length(), l2=s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_v=<span class="number">0</span>, start_id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l2;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>)) dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]= Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最长公共子串：字串要保证连续&lt;/p&gt;
&lt;p&gt;s1[i] ，s2[j] 表示以 s1 以下标 i 结尾， s2 以下标 j 结尾&lt;br&gt;dp(i)(j) 表示分别以s1[i], s2[j] 结尾的 公共子串的长度&lt;br&gt;dp(0)(j)&amp;#x3D;0, dp(i)(0) &amp;#</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>重复子串_459</title>
    <link href="http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2_459/"/>
    <id>http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2_459/</id>
    <published>2022-05-07T13:55:19.000Z</published>
    <updated>2022-04-20T10:56:03.165Z</updated>
    
    <content type="html"><![CDATA[<p>非空的字符串，判断它是否可以由它的一个 <strong>子串重复多次构成,</strong>  字符串只含小写英文字母，并且长度不超过10000</p><p>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>输入: “aba”<br>输出: False</p><p>输入: “abc abc abc abc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成，(或者子字符串 “abcabc” 重复两次构成。)</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>for (1 ~ len(s)&#x2F;2)  所有 子字符串（从index&#x3D;0开始取）<br>所取 <strong>子字符串 * 切片数  len(s) &#x2F;&#x2F; i ,</strong> 得到的字符串若和 原字符串相等，则返回 True<br>判断 2个str的值相等:   str1.equals(str2)<br>地址相等： str1&#x3D;&#x3D;str2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(String s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.length()/<span class="number">2</span> ; i&gt;<span class="number">0</span>; i—)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> s.length()/i;    <span class="comment">//切片的数量</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp_s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="comment">// 拼接形成 new 字符串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; k; j++) tmp_s.append( s.substring(<span class="number">0</span>,i));</span><br><span class="line">            <span class="keyword">if</span>( String.valueOf(tmp_s).equals(s) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;非空的字符串，判断它是否可以由它的一个 &lt;strong&gt;子串重复多次构成,&lt;/strong&gt;  字符串只含小写英文字母，并且长度不超过10000&lt;/p&gt;
&lt;p&gt;输入: “abab”&lt;br&gt;输出: True&lt;br&gt;解释: 可由子字符串 “ab” 重复两次构成。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最大回文子串-回文子序列</title>
    <link href="http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-05-07T13:55:19.000Z</published>
    <updated>2022-04-20T11:00:29.117Z</updated>
    
    <content type="html"><![CDATA[<p><strong>回文子串： boolean(len)(len) dp  ;   回文序列：  int(len)(len) dp</strong></p><p>回文：</p><p>for(int i&#x3D;len-1; i&gt;&#x3D;0; i–){</p><p>  for(int j&#x3D;i; j&lt;len; j++){</p><p>字符串中最长的回文子串：</p><p>Input: “babad”<br>Output: “bab”&#x2F; “aba” </p><p>Input: “cbbd”<br>Output: “bb”</p><h4 id="思路：（动态规划）"><a href="#思路：（动态规划）" class="headerlink" title="思路：（动态规划）"></a>思路：（动态规划）</h4><p>核心思想就是两个字“延伸”</p><p>在一个 <strong>不是回文字符串的字符串两端添加任何字符，或者在回文串左右分别加不同的字符，得到的一定不是回文串</strong></p><p>dp(i)(j):  表示 <strong>从 i 到 j 是否可以形成回文</strong><br>dp(i)(j)&#x3D; ( s.charAt(i)&#x3D;&#x3D;s.charAt(j) ) &amp;&amp; (j-i&lt;3 || dp(i+1)(j-1) );</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l][l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;l; j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)) dp[i][j] = (j-i&lt;<span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) ;</span><br><span class="line">            <span class="keyword">if</span>( dp[i][j] &amp;&amp; res.length()&lt;j-i+<span class="number">1</span> ) res=s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串 s ，找到其中<strong>最长的回文子序列，并返回该序列的长度。</strong></p><p>输入:  “bbbab”<br>输出:  4  ；一个可能的最长回文子序列为 “bbbb”</p><p>输入:  “cbbd”<br>输出:  2  ；一个可能的 最长回文子序列为 “bb”</p><h4 id="思路：DP"><a href="#思路：DP" class="headerlink" title="思路：DP"></a>思路：DP</h4><p>dp(i)(j): i 左 j 右， <strong>从 s[i] – s[j] 此字符串内， 最长的回文子序列</strong></p><p>if s[i] &#x3D;&#x3D; s[j] :  dp(i)(j) &#x3D; dp(i+1)(j-1) + 2;<br>else dp(i)(j) &#x3D; max( dp(i+1)(j), dp(i)(j-1) )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[ len ][ len ];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;len; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从下往上遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="comment">// 那么就说明在原先的基础上又增加了回文子序列的长度</span></span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表明这时 dp[i][j]只需取两者之间的 最大值即可</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;回文子串： boolean(len)(len) dp  ;   回文序列：  int(len)(len) dp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回文：&lt;/p&gt;
&lt;p&gt;for(int i&amp;#x3D;len-1; i&amp;gt;&amp;#x3D;0; i–){&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>不重复的子串_3</title>
    <link href="http://example.com/2022/05/06/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E4%B8%B2_3/"/>
    <id>http://example.com/2022/05/06/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E4%B8%B2_3/</id>
    <published>2022-05-06T13:55:19.000Z</published>
    <updated>2022-04-20T10:52:56.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h4><p>Input:  “abc abcbb”<br>Output:  3</p><p>思路：（双指针）<br>fast 前， slow 后, 保证此区间内不重复，用Map（） 走过的记录字符<br>保存临时子串 ： tmp_l，依次判断 s[fast] 是否在 tmp_l 中 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=s.length();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( l&lt;r &amp;&amp; map.containsKey(s.charAt(r)))</span><br><span class="line">            <span class="comment">// aabaab!bb , 在 slow=4, a 时,map.get(b)+1 = 3, 会出现更小的数值，此处可以保证 slow 一直向前走</span></span><br><span class="line">            l= Math.max( l, map.get(s.charAt(r))+<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        map.put(s.charAt(r), r);</span><br><span class="line">        res= Math.max(res, r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最长不重复子串&quot;&gt;&lt;a href=&quot;#最长不重复子串&quot; class=&quot;headerlink&quot; title=&quot;最长不重复子串&quot;&gt;&lt;/a&gt;最长不重复子串&lt;/h4&gt;&lt;p&gt;Input:  “abc abcbb”&lt;br&gt;Output:  3&lt;/p&gt;
&lt;p&gt;思路：（双指针）&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>3个数的和_15</title>
    <link href="http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/2.%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/2.%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-05T13:55:19.000Z</published>
    <updated>2022-04-20T10:51:38.296Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。<br>具体请参考样例解释<br><strong>示例1</strong><br>Input: <strong>[3,1,2,5,2,4]</strong><br>Output:  5</p><p>思路：</p><p>左右夹击， 左侧记录一个最大值，右侧记录一个最大值；<br>遇到比其lmax, rmax 小的数，+ 差值;<br>遇到比其lmax, rmax 大的数， 替换更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxWater</span> <span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">     <span class="type">int</span> l=<span class="number">0</span>, r=len-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> lmax=arr[l], rmax=arr[r];</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">         lmax = Math.max(lmax, arr[l]);</span><br><span class="line">         rmax = Math.max(rmax, arr[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lmax &lt; rmax)&#123;</span><br><span class="line">           res +=(lmax - arr[l]);</span><br><span class="line">             l++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           res +=(rmax - arr[r]);</span><br><span class="line">             r--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。&lt;br&gt;具体请参考样例解释&lt;br&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;br&gt;Input: &lt;strong&gt;[3,1,2,5,2,4]&lt;/strong&gt;&lt;br&gt;Output</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="指针" scheme="http://example.com/categories/LeetCode/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>3个数的和_15</title>
    <link href="http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/1.3%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C_15/"/>
    <id>http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/1.3%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C_15/</id>
    <published>2022-05-05T13:55:19.000Z</published>
    <updated>2022-04-20T10:42:09.074Z</updated>
    
    <content type="html"><![CDATA[<p><strong>双指针</strong></p><p>一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？<br>找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p><p>nums &#x3D; [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[[-1, 0, 1],<br> [-1, -1, 2]]</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>外循环<strong>先固定一个数</strong>，在此数之后，用双指针左（i+1）右（l-1），向中间聚，依次扫描<br>枚举数组中的两个元素时，如果发现随着<strong>第一个元素的递增，第二个元素是递减的</strong>，那么就可以使用双指针的方法，<br>将枚举的时间复杂度从 O(N^2) 减少至 O(N)这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但它一共会移动的位置数为 O(N)，每次也向左移动一个位置，因此时间复杂度为 O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt; List&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;len-<span class="number">2</span>; id++)&#123;</span><br><span class="line">        <span class="comment">// 固定好 id，一个数</span></span><br><span class="line">        <span class="keyword">if</span>(nums[id]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">0</span> &amp;&amp; nums[id]==nums[id-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l=id+<span class="number">1</span>, r=len-<span class="number">1</span>;  <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">while</span>( l&lt;r )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[id]+ nums[l]+  nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( Arrays.asList(nums[id],nums[l],nums[r])) );</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==nums[++l]);  <span class="comment">// 无论是否相等，保证 l+1 前进</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==nums[--r]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==nums[++l]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==nums[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;双指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &amp;#x3D; 0 ？&lt;br&gt;找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。&lt;/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="指针" scheme="http://example.com/categories/LeetCode/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二为矩阵顺时针打印</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/3.%E4%BA%8C%E4%B8%BA%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/3.%E4%BA%8C%E4%B8%BA%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:23:42.212Z</updated>
    
    <content type="html"><![CDATA[<p>四步：</p><p>1.从左到右<br>2.从上到下<br>3.从右到左<br>4.从下到上</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>row_s 行 开始， row 行 结束<br>col_s 列 开始，  col 列 结束<br>While(T)  单独判断跳出条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder( <span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0, len-1;   保持后续 &lt;= , &gt;= 的统一形式</span></span><br><span class="line">    <span class="type">int</span> row_s=<span class="number">0</span>, col_s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length-<span class="number">1</span>, col=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[( row+<span class="number">1</span>)*(col+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 列开始，列结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col_s; i&lt;=col; i++) res[id++] = matrix[ row_s][i];</span><br><span class="line">        row_s++; <span class="comment">// 行开始➕1</span></span><br><span class="line">        <span class="keyword">if</span>(row_s&gt; row) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 行开始，行结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row_s; i&lt;=row; i++) res[id++] = matrix[i][col];</span><br><span class="line">        col—-;  <span class="comment">// 列-1</span></span><br><span class="line">        <span class="keyword">if</span>(col&lt; col_s) <span class="keyword">break</span>; </span><br><span class="line">        <span class="comment">// 下+左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col; i&gt;=col_s; i--) res[id++] = matrix[row][i];</span><br><span class="line">        row--;</span><br><span class="line">        <span class="keyword">if</span>(row&lt; row_s) <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row;i&gt;=row_s; i--) res[id++] = matrix[i][col_s];</span><br><span class="line">        col_s++;</span><br><span class="line">        <span class="keyword">if</span>(col_s&gt; col) <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;四步：&lt;/p&gt;
&lt;p&gt;1.从左到右&lt;br&gt;2.从上到下&lt;br&gt;3.从右到左&lt;br&gt;4.从下到上&lt;/p&gt;
&lt;h4 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h4&gt;&lt;p&gt;row_s 行 开始，</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="数论" scheme="http://example.com/categories/LeetCode/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>最多的盛水容器_11</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/1.%E6%9C%80%E5%A4%9A%E7%9A%84%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8_11/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/1.%E6%9C%80%E5%A4%9A%E7%9A%84%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8_11/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:32:58.714Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。<br>在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。<br>找出其中的两条线，使得它们与 <strong>x 轴共同构成的容器可以容纳最多的水</strong></p><p>说明：你不能倾斜容器，且 n 的值至少为 2<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (r-l)*Math.min(height[l],height[r]);</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">       <span class="keyword">if</span>(height[l]&gt;height[r]) r—-;</span><br><span class="line">       <span class="keyword">else</span> l++；</span><br><span class="line">       res= Math.max(res, (r-l)*Math.min(height[l],height[r]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。&lt;br&gt;在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。&lt;br&gt;找出其中的两条线，使得它们与 &lt;strong&gt;x 轴共同构成的容器可以容纳最多的</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏_45/55</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/2.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_4555/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/2.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_4555/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:35:48.461Z</updated>
    
    <content type="html"><![CDATA[<h4 id="55"><a href="#55" class="headerlink" title="55."></a>55.</h4><p>给定一个非负整数 数组，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度。<br>判断 <strong>是否能够到达最后一个位置。</strong></p><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max_l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;nums.length; id++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_l&gt;=id &amp;&amp; id+nums[id] &gt; max_l ) </span><br><span class="line">            max_l = id+nums[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_l&gt;=nums.length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="45-最少次数跳到最后位置，使用-最少的跳跃次数到达数组的最后一个位置"><a href="#45-最少次数跳到最后位置，使用-最少的跳跃次数到达数组的最后一个位置" class="headerlink" title="45.最少次数跳到最后位置，使用 最少的跳跃次数到达数组的最后一个位置"></a>45.最少次数跳到最后位置，使用 <strong>最少的跳跃次数到达数组的最后一个位置</strong></h4><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdbxjzpdj20jo0dh75g.jpg" alt="6600092D-2F93-4F3E-91BC-C810187EEC89" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> step=<span class="number">0</span>, end=<span class="number">0</span>, max_l=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//不用考虑从最后一个位置起跳的情况，所以i &lt; nums.size()-1，而不是i &lt; nums.size()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;nums.length-<span class="number">1</span>; id++)&#123;</span><br><span class="line"></span><br><span class="line">        max_l = Math.max(max_l, id+nums[id]);</span><br><span class="line">        <span class="keyword">if</span>(id==end)&#123;</span><br><span class="line">            end=max_l;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;55&quot;&gt;&lt;a href=&quot;#55&quot; class=&quot;headerlink&quot; title=&quot;55.&quot;&gt;&lt;/a&gt;55.&lt;/h4&gt;&lt;p&gt;给定一个非负整数 数组，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度。&lt;br&gt;判断 &lt;strong&gt;是否能够</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>引爆气球最少箭数_452</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/4.%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%E6%9C%80%E5%B0%91%E7%AE%AD%E6%95%B0_452/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/4.%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%E6%9C%80%E5%B0%91%E7%AE%AD%E6%95%B0_452/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:39:17.040Z</updated>
    
    <content type="html"><![CDATA[<p>在二维空间中有许多球形的气球, 对于每个气球，提供的输入是水平方向上，气球直径的 <strong>开始和结束坐标</strong>。<br>开始坐标总是小于结束坐标，平面内最多存在104个气球。<br>若一个气球直径开始和结束坐标为 xstart，xend，<strong>且满足 xstart ≤ x ≤ xend，则该气球会被引爆。</strong>所需的弓箭的最小数量？   </p><p>输入:[[10,16],  [2,8],  [1,6],  [7,12]]<br>排序后：[1,6] [2,8] [7,12] [10,16]<br>输出:  2<br><strong>解释:</strong>  对于该样例，我们可以在x &#x3D; 6（射爆[2,8],[1,6]两个气球）和 x &#x3D; 11（射爆另外两个气球）。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>类似于集合求相交区间</p><p>排序，小–&gt;大<br>right &lt; array[left], 计数加 1<br>right &#x3D; min(right, array[right])  依次向后更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(points, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rv=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">1</span>;id&lt;points.length;id++)&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = points[id];</span><br><span class="line">        <span class="keyword">if</span>(rv &lt; tmp[<span class="number">0</span>])&#123;</span><br><span class="line">            res++;</span><br><span class="line">            rv = tmp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        rv = Math.min(rv, tmp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在二维空间中有许多球形的气球, 对于每个气球，提供的输入是水平方向上，气球直径的 &lt;strong&gt;开始和结束坐标&lt;/strong&gt;。&lt;br&gt;开始坐标总是小于结束坐标，平面内最多存在104个气球。&lt;br&gt;若一个气球直径开始和结束坐标为 xstart，xend，&lt;strong&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
</feed>
