<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TurboCome</title>
  
  <subtitle>Wang Hongqiang</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-20T03:13:26.194Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TurboCome</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>至少有 K个重复字符的最长子串_395</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/C-%E9%80%92%E5%BD%92/1.%E8%87%B3%E5%B0%91%E6%9C%89%20K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2_395/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/C-%E9%80%92%E5%BD%92/1.%E8%87%B3%E5%B0%91%E6%9C%89%20K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2_395/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T03:13:26.194Z</updated>
    
    <content type="html"><![CDATA[<p>找到给定字符串（小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k , 输出 T 的长度。</p><p>示例 1:<br>输入: s &#x3D; “aaa bb”, k &#x3D; 3<br>输出: 3   最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。</p><p>示例 2:<br>输入: s &#x3D; “ababb c”, k &#x3D; 2<br>输出: 5   最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>递归+分治</p><p>1.统计各个字符数量； 对于数量 &lt; k 的字符， <strong>设置为分割点</strong></p><p>2.遍历分割点，<strong>切分字符串，进入到递归中</strong></p><p>3.在递归中，依次<strong>保存最大值，最终进行返回</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span> || s.length() &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ch = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s.toCharArray()) ch[c-<span class="string">&#x27;a&#x27;</span>]++; <span class="comment">//记录每个字母个数</span></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; split_id = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//记录切分点位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( ch[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]&gt;<span class="number">0</span> &amp;&amp; ch[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]&lt;k )&#123;</span><br><span class="line">            split_id.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( split_id.size()==<span class="number">0</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">    split_id.add( s.length() );  <span class="comment">//记录最后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;split_id.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> longestSubstring( s.substring(l, split.get(i)), k);</span><br><span class="line">        res = Math.max(res, tmp);</span><br><span class="line">        l = split.get(i)+<span class="number">1</span>; <span class="comment">//要求下标起始位置为下一个 id+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;找到给定字符串（小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k , 输出 T 的长度。&lt;/p&gt;
&lt;p&gt;示例 1:&lt;br&gt;输入: s &amp;#x3D; “aaa bb”, k &amp;#x3D; 3&lt;br&gt;输出: 3   最长子串为 “aaa” ，其中 </summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="递归" scheme="http://example.com/categories/LeetCode/%E9%80%92%E5%BD%92/"/>
    
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>数组小和</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T01:57:52.664Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序类型题（美团实习二面原题）</p><p>数组小和 定义如下：给定一个数组 s，实现 函数返回 s 的小和</p><p>例如： 数组s&#x3D;[1,3,5,2,4,6]</p><p>s[0] 左边 &lt; &#x3D; s[0]的数的和为0，</p><p>s[1]左边 &lt;&#x3D; s[1] 的数的和为1，</p><p>s[2]左边 &lt;&#x3D; s[2]的数的和为1+3&#x3D;4，</p><p>s[3]左边 &lt;&#x3D; s[3]的数的和为1，</p><p>s[4]左边 &lt;&#x3D; s[4]的数的和为1+3+2&#x3D;6，</p><p>s[5]左边 &lt;&#x3D; s[5]的数的和为1+3+5+2+4&#x3D;15，</p><p>所以s 小和为 0+1+4+1+6+15&#x3D;27 </p><p>In:  arr&#x3D;[1, 3, 5, 2, 4, 6]</p><p>Out:  27</p><p>要求：时间复杂度O( NlogN)，额外空间复杂度O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallSum2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="literal">null</span> || arr.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>); <span class="comment">//归并排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//归并排序的过程会进行拆组再合并，即：拆左组，拆右组，合并左右组</span></span><br><span class="line">    <span class="keyword">return</span> func(s,l,mid) +func(s, mid+<span class="number">1</span>,r) + merge(s, l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hi=<span class="number">0</span>; <span class="comment">// h 的首位</span></span><br><span class="line">    <span class="type">int</span> i= left; <span class="comment">// 左组首位</span></span><br><span class="line">    <span class="type">int</span> j= mid+<span class="number">1</span>; <span class="comment">// 右组首位</span></span><br><span class="line">    <span class="type">int</span> sum= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( i&lt;=mid &amp;&amp; j&lt;=right)&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( s[i]&lt;=s[j])&#123;</span><br><span class="line">            sum += s[i]*(right-j+<span class="number">1</span>);<span class="comment">//生成小和</span></span><br><span class="line">            h[hi++] =s[i++]; <span class="comment">//左组动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> h[hi++]=s[j++]; <span class="comment">//右组动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; (j&lt;right+<span class="number">1</span>)||(i&lt;mid+<span class="number">1</span>); j++,i++)&#123;</span><br><span class="line">        h[hi++]= i&gt;mid? s[j]:s[i]; <span class="comment">//左右组合成h</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k!=h.length; k++) s[left++]=h[k];  <span class="comment">// 合成s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;归并排序类型题（美团实习二面原题）&lt;/p&gt;
&lt;p&gt;数组小和 定义如下：给定一个数组 s，实现 函数返回 s 的小和&lt;/p&gt;
&lt;p&gt;例如： 数组s&amp;#x3D;[1,3,5,2,4,6]&lt;/p&gt;
&lt;p&gt;s[0] 左边 &amp;lt; &amp;#x3D; s[0]的数的和为0，&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>二叉树路径总和-112-113-437</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/C-%E9%80%92%E5%BD%92/2.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C_112_113_437/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/C-%E9%80%92%E5%BD%92/2.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C_112_113_437/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:36:36.822Z</updated>
    
    <content type="html"><![CDATA[<ol start="112"><li></li></ol><p>给定一个二叉树和一个 <strong>目标和</strong>，判断该树中 <strong>是否存在 根节点到叶子节点的路径</strong>，这条路径上所有节点值 <strong>相加等于目标和</strong><br>说明: 叶子节点是指没有 子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><p>​         5</p><p>​        &#x2F;  \</p><p>​       4    8</p><p>​      &#x2F;    &#x2F;  \</p><p>​     11   13  4</p><p>​     &#x2F; \   \</p><p>​    7  2    1</p><p>{5,4,8,11,null, 13, 4, 7, 2, null, 1}</p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径  5-&gt;4-&gt;11-&gt;2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span> &amp;&amp; sum-root.val==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="113"><li></li></ol><p>给定一个二叉树和一个目标和，找到所有从 根节点到 <strong>叶子节点路径总和 &#x3D;&#x3D;给定目标和的路径</strong><br>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><p>​            5<br>​         &#x2F;     <br>​        4       8<br>​       &#x2F;  \     &#x2F;  \<br>​      11   N    13   4<br>​     &#x2F; \  &#x2F; \   &#x2F;\   &#x2F;<br>​    7   2 N N  N  N 5  1</p><p>{5,4,8, 11, null, 13, 4, 7,2, null, null,null, null, 5,1}</p><p>返回:</p><p>[</p><p>  [5,4,11,2],</p><p>  [5,8,4,5]</p><p>]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    pathSum(root, sum, item);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    item.add(root.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span> &amp;&amp; sum-root.val==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>(item) );  <span class="comment">// 一定要重新赋值，注意深浅copy</span></span><br><span class="line">      <span class="comment">//此处不要 return; 会导致item中末尾节点没有删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处 不能放在 else 中，否则在 添加满足条件后，无法将最后一个元素删除： 回溯</span></span><br><span class="line">    pathSum(root.left, sum-root.val, item);</span><br><span class="line">    pathSum(root.right, sum-root.val, item);</span><br><span class="line">   item.remove(item.size()-<span class="number">1</span>);  <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>437.链接：<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a><br>二叉树的每个结点都存放着一个整数值, 找出 路径和 等于 给定数值的路径总数<br>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1] , sum &#x3D; 8</p><pre><code>         10       /    \     5      -3   /  \     / \  3    2   N   11 / \      / \3  -2    N   1</code></pre><p>{10,5,-3,3,2,null,11,3,-2,null,1} </p><p>返回 3<br>和等于 8 的路径有:</p><ol><li>5 -&gt; 3</li><li>5 -&gt; 2 -&gt; 1</li><li>-3 -&gt; 11</li></ol><p>思路：<br>1.以当前节点为起始，dfs深搜遍历左右几点，找到所有sum&#x3D;target<br>2.递归遍历root.left ; root.right</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root, sum); <span class="comment">//加入 root 节点</span></span><br><span class="line">    <span class="comment">// 不加入root 节点</span></span><br><span class="line">    pathSum(root.left, sum);</span><br><span class="line">    pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(sum-root.val==<span class="number">0</span>) res++;</span><br><span class="line">    dfs(root.left, sum-root.val);</span><br><span class="line">    dfs(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;112&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一个二叉树和一个 &lt;strong&gt;目标和&lt;/strong&gt;，判断该树中 &lt;strong&gt;是否存在 根节点到叶子节点的路径&lt;/strong&gt;，这条路径上所有节点值 &lt;strong&gt;相加等于目标和&lt;/stro</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="递归" scheme="http://example.com/categories/LeetCode/%E9%80%92%E5%BD%92/"/>
    
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式(*.)匹配_10</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D_10/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D_10/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T03:13:43.056Z</updated>
    
    <content type="html"><![CDATA[<p>一个字符串 s和一个字符规律 p，实现一个支持 ‘.’ 和  ‘*’ 的正则表达式匹配。</p><p>.匹配任意 单个字符;<br>*匹配 零个或多个前面的那一个元素;  所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。<br>说明:  s 可能为空，且只包含从 a-z 的小写字母； p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *<br>s &#x3D; “aa”； p &#x3D; “a”<br>输出: false； 解释: “a” 无法匹配 “aa” 整个字符串。</p><p>s &#x3D; “aa”；  p &#x3D; “a*”   *<br>输出: true； 解释: 因为 ‘’可以匹配零个或多个前面的那一个元素, 这里前面元素是’a’。字符串”aa”可被视为’a’ 重复一次。</p><p>s &#x3D; “ab”；    p &#x3D; “.*”<br>输出: true；   解释: “.” 表示可匹配零个或多个（’’）任意字符（’.’）。</p><p>s &#x3D; “aab”；    p &#x3D; “c<em>a</em>b”<br>输出: true；  解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p><p>s &#x3D; “mississippi”；    p &#x3D; “mis<em>is</em>p*.”<br>输出: false</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>状态dp(i,j) 表示：  <strong>s 的前 i 个 是否 能被 p 的前 j个匹配</strong></p><p>已知 dp(i-1)(j-1) 意思就是前面子串都匹配上了，不知道新的一位的情况</p><p>1.p[j-1]  !&#x3D; ‘<em>‘:<br>    p[j-1] &#x3D;&#x3D; s[i-1] ||  p[j-1] &#x3D;&#x3D; “.” :</em>*    dp(i)(j) &#x3D; dp(i-1)(j-1)</p><p>2.p[j-1]  &#x3D;&#x3D; ‘<em>‘:   * 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]<br>    1.前一个都不能匹配上 s[i]， * 也无能为力，只能让前一个字符消失<br>        dp(i)(j) &#x3D; dp(i)(j-2);<br>    2.p[j-2] &#x3D;&#x3D; s[i-1] or p[j-2] &#x3D;&#x3D; “.”：  *** 前面那个字符，能匹配 s[i]，或者 * 前面那个字符是万能的</em>*<br>        dp(i)(j) &#x3D; (dp(i - 1)(j) || dp(i)(j); </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">     <span class="type">int</span> l1=s.length()， l2=p.length();</span><br><span class="line">     <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">     <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">     <span class="type">char</span>[] pp = p.toCharArray();</span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 所有 pp[j-1]==‘*’ , 都可以--将前一个字母消除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=l2;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(pp[j-<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l2; j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(pp[j-<span class="number">1</span>]!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(pp[j-<span class="number">1</span>]==ss[i-<span class="number">1</span>] || pp[j-<span class="number">1</span>]==‘.<span class="string">&#x27; )</span></span><br><span class="line"><span class="string">                     dp[i][j] = dp[i-1][j-1];</span></span><br><span class="line"><span class="string">             &#125;else&#123;</span></span><br><span class="line"><span class="string">                 if(j&gt;1) dp[i][j] = dp[i][j-2];</span></span><br><span class="line"><span class="string">                 if(pp[j-2]==&#x27;</span>.<span class="string">&#x27; || pp[j-2]==ss[i-1])</span></span><br><span class="line"><span class="string">                     dp[i][j] = ( dp[i][j] || dp[i-1][j] ); // 前一个字符匹配的话就匹配，不匹配再看是否可以消失</span></span><br><span class="line"><span class="string">             &#125;</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     return dp[l1][l2];</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个字符串 s和一个字符规律 p，实现一个支持 ‘.’ 和  ‘*’ 的正则表达式匹配。&lt;/p&gt;
&lt;p&gt;.匹配任意 单个字符;&lt;br&gt;*匹配 零个或多个前面的那一个元素;  所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。&lt;br&gt;说明:  s 可能为空，且只包含从 a</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>01背包--目标和_494</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.0-1%E8%83%8C%E5%8C%85-%E7%9B%AE%E6%A0%87%E5%92%8C_494/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.0-1%E8%83%8C%E5%8C%85-%E7%9B%AE%E6%A0%87%E5%92%8C_494/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T03:13:47.989Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非负整数数组 { a1, a2, …, an } 和一个目标数 S,  现有两个符号 + 和 - , 对于数组中的任意一个整数，可以从 + 或 - 中选择一个符号添加在前面。返回可以使最终数组和 为目标数 S 的所有 添加符号的方法数</p><p>输入：nums: [1, 1, 1, 1, 1],    S: 3  ； 不一定都是 1<br>输出：5<br>解释：<br>    -1+1+1+1+1 &#x3D; 3<br>    +1-1+1+1+1 &#x3D; 3<br>    +1+1-1+1+1 &#x3D; 3<br>    +1+1+1-1+1 &#x3D; 3<br>    +1+1+1+1-1 &#x3D; 3<br>一共有5种方法让最终目标和为 3</p><p>思路：<br>换种理解方式：就是从数组中挑出一部分数，作为正数，其余数为负，使其加和为S的所有方案<br>关键是这个选出哪些数作为正数呢？<br>设选出 正数的所有数求和 x ， 选出负数的所有数求和 y （不计符号）<br>x + y &#x3D; sum (  数组中所有元素和 )<br>x - y &#x3D; S<br>x &#x3D; (sum + S ) &#x2F; 2<br>之后此题便转化为一个 0-1背包问题； 即：装满背包容量X 的条件下，有多少种方案</p><p>设 dp(i)(j)表示在 数组中元素个数为 i 的条件下，背包容量为 j  的所有方案<br>第 i 个元素 有 2中可能 &#x3D; 不选 + 选<br>dp(i)(j)&#x3D;dp(i-1)(j)+dp(i-1)(j-nums[i])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: nums) sum +=v;</span><br><span class="line">    <span class="keyword">if</span>( (sum+S)%<span class="number">2</span>!=<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> (sum+S)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>][ W+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&lt; nums[i-<span class="number">1</span>]) dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个非负整数数组 { a1, a2, …, an } 和一个目标数 S,  现有两个符号 + 和 - , 对于数组中的任意一个整数，可以从 + 或 - 中选择一个符号添加在前面。返回可以使最终数组和 为目标数 S 的所有 添加符号的方法数&lt;/p&gt;
&lt;p&gt;输入：nums:</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>不含重复元素的最长子串_3</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T03:13:01.378Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中 <strong>不含有重复字符的 最长子串 的长度</strong></p><p>输入: “abcabcbb”</p><p>输出: 3</p><p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p><p>输入: “bbbbb”</p><p>输出: 1</p><p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p><p>输入: “pwwkew”</p><p>输出: 3</p><p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p><p>   请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p><p>滑动窗口：</p><p><strong>保证连续，有包含关系时，从下一个 id, 开始截取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">复杂度： n </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> l= -<span class="number">1</span>;  <span class="comment">// l边界 -1， 防止特殊情况全不相同</span></span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123; </span><br><span class="line">        <span class="keyword">if</span>( map.containsKey(ch[r]))&#123; </span><br><span class="line">            <span class="comment">// 确保 左指针一直在向前移动， 不会遍历之前的元素</span></span><br><span class="line">            l = Math.max( l, map.get(ch[r])); </span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, r-l);</span><br><span class="line">        map.put(ch[r], r);  <span class="comment">// 值，下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复杂度： n^<span class="number">2</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] ch=s.toCharArray();</span><br><span class="line">    <span class="type">int</span> l=-<span class="number">1</span>, res=<span class="number">0</span>;   <span class="comment">// 左下标 -1 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123;  <span class="comment">// 右指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; list.contains(ch[r]))&#123; <span class="comment">//左指针</span></span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, r-l);</span><br><span class="line">        list.add(ch[r]);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个字符串，请你找出其中 &lt;strong&gt;不含有重复字符的 最长子串 的长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输入: “abcabcbb”&lt;/p&gt;
&lt;p&gt;输出: 3&lt;/p&gt;
&lt;p&gt;解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。&lt;/p&gt;
&lt;p&gt;输入: </summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="滑动窗口" scheme="http://example.com/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 57 - II.和为s的连续正数序列</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:19:31.787Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个 正整数 target ，输出 <strong>所有和为 target</strong> 的 连续 **<em>*正整数序列*<em>（至少含有两个数）</em></em></p><p>序列内的 数字由小到大排列，不同序列按照首个数字从小到大排列</p><p>输入：target &#x3D; 9</p><p>输出：[[2,3,4],[4,5]]</p><p>输入：target &#x3D; 15</p><p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>思路：</p><p>当窗口的和 &lt; target 时:  右边界向右移动 ，增加</p><p>当窗口的和 &gt; target 时:  左边界向右移动 ，减少</p><p>当窗口的和 &#x3D;&#x3D; target 时， 记录结果</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fypl95qcj213e0qcjuc.jpg" alt="76F3FB9B-80E0-4AA1-AEB9-0E0C15368462" width="650" height="400" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findContinuousSequence</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    List&lt; List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= target/<span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">            sum+=r;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            sum-=l;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k=l; k&lt;r; k++) tmp.add(k);</span><br><span class="line">           res.add(tmp);</span><br><span class="line">            <span class="comment">// 左边界继续右移，仍要继续前进</span></span><br><span class="line">            sum-=l; </span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个 正整数 target ，输出 &lt;strong&gt;所有和为 target&lt;/strong&gt; 的 连续 **&lt;em&gt;*正整数序列*&lt;em&gt;（至少含有两个数）&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;序列内的 数字由小到大排列，不同序列按照首个数字从小到大排列&lt;/p&gt;
&lt;p&gt;输</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="滑动窗口" scheme="http://example.com/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>最小覆盖子串_76</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_76/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_76/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:25:56.856Z</updated>
    
    <content type="html"><![CDATA[<p>一个字符串 s , 一个字符串  t ， 返回 s 中 涵盖 t 所有字符的最小子串?</p><p>如果 s 中  不存在涵盖 t 所有字符的子串，则返回空字符串 “” </p><p>注意：如果 s 中存在这样的子串，保证它是唯一的答案。</p><p>输入：s &#x3D; “ADOBECODEBANC”,  t &#x3D; “ABC”</p><p>输出：”BANC”</p><p>输入：s &#x3D; “a”,  t &#x3D; “a”</p><p>输出：”a”</p><p>提示：</p><p>1 &lt;&#x3D; s.length,  t.length &lt;&#x3D; 105</p><p>s 和 t 由英文字母组成  </p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>左右指针，依次截取判断是否包含。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( s.length() &lt; t.length() ) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map_test = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: t.toCharArray()) map_test.put( c, map_test.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, len=Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt; s.length(); r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">         <span class="comment">// 包括的话，就添加进来</span></span><br><span class="line">        <span class="keyword">if</span>( map_test.containsKey(c)) map.put(c, map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l&lt;=r &amp;&amp; check(map_test, map) )&#123;</span><br><span class="line">            <span class="keyword">if</span>(len&gt; r-l+<span class="number">1</span>)&#123;</span><br><span class="line">                res= s.substring(l, r+<span class="number">1</span>);</span><br><span class="line">                len = r-l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 内部缩减， 左指针前移</span></span><br><span class="line">            <span class="keyword">if</span>(map_test.containsKey(s.charAt(l)))</span><br><span class="line">                map.put(s.charAt(l), map.getOrDefault( s.charAt(l),<span class="number">0</span>)-<span class="number">1</span> );</span><br><span class="line">            l++;  <span class="comment">// 可以考虑使用 map&lt;v, id&gt; 优化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Map&lt;Character, Integer&gt; map_test, Map&lt;Character, Integer&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( Map.Entry&lt;Character,Integer&gt; it: map_test.entrySet())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> it.getKey();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> it.getValue();</span><br><span class="line">        <span class="keyword">if</span>(map.getOrDefault(key, <span class="number">0</span>)&lt; value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个字符串 s , 一个字符串  t ， 返回 s 中 涵盖 t 所有字符的最小子串?&lt;/p&gt;
&lt;p&gt;如果 s 中  不存在涵盖 t 所有字符的子串，则返回空字符串 “” &lt;/p&gt;
&lt;p&gt;注意：如果 s 中存在这样的子串，保证它是唯一的答案。&lt;/p&gt;
&lt;p&gt;输入：s &amp;#x</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="滑动窗口" scheme="http://example.com/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>检验字符串是否包含__567</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/2.%E6%A3%80%E9%AA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/2.%E6%A3%80%E9%AA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T03:13:09.423Z</updated>
    
    <content type="html"><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列,  <strong>排列可以是任何顺序</strong></p><p>换句话说：第一个字符串的 <strong>排列之一</strong> 是 <strong>第二个字符串的子串，任意排列是s2 连续的*<em>子串*</em></strong></p><p>输入: s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”</p><p>输出: True</p><p>解释: s2 包含 s1 的排列之一 ( “ba” )</p><p>输入: s1&#x3D; “ab” s2 &#x3D; “eidboaoo”</p><p>输出: False</p><p>注意：</p><p>输入的字符串只包含小写字母  </p><p>两个字符串的长度都在 [1, 10,000] 之间</p><p>优化版本：  </p><p>使用外加 res[26],  前–；后++</p><p>依次维护 res ，来和 array 比对</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要每一次去比较， 依靠中间变量，删前加后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ll= s1.length();</span><br><span class="line">    <span class="keyword">if</span>(ll&gt; s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span>[] ss1= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] res= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ll; i++)&#123;</span><br><span class="line">        ss1[s1.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       res[s2.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 res 依次划窗来维护</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s2.length()-ll; i++)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>( Arrays.equals(res, ss1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        res[ s2.charAt(i)-‘a<span class="string">&#x27; ]--;</span></span><br><span class="line"><span class="string">        res[ s2.charAt(i+ll )-&#x27;</span>a<span class="string">&#x27;]++;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    return Arrays.equals(res,ss1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p>思路：</p><p><strong>无序排列的字符串，就是序列字符串，使用 Map | str[ c-‘a’] 来记录</strong></p><p><strong>最终判断是否为&#x3D;&#x3D;0，或 2个Map是否相等</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] ss=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s1.toCharArray()) ss[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="type">int</span> sum_l=s1.length();</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ss2=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;s2.length()-sum_l+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match( Arrays.copyOf(ss,ss.length), s2.substring(i,i+sum_l))) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span>[] ss, String substring)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:substring.toCharArray())&#123;</span><br><span class="line">        ss[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(ss[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列,  &lt;strong&gt;排列可以是任何顺序&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;换句话说：第一个字符串的 &lt;strong&gt;排列之一&lt;/strong&gt; 是 &lt;strong&gt;第二个字符串的子串，任意排列是s</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="滑动窗口" scheme="http://example.com/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>防止怠慢，经常自勉</title>
    <link href="http://example.com/2022/04/19/Z-%E9%9A%8F%E7%AC%94/%E8%87%AA%E5%8B%89/"/>
    <id>http://example.com/2022/04/19/Z-%E9%9A%8F%E7%AC%94/%E8%87%AA%E5%8B%89/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-19T13:31:01.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防止怠慢，经常自勉"><a href="#防止怠慢，经常自勉" class="headerlink" title="防止怠慢，经常自勉"></a>防止怠慢，经常自勉</h1><ol><li><h4 id="不受些挫，永远不知道自己有多差劲！"><a href="#不受些挫，永远不知道自己有多差劲！" class="headerlink" title="不受些挫，永远不知道自己有多差劲！"></a>不受些挫，永远不知道自己有多差劲！</h4></li><li><h4 id="你已不再年轻，请别把自己当作一个孩子了！"><a href="#你已不再年轻，请别把自己当作一个孩子了！" class="headerlink" title="你已不再年轻，请别把自己当作一个孩子了！"></a>你已不再年轻，请别把自己当作一个孩子了！</h4></li><li><h4 id="做什么事情，请用心去做，不是什么事都那么随便就可以成功的！"><a href="#做什么事情，请用心去做，不是什么事都那么随便就可以成功的！" class="headerlink" title="做什么事情，请用心去做，不是什么事都那么随便就可以成功的！"></a>做什么事情，请用心去做，不是什么事都那么随便就可以成功的！</h4></li><li><h4 id="以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！"><a href="#以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！" class="headerlink" title="以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！"></a>以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！</h4></li><li><h4 id="这一路走来容易么？你经历了什么？你得到了什么？你想要什么？"><a href="#这一路走来容易么？你经历了什么？你得到了什么？你想要什么？" class="headerlink" title="这一路走来容易么？你经历了什么？你得到了什么？你想要什么？"></a>这一路走来容易么？你经历了什么？你得到了什么？你想要什么？</h4></li><li><h4 id="不要那么鲁莽，生活终究会为你的粗心而付出代价！"><a href="#不要那么鲁莽，生活终究会为你的粗心而付出代价！" class="headerlink" title="不要那么鲁莽，生活终究会为你的粗心而付出代价！"></a>不要那么鲁莽，生活终究会为你的粗心而付出代价！</h4></li><li><h4 id="有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！"><a href="#有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！" class="headerlink" title="有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！"></a>有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！</h4></li><li><h4 id="平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？"><a href="#平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？" class="headerlink" title="平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？"></a>平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？</h4></li><li><h4 id="要有自己的梦想，你的潜力不止于此！"><a href="#要有自己的梦想，你的潜力不止于此！" class="headerlink" title="要有自己的梦想，你的潜力不止于此！"></a>要有自己的梦想，你的潜力不止于此！</h4></li><li><h4 id="抱怨没有任何意义，那是曾经！我要的是未来！"><a href="#抱怨没有任何意义，那是曾经！我要的是未来！" class="headerlink" title="抱怨没有任何意义，那是曾经！我要的是未来！"></a>抱怨没有任何意义，那是曾经！我要的是未来！</h4></li><li><h4 id="经常总结经验，失败并不可怕，但一定要有所成长！"><a href="#经常总结经验，失败并不可怕，但一定要有所成长！" class="headerlink" title="经常总结经验，失败并不可怕，但一定要有所成长！"></a>经常总结经验，失败并不可怕，但一定要有所成长！</h4></li><li><h4 id="今天的怠慢在以后一定会让你加倍偿还！"><a href="#今天的怠慢在以后一定会让你加倍偿还！" class="headerlink" title="今天的怠慢在以后一定会让你加倍偿还！"></a>今天的怠慢在以后一定会让你加倍偿还！</h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防止怠慢，经常自勉&quot;&gt;&lt;a href=&quot;#防止怠慢，经常自勉&quot; class=&quot;headerlink&quot; title=&quot;防止怠慢，经常自勉&quot;&gt;&lt;/a&gt;防止怠慢，经常自勉&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;不受些挫，永远不知道自己有多差劲！&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>排序算法汇总</title>
    <link href="http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/"/>
    <id>http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-20T03:12:40.293Z</updated>
    
    <content type="html"><![CDATA[<h4 id="排序算法总结："><a href="#排序算法总结：" class="headerlink" title="排序算法总结："></a>排序算法总结：</h4><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fd578lsfj20ll0bp3zc.jpg" alt="82BAF801-27D7-496B-BDE1-0BC3461F6172" width="650" height="400" /><h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a><strong>归并排序：</strong></h3><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fczk2g0fj20u00u6wgu.jpg" alt="99D30D77-7213-4598-8705-403B62FC60F0" width="550" height="500" /><p><strong>思路： 使用额外空间 res[]</strong> </p><p>1.首先把一个未排序的序列从中间分割成2部分<br>2.再把2部分分成4部分，依次分割下去，直到分割成一个一个的数据<br>3.再把这些数据两两归并到一起，使之有序，不停的归并，最后成为一个排好序的序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序:   r=len-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">    merge2(nums, l, m);</span><br><span class="line">    merge2(nums, m+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=l, j=m+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r-l+<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        tmp[k++] = nums[i]&lt;nums[j]? nums[i++]:nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m) tmp[k++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>;id&lt;=r-l;id++) nums[id+l] = tmp[id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.外 for： 0—len<br>2.内 for:  0–i;<br>外层遍历一遍没有交换元素时： 表示排完，终止 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubble(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[j] ^= nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] ^= nums[j];</span><br><span class="line">                nums[j] ^= nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>从 i –&gt;nums.length 的数组列表中，每次选择最小的元素，放到第 i 个位置上</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get_min</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l)</span>&#123;</span><br><span class="line">    <span class="type">int</span> min_v=nums[l], min_id=l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l+<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min_v &gt; nums[i])&#123;</span><br><span class="line">            min_v=nums[i];</span><br><span class="line">            min_id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] select_sort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min_id=get_min(nums, i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[min_id];</span><br><span class="line">        nums[min_id] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>前面的排好序，每次取当前的值，<strong>从后向前遍历，直到出现 &gt; 情况时， 进行填入</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;len; id++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[id]; <span class="comment">//记录当前元素值</span></span><br><span class="line">        <span class="type">int</span> i=id; </span><br><span class="line">        <span class="comment">// 遍历当前元素之前到所有元素，每一个元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span>( ; i&gt;<span class="number">0</span> &amp;&amp; arr[i-<span class="number">1</span>]&gt;tmp; i--)&#123;</span><br><span class="line">            arr[i] = arr[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;排序算法总结：&quot;&gt;&lt;a href=&quot;#排序算法总结：&quot; class=&quot;headerlink&quot; title=&quot;排序算法总结：&quot;&gt;&lt;/a&gt;排序算法总结：&lt;/h4&gt;&lt;img src=&quot;https://tva1.sinaimg.cn/large/e6c9d24ely1h1</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-20T01:56:34.456Z</updated>
    
    <content type="html"><![CDATA[<p>思路： </p><p>取第一个元素，右–&gt;左：直到碰到&lt; 赋值给左； 再 左–&gt;右：直到碰到&gt; 赋值给右；</p><p>一次遍历完划分左右 2部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;   <span class="comment">// 终止条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不对数组进行截取时，要定义 起止下标</span></span><br><span class="line">    <span class="type">int</span> high=r, low=l;       </span><br><span class="line">    <span class="type">int</span> base=nums[l];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; base&lt;=nums[r]) r--;</span><br><span class="line">        nums[l]=nums[r];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; base&gt;nums[l]) l++;</span><br><span class="line">        nums[r]=nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l]=base;</span><br><span class="line">    <span class="comment">// 分支递归</span></span><br><span class="line">    quick_sort(nums,low,l-<span class="number">1</span>);</span><br><span class="line">    quick_sort(nums,l+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;思路： &lt;/p&gt;
&lt;p&gt;取第一个元素，右–&amp;gt;左：直到碰到&amp;lt; 赋值给左； 再 左–&amp;gt;右：直到碰到&amp;gt; 赋值给右；&lt;/p&gt;
&lt;p&gt;一次遍历完划分左右 2部分&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序算法</title>
    <link href="http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-19T13:50:44.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序算法："><a href="#堆排序算法：" class="headerlink" title="堆排序算法："></a>堆排序算法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[] ,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 i 作为节点时， 进行的左 右子树的调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l= <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r= <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l&lt;len &amp;&amp; arr[base]&lt;arr[l]) base=l;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;len &amp;&amp; arr[base]&lt;arr[r]) base=r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(base!= i)&#123;</span><br><span class="line">        swap(arr, i, base);</span><br><span class="line">        heapify(arr, base, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heap_sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="type">int</span> len=arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (len-<span class="number">1</span>)/<span class="number">2</span>;   <span class="comment">//最后一个节点的父节点</span></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(arr,<span class="number">0</span>, i);</span><br><span class="line">        heapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型题：</p><p>查找第K大的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find_K_nums</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="type">int</span> parent=(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(nums, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;len-K; i--)&#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, i);</span><br><span class="line">        heapify(nums, <span class="number">0</span>, i);</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;堆排序算法：&quot;&gt;&lt;a href=&quot;#堆排序算法：&quot; class=&quot;headerlink&quot; title=&quot;堆排序算法：&quot;&gt;&lt;/a&gt;堆排序算法：&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化实践</title>
    <link href="http://example.com/2022/04/13/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A5-MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2022/04/13/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A5-MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-04-13T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:26.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL优化实践"><a href="#MySQL优化实践" class="headerlink" title="MySQL优化实践"></a>MySQL优化实践</h1><h3 id="1-大数据量拆分："><a href="#1-大数据量拆分：" class="headerlink" title="1.大数据量拆分："></a>1.大数据量拆分：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update coupons </span><br><span class="line">set status = 1 </span><br><span class="line">where status= 0 and create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59&#x27;;</span><br></pre></td></tr></table></figure><p>问题： 一个 SQL只能使用一个 cpu core去处理，如果 SQL很复杂或执行很慢，就会阻塞后面的 SQL请求，造成活动连接数暴增，MySQL CPU 100%，相应的接口Timeout，同时对于主从复制架构，做了业务读写分离，更新500w数据需要5分钟，Master上执行了5分钟，binlog传到了slave也需要执行5分钟，那就是Slave延迟5分钟，在这期间会造成 业务脏数据，比如重复下单等。<br>1.先获取 where 条件中的 最小id  ，最大id，<br>2.然后 分批次去更新，每个批次 1000条，这样既能快速完成更新，又能保证 主从复制不会出现延迟</p><p>先获取要更新的 数据范围内的 最小id和最大id（表没有物理delete，所以id是连续的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select min(id) min_id, max(id) max_id from coupons </span><br><span class="line">where status=0 </span><br><span class="line">and create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59’; </span><br><span class="line"></span><br><span class="line">current_id = min_id;</span><br><span class="line">for current_id &lt; max_id do</span><br><span class="line">    update coupons set status=1 </span><br><span class="line">    where id&gt;= current_id and id&lt;= current_id + 1000;    //通过主键id更新1000条很快</span><br><span class="line">commit;</span><br><span class="line">current_id += 1000;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>充分利用 辅助索引包含主键id的特性，先通过索引获取主键 id走覆盖索引扫描，不需要回表，然后再通过id去关联操作是高效的，同时根据 MySQL的特性 使用分而治之的思想既能高效完成操作，又能避免主从复制延迟产生的业务数据混乱。</p><h3 id="2-分解多表连接："><a href="#2-分解多表连接：" class="headerlink" title="2.分解多表连接："></a>2.分解多表连接：</h3><p>例如，使用 IN() 代替连接查询（in 等价于等值查询）可排序，让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">    JOIN tag_post ON tag_post.tag_id= tag.id</span><br><span class="line">    JOIN post ON tag_post.post_id= post.id</span><br><span class="line">    WHERE tag.tag=&#x27;mysql’;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;           --&gt; tag_id = 1234</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;      —&gt; (123,456,567,9098,8904)</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure><h3 id="3-MRR优化："><a href="#3-MRR优化：" class="headerlink" title="3.MRR优化："></a>3.MRR优化：</h3><p><strong>应用实例一：</strong>（mysql优化器改变where 条件顺序—&gt;匹配联合索引） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE key_part1&gt;=1000 and key_part1&lt;2000 AND key_part2=1000;</span><br></pre></td></tr></table></figure><p>表 t 有 ( key_part1,  key_part2 ) 的联合索引 ，因此索引根据 key_part1,  key_part2 的位置关系进行排序。<br>没有MRR：SQL优化器会先将 key_part1&gt;1000 and key_part2&lt;2000 的数据查询出来，待取出的数据后，再根据key_part2的条件进行过滤。这会导致无用的数据被取出，如果有大量的数据是 key_part2 !&#x3D;1000，则启用MRR优化会使性能有巨大的提升.<br>启用MRR优化：优化器会先 将查询条件进行拆分，然后在进行数据查询。优化器会将查询条件拆分为(1000,1000),(1001,1000),(1002,1000),…,(1999,1000)，然后在根据这些拆分出的条件，使用索引下推进行数据查询，避免回表。</p><h4 id="应用实例二："><a href="#应用实例二：" class="headerlink" title="应用实例二："></a><strong>应用实例二：</strong></h4><p> 在没有MRR之前,或没有开启 MRR特性时，MySQL 针对基于辅助索引的查询策略是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select non_key_column </span><br><span class="line">from tb where key_column=x;</span><br></pre></td></tr></table></figure><p>MySQL 执行查询的伪代码<br>第一步 先根据 where 条件中的 辅助索引，获取辅助索引与主键的集合，结果集为 rest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select key_column, pk_column from tb </span><br><span class="line">where key_column=x order by key_column </span><br></pre></td></tr></table></figure><p>第二步 通过第一步获取的主键来获取 对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for each pk_column value in rest do:</span><br><span class="line">select non_key_column from tb where pk_column=val</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryagegrej60ko0im3zx02.jpg" alt="71AD8A06-C4D7-4035-A63F-E0978354FC50" width="450" height="350"/><p>由于MySQL存储数据的方式： 辅助索引的存储顺序并非与主键的顺序一致，从图中可以看出,根据辅助索引获取的主键来访问表中的数据会导致随机的IO . 不同主键不在同一个page 里面时必然导致多次IO 和随机读。<br>在使用 MRR优化特性的情况下，MySQL 针对基于辅助索引的查询策略是这样的：<br>第一步 先根据 where条件中的辅助索引获取辅助索引与主键的集合，结果集为rest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select key_column, pk_column from tb where key_column = x order by key_column </span><br></pre></td></tr></table></figure><p>第二步 将结果集rest 放在buffer里面(read_rnd_buffer_size 大小直到buffer满了)，然后对结果集 rest按照pk_column排序，得到结果集是rest_sort<br>第三步 利用已经排序过的结果集，访问表中的数据，此时是顺序IO.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select non_key_column fromtb where pk_column in ( rest_sort )</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryaq9apaj60y80hkwge02.jpg" alt="863DB3B3-6049-45F0-B0DC-16D319E21722" width="650" height="350"/><p>​    从图示MRR原理，MySQL 将根据 辅助索引获取的结果集根据主键进行排序，将乱序化为有序，可以用-主键顺序访问基表，将随机读转化为顺序读，多页数据记录可一次性读入或 根据此次的主键范围分次读入，以减少IO操作，提高查询效率。<br>MRR的使用与否，是由 MySQL中的开关控制，只要设置开启，它会自动在 read_rnd_buffer_size 缓冲区 内，对primaryKey进行排序。但这个开关并不是一直开着，因为对于 大多数的单条查询，重新在中间添加一步排序，是对性能的损失，没有必要。所以Mysql 中还有一个 mrr_cost_based 开关，如果设置关闭，则完全按照 mrr 开关来执行了；如果设为开启，MySQL的优化器会通过 CBO算法确定是否开启MRR特性（进行对 primaryKey的排序）<br>​    mrr&#x3D;{on|off}<br>​    mrr_cost_based&#x3D;{on|off}</p><h3 id="4-大数据量下分页查询-limit-offset-batchSize"><a href="#4-大数据量下分页查询-limit-offset-batchSize" class="headerlink" title="4.大数据量下分页查询 limit offset, batchSize:"></a>4.大数据量下分页查询 limit offset, batchSize:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select  * from trade_info </span><br><span class="line">where status = 0 and </span><br><span class="line">create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59’ </span><br><span class="line">order by id desc </span><br><span class="line">limit 102120, 20;</span><br></pre></td></tr></table></figure><p>表 trade_info 上有索引 idx_status_create_time(status, create_time); 等价于索引（status, create_time,id)<br>对于典型的 分页 limit m, n来说，越往后翻页越慢( m越大会越慢);  因为要 定位 m位置需要扫描的数据越来越多，导致IO开销比较大。这里可以利用 辅助索引的覆盖扫描来进行优化，先获取id，这一步就是 索引覆盖扫描，不需要回表，然后通过 id 跟原表 trade_info进行关联<br>&#x2F;&#x2F; 改写后的SQL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from trade_info a , </span><br><span class="line">   (select id from trade_info </span><br><span class="line">    where status = 0 </span><br><span class="line">    and create_time &gt;=&#x27;2020-10-01 00:00:00&#x27; and create_time &lt;=&#x27;2020-10-07 23:59:59’ </span><br><span class="line">    order by id desc limit 102120, 20)  as b    -- 这一步走的是索引覆盖扫描，不需要回表</span><br><span class="line"> where a.id = b.id;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong> 分页查询时，MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，而且在取offset+N 行数据时，因为是select * … 的操作，所以是需要回表的，查询到索引叶子节点数据，根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值。<br>那当 offset 特别大的时候，此时使用 limit m,n 效率就非常的低下，因为回表了 M 行无用的数据，并且占用了大量的 buffer pool 缓存。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>1.控制返回的总页数；<br>2.对超过特定阈值的页数进行 SQL 改写<br>SELECT a.* FROM USER a  INNER JOIN  (SELECT id  FROM USER WHERE age &#x3D; 10 LIMIT 100000,10) b  ON a.id &#x3D; b.id;  结果0.53s<br>需要对 where条件增加索引，id 因为是主键自带索引，select返回减少回表可以提升查询性能, 所以采用查询主键字段后进行关联大幅度提升了查询效率。<br>3.使用Redis 来保存lastMaxtId, 下一次分页查询时直接拼接在 where 条件后边，直接跨过 offset 行数据。</p><h3 id="常见慢查询问题："><a href="#常见慢查询问题：" class="headerlink" title="常见慢查询问题："></a>常见慢查询问题：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryax8sv9j61860oan1002.jpg" alt="14B56083-7EBD-4768-AD40-E3C00DFA418D" width="850" height="500" /><p>1.确定主键，索引字段，将它们作为查询条件<br>2.数据量过大，使用 limit 做分页处理，  limit  起始id, 条数count<br>3.当 limit 起始行数很大时， 查询效率会降低， 可以考虑使用自增 id </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Select *. From table limit  150000 , 5000</span><br><span class="line"></span><br><span class="line">优化： Select * from table where id&gt;150000 and id&lt;200000;  -- 速度会有提升</span><br></pre></td></tr></table></figure><p>4.数据导入，可尝试批量导入数据 ；<br><strong>性能：Load  &gt; insert.</strong><br>load 只操作一次，之后数据 批量插入<br>insert 每个数据操作一次，’就要遍历 一次字段索引</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL优化实践&quot;&gt;&lt;a href=&quot;#MySQL优化实践&quot; class=&quot;headerlink&quot; title=&quot;MySQL优化实践&quot;&gt;&lt;/a&gt;MySQL优化实践&lt;/h1&gt;&lt;h3 id=&quot;1-大数据量拆分：&quot;&gt;&lt;a href=&quot;#1-大数据量拆分：&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>TCP/UDP/Http</title>
    <link href="http://example.com/2022/04/10/E-%E7%BD%91%E7%BB%9C/2.TCP-UDP-Http%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/04/10/E-%E7%BD%91%E7%BB%9C/2.TCP-UDP-Http%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-04-10T13:55:19.000Z</published>
    <updated>2022-04-19T13:04:25.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-UDP-x2F-Http"><a href="#TCP-x2F-UDP-x2F-Http" class="headerlink" title="TCP&#x2F;UDP&#x2F;Http"></a>TCP&#x2F;UDP&#x2F;Http</h1><h3 id="http-中的长，短链接："><a href="#http-中的长，短链接：" class="headerlink" title="http 中的长，短链接："></a>http 中的长，短链接：</h3><p>​    在 HTTP&#x2F;1.0中 默认短连接，客户端和 服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就 中断连接。当客户端浏览器访问某个Web页中包含有其他的 Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>​    从HTTP&#x2F;1.1起，默认长连接，用以 保持连接特性。使用长连接的 HTTP协议，会在 响应头加入这行代码：Connection:keep-alive；<br>使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间 用于传输 HTTP数据的 TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，有一个保持时间，可以设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP 协议的长，短连接，实质上是 TCP协议的长，短连接。<br><strong>http 长连接：</strong>设置 connection 为 keep-alive ；在 header 中有个超时时间，超过此时间就断开长连接<br>长连接： 多个 http 请求复用同一个 TCP ； 频繁通信<br>短链接： 一个 http 用一个 TCP；  长时间不通信，创建，关闭都会浪费时间</p><p>长优点： 省去较多的 TCP建立和关闭操作，减少浪费，节约时间，对于 频繁请求资源的客户端较适合<br>短优点： 管理起来简单，存在的连接都是有用的连接，不需要额外的控制手段 </p><p>像 Web 网站的 http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 web网站有大量的客户端连接 用 短连接会省一些资源，如果用长连接，同时有成千上万的用户，每个 用户都占用一个连接的话，并发量很大，资源消耗很大； 而且每个用户无需频繁操作。</p><h3 id="浏览器中输入一个网址-url，执行过程："><a href="#浏览器中输入一个网址-url，执行过程：" class="headerlink" title="浏览器中输入一个网址 url，执行过程："></a>浏览器中输入一个网址 url，执行过程：</h3><p>1.应用层：浏览器看是否有缓存（浏览器，本地）; 没有则通过 DNS 解析，将 域名 转成其所对应的 服务器 ip地址，确定从浏览器到服务器的一条路径<br>2.传输层：将 http 会话通过 TCP 协议封装成数据包，在 源，目的端添加 对应的端口号, 来保证端到端的可靠传输<br>3.网络层：通过 IP 协议，查找 路由表，确定如何路由线路，到达服务器<br>4.数据链路层： 通过 邻居发现协议 ND， 查找到 给定 IP 地址的 mac 地址，发送 ARP 请求查找目的地址<br>5.物理层：将 ip 数据包转换成比特流，在物理链路上传输</p><h3 id="Web-页面请求过程："><a href="#Web-页面请求过程：" class="headerlink" title="Web 页面请求过程："></a>Web 页面请求过程：</h3><p>1.浏览器进行DNS域名解析，得到对应的IP地址<br>2.根据这个IP，找到对应的服务器，建立连接（三次握手）<br>3.建立TCP连接后发起 HTTP请求（一个完整的 http请求报文）<br>4.服务器响应HTTP请求，浏览器得到 html代码（服务器如何响应）<br>5.浏览器解析 html代码，并请求 html代码中的资源（如js，css，图片等）<br>6.浏览器对页面进行渲染呈现给用户<br>7.服务器关闭 TCP连接（四次挥手）</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>1.首先会搜索浏览器自身的 DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p><p>2.如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p><p>3.如果还没有找到，那么尝试从 hosts文件里面去找</p><p>4.在前面三个过程都没获取到的情况下，浏览器会发起一个DNS的系统调用，向本地配置的首选DNS服务器（一般是电信运营商提供）发起域名解析请求（通过 UDP协议向 DNS的 53端口发起请求，这个请求是递归的，就是要求运营商的DNS服务器必须提供给我们该域名的IP地址）<br>DNS优化两个方面： DNS缓存, DNS负载均衡</p><h3 id="TCP-与-UDP-区别："><a href="#TCP-与-UDP-区别：" class="headerlink" title="TCP 与 UDP 区别："></a>TCP 与 UDP 区别：</h3><p>1.基于 TCP有连接； UDP 无连接；<br>2.TCP数据正确性，可靠传输，无差错，不丢失，不重复，且按序到达；<br>   UDP可能丢包，不可靠传输，UDP 尽最大努力交付，即不保   证可靠交付<br>   UDP没有拥塞控制，因此网络出现 拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>3.UDP 程序结构较简单，速度快，适合传输大数据； TCP 速度慢，适合小数据传输<br>4.TCP面向字节流;  UDP是面向报文的<br>5.每一条 TCP连接只能是点到点的;  UDP支持一对一，一对多，多对一和多对多的交互通信<br>6.TCP首部开销 20字节;  UDP的首部开销 8个字节<br>7.TCP通信 信道是 全双工的可靠信道，UDP则是 不可靠信道</p><h3 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h3><p><strong>点对点  让发送速率不要过快</strong>，使接收方来得及接收;  利用 滑动窗口机制就可以实施流量控制<br><strong>原理：</strong>运用 TCP报文段中的 窗口大小字段来控制，发送方的发送窗口不能  &gt; 接收方发回的窗口大小<br>滑动窗口协议是传输层进行流控的一种措施，接收方告知发送方自己可以接受缓冲区大小（此字段越大–网络吞吐量越高），从而控制发送方的发送速度，如果接收端缓冲区面临数据溢出，窗口大小值会被设置一个更小的值通知给发送端，从而控制数据发送量（发送端根据接收端指示，进行流量控制）</p><p><strong>拥塞控制：</strong>整个网络解决 过多的 数据注入到网络,  导致网络崩溃,  超过负荷, 拥塞控制包含四个策略<br>防止过多的数据注入到网络中，导致网络中的 路由器或链路过载；发送方控制 拥塞窗口的原则是：只要网络 没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去； 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><h3 id="拥塞控制四个策略："><a href="#拥塞控制四个策略：" class="headerlink" title="拥塞控制四个策略："></a><strong>拥塞控制四个策略：</strong></h3><p><strong>1.慢开始：</strong>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2,4,8 …； 慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，慢开始结束。</p><p><strong>2.拥塞避免：</strong>慢开始结束后 是 拥塞避免, 此时拥塞窗口 每个传输轮次 + 1,  直到 触发网络拥塞；如果出现超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始。</p><p><strong>3.快重传：</strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 快重传要求接收方在 收到一个失序的报文段后 ，立即发出重复确认，而  不是等到自己发送数据时 捎带确认；发送方只要一连收到三个重复确认ACK， 就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>4.快恢复：配合快重传使用</strong>，在收到三个重复确认ACK后，这种情况下只是丢失个别报文段，不是网络拥塞。因此执行快恢复，设ssthresh &#x3D; cwnd&#x2F;2 ，cwnd &#x3D; ssthresh，注意到此时直接进入 拥塞避免。 </p><p>注意：在采用快恢复算法时，慢开始算法只是在 TCP连接建立时和网络出现超时时才使用</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru93o6d9j612w0gimzi02.jpg" alt="0043A64C-1752-4B59-805F-250ED799F749" width="700" height="300"  /><h3 id="流量控制与拥塞控制-区别："><a href="#流量控制与拥塞控制-区别：" class="headerlink" title="流量控制与拥塞控制 区别："></a>流量控制与拥塞控制 区别：</h3><p><strong>相同点：</strong> 都会丢包；实现机制都是让发送方发的 慢一点，发的少一点； 提高网络性能<br><strong>不同点：</strong><br>1.丢包位置不同，流量控制丢包位置是在接收端上；  拥塞控制丢包：在路由器上<br>2.作用对象不同：流量控制对象是 接收方，防止发送方发的太快，来不及接受； 拥塞控制对象是 网络，防止发送方发的太快，造成网络拥塞，超过网络负荷。<br>3.联系：拥塞控制是一个全局性的过程，涉及网络中的所有主机，所有路由器，考虑网络负荷；流量控制是局部的，发生在端和端之间，是点到点的控制。</p><h3 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru9fuobcj60nr0fddh202.jpg" alt="Image" width="650" height="400" /><p>客户端和 服务器建立的是可靠的   全双工连接：<br>客户端：确定，服务器是可以接受，发送数据<br>服务器：确定，客户端是可以接受，发送数据</p><p><strong>第一次握手：</strong>建立连接时，客户端发送 syn包 (syn&#x3D;j)到服务器，并进入 SYN_SEND状态，等待服务器确认；此时对于服务器而言，服务器知道自己的 “接收”能力正常，客户端的 “发送”能力正常。<br><strong>第二次握手：</strong>服务器收到 syn包，确认客户 SYN（ack&#x3D;j+1），同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包 ，此时服务器进入 SYN_RECV状态；<br>此时对于客户端而言，客户端知道自己的“发送”能力正常；客户端的“接收”能力正常； 知道服务器的“发送”、“接收”能力正常<br>此时对于服务器而言，服务器知道客户端“发送”能力正常，但客户端“接收”能力不确定，同时，服务器知道自己“接收”能力正常，但“发送”能力不确定 。<br><strong>第三次握手：</strong>客户端收到服务器SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)，发送完毕后客户端和服务器进入 ESTABLISHED状态，完成三次握手。<br>此时对于服务器而言，服务器就能确定自己的“发送”能力正常，客户端的“接收”能力正常。<br>通过这样的三次握手，双方都能确定自己和对方的收，发能力正常，客户端与 服务端建立起 可靠的双工的连接，开始传送数据。</p><p>TCP 协议为实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要 重传。 为了实现这个需求，就涉及到 序号（sequence number） 和 确认号（acknowledgement number） 这2个概念 。<br><strong>序列号 seq：</strong>TCP 连接中传送的数据流中每一个字节都编上一个序号，序号字段的值是 本报文段所发送的数据的第一个字节的序号。<br><strong>确认号 ack：</strong>期望收到对方下一个报文段数据的第一个字节的序号。</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru9mrx5dj60ft0ap3za02.jpg" alt="C04AF208-878B-4928-A90D-ABB44B58C24C" width="650" height="400"  /><p><strong>第一次：</strong>A 应用进程先向其 TCP发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。<br><strong>第二次：</strong>B 收到连接释放报文段后即发出确认报文段，（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。<br>A 收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。<br>此时客户端不再向服务器发送数据，服务器不再接受数据； 但服务器还会将没发送完的数据发给客户端，客户端可以继续接受服务器发来的数据。<br><strong>第三次：</strong>当B没有要发的数据时，释放报文段(FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1)，B进入LAST-ACK最后确认状态，等待A确认。<br><strong>第四次：</strong>A收到B的连接释放报文段后，对此发出确认报文段(ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1)，A进入 TIME-WAIT（时间等待）状态。此时 TCP未释放掉，需要 经过时间 等待计时器设置的时间 2MSL后，A才进入CLOSED状态。</p><h4 id="为什么-A-在-TIME-WAIT状态等待-2MSL的时间？"><a href="#为什么-A-在-TIME-WAIT状态等待-2MSL的时间？" class="headerlink" title="为什么 A 在 TIME-WAIT状态等待 2MSL的时间？"></a>为什么 A 在 TIME-WAIT状态等待 2MSL的时间？</h4><p>MSL 最长报文段寿命 Maximum Segment Lifetime，MSL&#x3D;2<br><strong>1.避免B 服务端无法 closed 关闭；</strong>确保有足够时间让 服务器 收到 对方的 ACK 包，一来一去就是2MSL； TCP 可靠的，服务器在 2MSL 时间后没收到ACK 会超时重传 ；ACK 报文段可能丢失，使得处于LAST-ACK状态的B 收不到对已发送的 FIN+ACK报文段的确认，B 超时重传FIN+ACK报文段，而 A 能在 2MSL时间内收到这个重传的 FIN+ACK报文段，接着 A重传一次确认，重新启动 2MSL计时器，最后A和B都进入到CLOSED状态；若A在TIME-WAIT状态不等待一段时间，而是 发送完 ACK报文段后立即释放连接，则 无法收到 B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则 B无法正常进入到CLOSED状态。</p><p><strong>2.避免 新旧连接混: 即 不会跟后面的 新连接混淆；</strong>  防止“ 已失效的连接请求 报文段”出现在本连接中；A 在发送完最后一个 ACK报文段后，再经过 2MSL，可以使 本连接持续时间内所产生的所有报文段 都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p><h4 id="为什么连接时三次握手，关闭时四次握手？"><a href="#为什么连接时三次握手，关闭时四次握手？" class="headerlink" title="为什么连接时三次握手，关闭时四次握手？"></a>为什么连接时三次握手，关闭时四次握手？</h4><p>当 Server 端收到 Client 端的 SYN连接请求报文后，可以直接 <strong>发送SYN+ACK报文</strong>。其中 ACK报文是用来应答的，SYN报文是用来同步的<br>但是关闭连接时，当 Server端收到FIN报文时，可能不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉 Client端，你发的FIN报文我收到。只有等到我 Server端所有的报文都发送完，我才能发送FIN报文，因此不能一起发送,  故需要四步握手。</p><h4 id="SYN泛洪（SYN-flood）攻击："><a href="#SYN泛洪（SYN-flood）攻击：" class="headerlink" title="SYN泛洪（SYN flood）攻击："></a>SYN泛洪（SYN flood）攻击：</h4><p>​    如果大量的握手请求涌向TCP服务端，而它们只发出SYN报文而不以ACK响应结束握手，服务端就要为这每一个请求都维持约一分多钟的连接去等待ACK，也就形成所谓的“半连接”。维护这些半连接是需要消耗很多服务器的网络连接资源的。如果短时间内这些资源几乎都被半连接占满，那么正常的业务请求在这期间就得不到服务，处于等待状态。如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这就形成了DoS（Denial of Service拒绝服务）攻击。</p><h3 id="Http的方法："><a href="#Http的方法：" class="headerlink" title="Http的方法："></a>Http的方法：</h3><p>Get, post 是客户端和服务器端进行请求-响应的常用方法<br><strong>GET 请求： 获取资源</strong><br>1.可被 缓存<br>2.保留在 浏览器历史记录中<br>3.有长度限制；URL 的最大长度是 2048 个字符<br>4.可被 收藏为书签<br>5.数据在 URL 中对所有人都是可见的<br>6.传输的表单在 url中</p><p><strong>POST 请求： 传输实体主体</strong><br>1.不会被缓存<br>2.不会保留在浏览器历史记录中<br>3.没有对数据长度的限制<br>4.不能 被收藏为书签<br>5.数据不会显示在 URL 中<br>6.传输的表单在request请求的 body中</p><p><strong>HEAD： 获取报文首部</strong></p><p>和GET方法类似，但服务器在响应中 只返回首部，不返回实体的主体部分；允许客户端在未获取实际资源情况下，对资源首部进行检查<br>优点：<br>1.在 不获取资源的情况下 了解资源（比如：判断其类型）；<br>2.通过查看 响应的状态码，看看某个对象是否存在；<br>3.通过查看首部，测试资源是否被修改  </p><p><strong>PUT： 上传文件</strong><br>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p><h3 id="HTTP-和-HTTPs-区别："><a href="#HTTP-和-HTTPs-区别：" class="headerlink" title="HTTP 和 HTTPs 区别："></a>HTTP 和 HTTPs 区别：</h3><p>HTTP 的请求过程：<br>1.TCP 建立连接后，客户端会发送报文给服务端；<br>2.服务端接收报文并作出响应；<br>3.客户端收到响应后解析给用户；<br>HTTP协议 不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信,非常不安全</p><p>HTTPS 在 HTTP 的基础上加入 SSL 层，HTTPS 的安全基础是 SSL，HTTPS 存在 不同于 HTTP 的默认端口和 一个加密&#x2F;身份验证层(在HTTP与 TCP之间）这个系统提供了 身份验证与加密通讯方法;  它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。</p><h3 id="HTTPS的请求过程："><a href="#HTTPS的请求过程：" class="headerlink" title="HTTPS的请求过程："></a>HTTPS的请求过程：</h3><p>1.客户端 发送请求到 服务端；<br>2.服务器返回 数字证书（公钥，明文数据，签名，服务器域名）<br>3.客户端 根据数字证书来验证服务器是不是自己要访问的（有效性），有效则随机生成对称加密的密钥X，并使用公钥加密密钥X，然后发送到服务端；<br>4.服务端使用 私钥解密，得到 对称密钥X ； 后续使用密钥 X 对报文加密传输</p><p><strong>数字证书：</strong>验证访问的 服务器网站是有效的，合法的<br><strong>签名：</strong> 验证 数字证书是有效的<br>CA 机构对数字证书中的 明文数据，做 hash ，然后使用 私钥加密得到 签名 S<br>浏览器收到 数字证书后，通过 公钥对签名 S 解密得到 T， 然后对 明文数据进行 hash 得到 T’ ；通过验证T&#x3D;&#x3D;T’ 来保证数字证书没有被篡改<br>Hash 作用：证书信息一般较长，而 hash后得到固定长度的信息(比如用 md5算法hash后得到固定的 128位的值),这样加密，解密会快很多<br><strong>数字证书公钥：</strong> 操作系统，浏览器本身会预装一些它们信任的根证书，其中会有 CA机构的根证书，这样就可以拿到它对应的 可信公钥，不是每次请求都经历一次密钥传输过程：服务器 会为每个浏览器维护一个 session ID，浏览器生成好 密钥X传给服务器，服务器把该 密钥X存到相应的 session ID，之后 浏览器每次请求都会携带 session ID，服务器根据 session ID 找到相应的密钥进行解密，加密操作。<br>        服务器端有个session ID 表，客户端第一次带着账户信息请求时，服务端查库，并产生一个 sessionID 返回给客户端，客户端之后请求时，会把 sessionID 放到cookie 中，携带cookie 请求，服务端通过校验sessionID，如果在sessionID表中，直接通过避免查库。</p><h4 id="HTTPS-缺点："><a href="#HTTPS-缺点：" class="headerlink" title="HTTPS 缺点："></a>HTTPS 缺点：</h4><p>1.https协议是 多次握手，导致页面 加载时间延长近50%;<br>2.https 连接 缓存不如HTTP高效，会 增加数据开销和功耗;<br>3.申请SSL 证书需要钱，功能越强大的证书费用越高;<br>4.SSL涉及到的安全算法会 消耗 CPU 资源，对服务器资源消耗较大</p><h4 id="http-和-https-区别："><a href="#http-和-https-区别：" class="headerlink" title="http 和 https 区别："></a>http 和 https 区别：</h4><p>1.https 是 http 协议的安全版本<br>2.http 协议的 数据传输是明文的，是不安全的;   https使用 SSL&#x2F;TLS 非对称加密协议进行加密处理， 是安全的<br>3.http 和https 使用连接方式不同，默认端口不一样，http是80，https是443<br>4.https协议对传输的数据进行加密，内容传输上使用对称加密，证书验证上使用非对称加密</p><h3 id="Https整体过程分为证书验证和数据传输阶段："><a href="#Https整体过程分为证书验证和数据传输阶段：" class="headerlink" title="Https整体过程分为证书验证和数据传输阶段："></a>Https整体过程分为证书验证和数据传输阶段：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guruaqnpc6j60y40u0tcd02.jpg" alt="2BD4ED6C-0A4F-49AE-AD91-A0675CDBC23C" width="700" height="500"  /><p>​    非对称加密的 <strong>加解密效率</strong>是 非常低的，而 http 应用场景中通常 端与端之间存在大量的交互，非对称加密的效率是无法接受的。<br>在 https场景中只有 服务端保存私钥，一对公钥，私钥只能实现单向的加密和解密，所以https 中内容传输加密是 对称加密，证书验证是非对称加密。</p><h3 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurvv95xvsj61a60q0q8102.jpg" alt="image-20210924172152459" width="750" height="400"  /><p>301 永久重定向；  302 暂时重定向；  网站调整； 网页移到新地址； 扩展名改变</p><h3 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。<br>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。<br>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h3><p>​    除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<br>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</li></ul><h3 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有用户信息都存储到 Session 中。#</li></ul><h3 id="RPC-与http-区别："><a href="#RPC-与http-区别：" class="headerlink" title="RPC 与http 区别："></a>RPC 与http 区别：</h3><p>RPC ： 远程调用其他计算机服务，底层使用 TCP 传输协议； 指定数据传输格式，序列化方式<br>相同点： 底层都是基于 socket 编程，使用 TCP 协议，实现远程调用，服务调用 服务<br>不同：<br>RPC ： 提供方，消费方 都使用 统一的RPC 框架（ dubbo）, 跨操作系统，同一编程语言内使用；  调用快，处理快，实现复杂<br>HTTP： 跨操作系统，跨编程语言； 通用性强， 实现简单</p><h3 id="区分-MSS-与-MTU："><a href="#区分-MSS-与-MTU：" class="headerlink" title="区分 MSS 与 MTU："></a><strong>区分 MSS 与 MTU：</strong></h3><p>最大传输单元（Maximum Transmission Unit, MTU）， 最大报文段长度（Maximum Segment Size ，MSS）协议用来定义最大长度的<br>MTU 应用于 数据链接层，并无具体针对的协议。 MTU限制数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知 某局域网的 MTU为1500字节，则在网络层的因特网协议（ IP）里最大数据包大小为 1500字节（包含IP协议头）。<br>MSS 应用于 传输层的TCP协议，因为 MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/161560683">https://zhuanlan.zhihu.com/p/161560683</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-x2F-UDP-x2F-Http&quot;&gt;&lt;a href=&quot;#TCP-x2F-UDP-x2F-Http&quot; class=&quot;headerlink&quot; title=&quot;TCP&amp;#x2F;UDP&amp;#x2F;Http&quot;&gt;&lt;/a&gt;TCP&amp;#x2F;UDP&amp;#x2F;Http&lt;/</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>请求代理服务器--加密</title>
    <link href="http://example.com/2022/04/09/E-%E7%BD%91%E7%BB%9C/3.%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8A%A0%E5%AF%86/"/>
    <id>http://example.com/2022/04/09/E-%E7%BD%91%E7%BB%9C/3.%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8A%A0%E5%AF%86/</id>
    <published>2022-04-09T13:55:19.000Z</published>
    <updated>2022-04-19T13:04:31.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求代理服务器–加密"><a href="#请求代理服务器–加密" class="headerlink" title="请求代理服务器–加密"></a>请求代理服务器–加密</h1><p><strong>代理服务器：</strong> 提供代理服务的电脑系统或其它类型的网络终端,代替网络用户去取得网络信息。</p><p>使用代理的<strong>主要目的：</strong></p><ul><li><p>缓存：提高访问速度，由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到缓存的作用，尤其对于热门网站能明显提高访问速度。</p></li><li><p>网络访问控制：防火墙作用，由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。</p></li><li><p>突破访问限制：互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。</p></li><li><p>负载均衡，通过配置后台各个服务器的权重参数，实现多机负载</p></li></ul><h4 id="正向代理的应用"><a href="#正向代理的应用" class="headerlink" title="正向代理的应用"></a><strong>正向代理的应用</strong></h4><ol><li><p>访问原来无法访问的资源</p></li><li><p>用作缓存，加速访问速度</p></li><li><p>对客户端访问授权，上网进行认证</p></li><li><p>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p></li></ol><h4 id="反向代理的应用"><a href="#反向代理的应用" class="headerlink" title="反向代理的应用"></a><strong>反向代理的应用</strong></h4><ol><li>保护内网安全</li><li>负载均衡</li><li>缓存，减少服务器的压力</li></ol><p><strong>正向代理：</strong>一个位于客户端和原始服务器之间的服务器，为了从 <strong>原始服务器取得内容</strong>，客户端向代理发送一个请求并制定目标（原始服务器），然后 <strong>代理向原始服务器转发请求</strong>并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2sm4zxj60i907mwem02.jpg" alt="img" width="450" height="200"  /><p><strong>反向代理：</strong>以 <strong>代理服务器来接受internet上的连接请求</strong>，然后 将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2psrynj60ec076mx702.jpg" alt="img" width="450" height="200"  /><h3 id="正向-x2F-反向区别："><a href="#正向-x2F-反向区别：" class="headerlink" title="正向&#x2F;反向区别："></a>正向&#x2F;反向区别：</h3><p><strong>1.位置不同</strong></p><ul><li><p>正向代理，架设在客户机和目标主机之间；</p></li><li><p>反向代理，架设在服务器端；</p></li></ul><p><strong>2.代理对象不同</strong></p><ul><li><p>正向代理，代理客户端，服务端不知道实际发起请求的客户端；</p></li><li><p>反向代理，代理服务端，客户端不知道实际提供服务的服务端；</p></li></ul><p><strong>3.安全性不同</strong></p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务；</li><li>反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。</li></ul><h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术:"></a>加密技术:</h3><p>是对信息进行编码和解码的技术，编码是把原来可读信息（明文）译成代码形式（密文），其逆过程就是解码（解密），加密技术要点是加密算法，加密算法可分为三类：</p><h4 id="对称加密，如AES："><a href="#对称加密，如AES：" class="headerlink" title="对称加密，如AES："></a>对称加密，如AES：</h4><p>​    基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。<br>​    优势：算法公开、计算量小、加密速度快、加密效率高<br>​    缺陷：双方都使用 同样密钥，安全性得不到保证</p><h4 id="非对称加密，如RSA："><a href="#非对称加密，如RSA：" class="headerlink" title="非对称加密，如RSA："></a>非对称加密，如RSA：</h4><p>​    基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端<br>​    私钥加密，持有 私钥、公钥才可以解密<br>​    公钥加密，持有 私钥才可解密<br>​    优点：安全，难以破解<br>​    缺点：算法比较耗时</p><h4 id="不可逆加密，如MD5，SHA："><a href="#不可逆加密，如MD5，SHA：" class="headerlink" title="不可逆加密，如MD5，SHA："></a>不可逆加密，如MD5，SHA：</h4><p>​    基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。</p><h4 id="1-在没有RSA加密时："><a href="#1-在没有RSA加密时：" class="headerlink" title="1.在没有RSA加密时："></a>1.在没有RSA加密时：</h4><p>在微服务架构中，可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru1r5iujj60mi0fc75902.jpg" alt="1527312464328" width="650" height="400"  /><p>1.用户请求登录<br>2.Zuul将请求转发到授权中心，请求授权<br>3.授权中心校验完成，颁发JWT凭证<br>4.客户端请求其它功能，携带JWT<br>5.Zuul将jwt交给授权中心校验，通过后放行<br>6.用户请求到达微服务<br>7.微服务将jwt交给鉴权中心，鉴权同时解析用户信息<br>8.鉴权中心返回用户数据给微服务<br>9.微服务处理请求，返回响应<br>问题： 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。</p><h4 id="2-在结合RSA的鉴权："><a href="#2-在结合RSA的鉴权：" class="headerlink" title="2.在结合RSA的鉴权："></a>2.在结合RSA的鉴权：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2cq63ej60ma0ezt9t02.jpg" alt="1527313765010" width="650" height="400"  /><p>1.利用RSA生成公钥和私钥，私钥保存在授权中心，公钥保存在Zuul和各个信任的微服务<br>2.用户请求登录<br>3.授权中心校验，通过后用私钥对JWT进行签名加密<br>4.返回jwt给用户<br>5.用户携带JWT访问<br>6.Zuul直接通过 公钥解密 JWT，进行验证，验证通过则放行<br>7.请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;请求代理服务器–加密&quot;&gt;&lt;a href=&quot;#请求代理服务器–加密&quot; class=&quot;headerlink&quot; title=&quot;请求代理服务器–加密&quot;&gt;&lt;/a&gt;请求代理服务器–加密&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代理服务器：&lt;/strong&gt; 提供代理服务的电脑系统或其它</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://example.com/2022/04/08/E-%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/04/08/E-%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2022-04-08T13:55:19.000Z</published>
    <updated>2022-04-19T13:04:20.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述："><a href="#计算机网络概述：" class="headerlink" title="计算机网络概述："></a>计算机网络概述：</h1><p>网络是把主机连接起来，互连网（internet）是把多种不同的网络连接起来。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvo14kvhj60pe0gkjsy02.jpg" width="350" height="200"  /><h4 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h4><p>1.客户-服务器(C&#x2F;S)：客户是服务的请求方，服务器是服务的提供方</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvoxas2uj60ds0b0aa502.jpg" alt="103AEF76-2D90-48D2-8F3F-48F45A280D2D" width="250" height="150"  /><p>2.对等(P2P):  不区分客户和服务器</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvptl5y4j60d20b0dg002.jpg" alt="240FE4DC-14A2-49AB-8C9F-8F0105C7BF4B" width="250" height="150"  /><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>每台计算机通信时把数据包进行分组打包，只要在头部附上本机的信息和组号就可以多台计算机共用一条通信线路，这样就提高了通信线路的利用率。分组交换过程中发送端计算机发送给路由器，路由器会缓存这部分数据然后再转发给目标计算机。路由器不一定按照队列先进先出然后再发出去，也有可能优先发出一些特殊的数据。<br>每个分组都有首部和尾部，包含源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互不影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><p>网络传输时延：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvqjh6ovj60l407gjro02.jpg" alt="9DDA2E4C-67B6-42EC-911E-35C0355914AC" width="650" height="200"  /><p>总时延  &#x3D;  排队时延 +  处理时延 +  传输时延 +  传播时延</p><ol><li>排队时延：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li><li>处理时延：主机或路由器收到分组时进行处理所需要的时间；例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li><li>传输时延：主机或路由器传输数据帧所需要的时间。</li></ol><p>4.传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvqsrrjjj60gl06rdh002.jpg" alt="FFE6973C-138C-48DB-90FC-3C6794A1DB0D" width="650" height="300"  /><h3 id="七层协议："><a href="#七层协议：" class="headerlink" title="七层协议："></a>七层协议：</h3><ul><li>应用层 ：为特定 应用程序提供数据传输服务；例如 HTTP、DNS 等协议。数据单位：报文</li><li>表示层 ：数据压缩、加密以及数据描述，使应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li>会话层 ：建立及管理会话。</li><li>传输层 ：为进程提供通用数据传输服务。应用层协议很多，定义通用的传输层协议可以支持不断增多的应用层协议。<br>传输层包括：TCP，UDP</li><li>网络层 ：为主机提供数据传输服务。传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或用户数据报封装成分组。</li><li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li>物理层 ：在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="协议的层次、模型："><a href="#协议的层次、模型：" class="headerlink" title="协议的层次、模型："></a><strong>协议的层次、模型：</strong></h3><p>OSI 七层模型：<br>应用层： 允许有访问OSI 环境的手段，HTTP，FTP,DNS, SMTP, Telnet<br>表示层： 对数据进行翻译，加密、压缩  JPEG，MPEG<br>会话层： 建立，管理和终止会话 SQL， RPC<br>传输层： 提供不同端系统的进程间通信 TCP，UDP<br>网络层： 提供主机间的通信， IP， ICMP， ARP，<br>数据链路层： 提供网络中点到点之间数据帧的传递PPP，MAC（网桥，交换机）<br>物理层： 提供在物理介质上每一比特的传输 CLOCK， IEEE802.3（中继器，集线器，网关）</p><p>Internet 五层模型：<br>应用层：   将应用程序的 报文交给传输层<br>传输层：  将接收的报文分段，封装TCP&#x2F;UDP头部信息，将报文段传递给网络层<br>网络层：  将接收的报文段封装 IP头部信息，将数据报交给数据链路层<br>数据链路层： 将接收网络层的数据报，封装数据帧头部信息，将数据帧从一个节点通过链路传到另一个节点<br>物理层： 数据链路层负责将一个个数据帧从一点传递到另一点，物理层负责一个个比特从一点传递到另一点</p><h4 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h4><p>HTTP、DNS 、FTP等协议</p><h4 id="传输层：-两种协议"><a href="#传输层：-两种协议" class="headerlink" title="传输层： 两种协议"></a>传输层： 两种协议</h4><p>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；<br>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p><h4 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h4><p>IP 协议：根据路由表实现IP数据报的路由转发</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvrggomrj60zs0k2dj302.jpg" alt="F9F897CF-D0C9-4F9A-A010-3985E6274581" width="680" height="350" /><h4 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h4><p>信道分类： </p><ol><li>广播信道： 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。</li><li>点对点信道： 一对一通信： 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</li></ol><p>信道复用技术： 频分复用；时分复用；统计时分复用；波分复用；码分复用</p><p>MAC 地址：<br>链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><p>交换机：<br>有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>地址解析协议 ARP<br>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。<br>ARP 实现由 IP 地址得到 MAC 地址。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>根据信息在传输线上的传送方向，分为以下三种通信方式：<br>单工通信：单向传输；<br>半双工通信：双向交替传输；<br>全双工通信：双向同时传输</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络概述：&quot;&gt;&lt;a href=&quot;#计算机网络概述：&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概述：&quot;&gt;&lt;/a&gt;计算机网络概述：&lt;/h1&gt;&lt;p&gt;网络是把主机连接起来，互连网（internet）是把多种不同的网络连接起来。&lt;/p&gt;
&lt;im</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL实践案例</title>
    <link href="http://example.com/2022/03/15/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B2-SQL%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/03/15/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B2-SQL%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/</id>
    <published>2022-03-15T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:35.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL实践案例"><a href="#SQL实践案例" class="headerlink" title="SQL实践案例"></a>SQL实践案例</h1><p>查寻每个省份中，金额排 前三的数据</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryq33sqkj60q00g0mys02.jpg" alt="779BB0D3-D123-45C3-9705-FBE5B65973CA" width="350" height="200" />          <img src="https://tva1.sinaimg.cn/large/008i3skNly1guryq7vz98j60pe08swfa02.jpg" alt="A8F514AE-FB66-4027-B813-4FA44385AE55" width="350" height="150" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># a.province = b.province 表示分组，里外统一省份</span><br><span class="line"># b.amount &gt; a.amount 表示 内部金额 &gt; 外部金额的 条数</span><br><span class="line"># 先确定 外部金额，在从内部金额中找到满足条件的数量</span><br><span class="line">select * </span><br><span class="line">from city_order as a </span><br><span class="line">where 3 &gt; ( select count(*) from city_order as b </span><br><span class="line">            where a.province=b.province and a.amount&lt; b.amount );</span><br><span class="line">ORDER BY amount desc;</span><br></pre></td></tr></table></figure><p>使用group by 分组统计之后，select 后面只能跟：  group by 的字段、聚合函数</p><p>select 中的非多行函数列，都必须出现在group by 中,在group by 中的列，可以出现或不出现在 select 字句中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select deptno, avg(sal)</span><br><span class="line">from emp</span><br><span class="line">group by deptno;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select province , max(amount) amount</span><br><span class="line">from city_order</span><br><span class="line">group by province;</span><br><span class="line"></span><br><span class="line">select province , avg(amount) amount</span><br><span class="line">from city_order</span><br><span class="line">group by province</span><br><span class="line">having max(amount)&gt; 500;  # amount&gt;500 报错，</span><br></pre></td></tr></table></figure><p>在 having ,select 的字段中，只能写 group by 分组的字段 + 聚合函数（其他字段）</p><p>不适用 order by ， 实现在 salaries 表 中找 第二大 的员工信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select b.emp_no, max(b.salary),  a.last_name, a.first_name</span><br><span class="line">from  employees a,  salaries b  on a.emp_no = b.emp_no</span><br><span class="line">where b.salary &lt; (select max(bb.salary) from salaries bb);</span><br></pre></td></tr></table></figure><p><strong>知识点：</strong><br>在 from 后边写 连接 left join,  right join ,  inner join;   通过 on  连接2个表的相连字段。<br>对所有员工的 薪水按照 salary降序进行 1-N的排名，要求相同 salary并列且按照 emp_no升序排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary, </span><br><span class="line">    (select  count(distinct salary) from salaries s2  where s1.salary&lt;=s2.salary )</span><br><span class="line">from salaries s1</span><br><span class="line">order by salary Desc, emp_no Asc;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL实践案例&quot;&gt;&lt;a href=&quot;#SQL实践案例&quot; class=&quot;headerlink&quot; title=&quot;SQL实践案例&quot;&gt;&lt;/a&gt;SQL实践案例&lt;/h1&gt;&lt;p&gt;查寻每个省份中，金额排 前三的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.si</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL语法</title>
    <link href="http://example.com/2022/03/14/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B1-SQL%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/03/14/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B1-SQL%E8%AF%AD%E6%B3%95/</id>
    <published>2022-03-14T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:31.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><p>本地启动： sudo  &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server start –skip-grant-tables<br>关闭： sudo pkill -9 mysql<br>登陆 docker 中的 mysql:  mysql -h  10.85.172.27 -P  4058  -u  rootName -p  passWord  cashier<br>忘记密码启动： 修改  mysql.user 表里面的password字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;  update mysql.user <span class="built_in">set</span> password=‘***<span class="string">&#x27;  where host=‘***&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; flush privileges;</span></span><br></pre></td></tr></table></figure><h4 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a><strong>数据库：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database **if not exists dbName character set utf8;**</span><br><span class="line">**show databases;**</span><br><span class="line">**drop database if exists dbName;**</span><br><span class="line">use dbName;</span><br><span class="line">select database();  -- 显示当前打开的数据库</span><br></pre></td></tr></table></figure><h4 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a><strong>创建表：</strong></h4><p>PRIMARY KEY:  主键约束</p><p>UNIQUE KEY:   唯一约束</p><p>NOT NULL:     非空约束</p><p>DEFAULT:      默认约束</p><p>FOREIGN KEY:  外键约束</p><p>主键可自动编号，则可加上 “AUTO_INCREMENT”</p><p>级联外键字段：</p><p>CASCADE：父表的删除、更新操作会使得子表中匹配的行也自动进行删除或更新；</p><p>SET NULL：父表的删除、更新操作会使得子表中的外键列为NULL，并且前提是外键列没有指定为NOT NULL；</p><p>RESTRICT：拒绝对父表的删除或更新操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists teacher(</span><br><span class="line">  id   **int primary key** unique key ,</span><br><span class="line">  name  varchar(20) not null ,</span><br><span class="line">  score  float(8,2) UNIQUE,</span><br><span class="line">  age   int not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">\# 子表</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">  id    SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username VARCHAR(10) NOT NULL,</span><br><span class="line">  pid    SMALLINT UNSIGNED, </span><br><span class="line">  FOREIGN KEY (pid) REFERENCES province (id)  /* 外键列，外键列和参照列必须具有相似的数据类型 */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE user3(</span><br><span class="line">  id     SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username  VARCHAR(10) NOT NULL,</span><br><span class="line">  pid     SMALLINT UNSIGNED,</span><br><span class="line">  FOREIGN KEY (pid) REFERENCES province (id) ON DELETE CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 外键</span><br><span class="line">create table province(</span><br><span class="line">  id   **SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,** </span><br><span class="line">  pname  VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line">**show columns** from teacher; -- 查看数据表结构</span><br></pre></td></tr></table></figure><h4 id="修改表属性："><a href="#修改表属性：" class="headerlink" title="修改表属性："></a><strong>修改表属性：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user3  add  age tinyint unsigned not null; -- 添加一列</span><br><span class="line">alter table teacher add  (class varchar(20),  address varchar(10) not null);  —- 添加多列</span><br><span class="line">alter table teacher drop class; -- 删除一列</span><br></pre></td></tr></table></figure><p><strong>– 添加约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table  teacher  add  unique(age);</span><br><span class="line">alter table  user3   add  foreign key(pid) references province(id);</span><br></pre></td></tr></table></figure><p><strong>– 删除约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3  drop primary key;</span><br></pre></td></tr></table></figure><p><strong>– 修改列定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3 modify id smallint unsigned not null first;</span><br></pre></td></tr></table></figure><p><strong>– 修改列名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3 change age userage tinyint unsigned;</span><br></pre></td></tr></table></figure><p><strong>– 修改表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3 rename as user33;</span><br></pre></td></tr></table></figure><p><strong>删除表：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table user;  </span><br></pre></td></tr></table></figure><p><strong>增删改：</strong></p><h4 id="增-删-改"><a href="#增-删-改" class="headerlink" title="增-删-改:"></a><strong>增-删-改:</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**insert into** teacher (id,name,score) values (0,&#x27;whq&#x27;,98.3241),(1,&#x27;wxb&#x27;,34.42);</span><br><span class="line"></span><br><span class="line">**delete from** teacher where id = 1;</span><br><span class="line"></span><br><span class="line">**update** teacher **set age=24** where name=&#x27;whq&#x27;;</span><br></pre></td></tr></table></figure><h4 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SELECT select_expr1[,select_expr2,...]</span><br><span class="line">[</span><br><span class="line">  FROM table_name</span><br><span class="line">  [WHERE   where_condition]</span><br><span class="line">  [GROUP BY  &#123;col_name | position&#125; [ASC | DESC],...]</span><br><span class="line">  [HAVING   where_condition]</span><br><span class="line">  [ORDER BY  &#123;col_name | expr | position&#125; [ASC | DESC],...]</span><br><span class="line">  [LIMIT   &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">select name, age</span><br><span class="line">from teacher</span><br><span class="line">group by age asc;</span><br><span class="line">select name, age</span><br><span class="line">from teacher</span><br><span class="line">group by age asc having age&gt;=10;</span><br><span class="line"></span><br><span class="line">/* 从查询结果中的第3行开始（从0开始计数），共返回4行 */</span><br><span class="line">SELECT name,age </span><br><span class="line">FROM teacher </span><br><span class="line">ORDER BY age ASC </span><br><span class="line">LIMIT 3,4;</span><br><span class="line"></span><br><span class="line">/* 子查询的结果作为上一层查询的条件。可使用IN()/NOT IN()、ANY()、SOME()、ALL()等操作符和比较运算符搭配使用。 */</span><br><span class="line">SELECT goods_id,goods_name,goods_price </span><br><span class="line">FROM tdb_goods </span><br><span class="line">WHERE goods_price &gt;= (SELECT AVG(goods_price) FROM tdb_goods);</span><br><span class="line"></span><br><span class="line">-- LEFT/RIGHT [OUTER] JOIN左外连接/右外连接</span><br><span class="line">SELECT goods_id, goods_name, cate_name </span><br><span class="line">FROM tdb_goods as tg **LEFT JOIN** tdb_goods_cates as tgc</span><br><span class="line">**ON tg.cate_id = tgc.cate_id;**</span><br></pre></td></tr></table></figure><h4 id="–-多表删除"><a href="#–-多表删除" class="headerlink" title="– 多表删除"></a>– 多表删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELETE t1 </span><br><span class="line">FROM tdb_goods AS t1 </span><br><span class="line">LEFT JOIN (SELECT goods_id,goods_name </span><br><span class="line">  FROM tdb_goods </span><br><span class="line">GROUP BY goods_name </span><br><span class="line">HAVING count(goods_name) &gt;= 2 ) AS t2 </span><br><span class="line">ON t1.goods_name = t2.goods_name </span><br><span class="line">WHERE t1.goods_id &gt; t2.goods_id;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数:"></a><strong>聚合函数:</strong></h3><ol><li><p>AVG()：求平均值；</p></li><li><p>COUNT()：计数；</p></li><li><p>MAX()：求最大值；</p></li><li><p>MIN()：求最小值；</p></li><li><p>SUM()：求和</p></li></ol><h3 id="数值运算："><a href="#数值运算：" class="headerlink" title="数值运算："></a><strong>数值运算：</strong></h3><ol><li>ceil(x)：返回大于 x的最小整数值；</li><li>div：整数除法，即结果中只保留整数部分；</li><li>floor(x)：返回小于 x的最大整数值；</li><li>mod：取余；</li><li>power(x, y)：幂运算，即 x的y次方；</li><li>round(x, y)：四舍五入，即将数值 x四舍五入为y位小数。</li><li>truncate(x, y)：数字截取，将数值 x保留y位小数（不进行四舍五入）</li></ol><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算:"></a><strong>比较运算:</strong></h3><ol><li>[NOT] BETWEEN…AND…：【不】在范围之内；</li><li>[NOT] IN()：【不】在列出值范围内；</li><li>IS [NOT] NULL：【非】空</li></ol><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数:"></a><strong>字符函数:</strong></h3><ol><li><p>CONCAT(  str1, str2, …)： 字符连接；</p></li><li><p>CONCAT_WS(separator, str1, str2, …)： 使用指定的分隔符进行字符连接；</p></li><li><p>FORMAT(x, d)： x为某数字，d为小数位；</p></li><li><p>LOWER(str)： 将字符串转化为小写字母；</p></li><li><p>UPPER(str)： 将字符串转化为大写字母；</p></li><li><p>LEFT(str, len)：  返回指定长度的字符串的左侧部分；</p></li><li><p>RIGHT(str, len)： 返回指定长度的字符串的右侧部分；</p></li><li><p>MID(str, pos[, len])： 返回str里从pos位置开始，长度为len的字符串部分；</p></li><li><p>SUBSTRING(str, pos, len)： 返回str里从pos位置开始，长度为len的字符串部分；</p></li><li><p>LENGTH(str)： 返回字符串str的长度，空格也会一起计算长度，以字节为单位；</p></li><li><p>LTRIM(str)： 删除前导空格；</p></li><li><p>RTRIM(str)： 删除后续空格；</p></li><li><p>TRIM([{BOTH | LEADING | TRAILING} [removed_str]] FROM str)： 删除前后缀不需要的字符；</p></li><li><p>[NOT]LIKE()： 与通配符一起使用选择数据。MySQL提供两个通配符（%和_），其中，“%”用于匹配任何字符串，“_”用于匹配任何单个字符。如果需要匹配的字符本身就是通配符，可使用ESCAPE；</p></li><li><p>REPLACE(str, old_str, new_str)：将str字符串里的old_str字符串部分替换为new_str；</p></li><li><p>LOCATE(substr,str)： 返回子符串substr在字符串str的第一个出现的位置；</p></li><li><p>LOCATE(substr,str,pos)：返回子符串substr在字符串str，从pos处开始的第一次出现的位置。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* LIKE()举例 */</span><br><span class="line">SELECT * FROM test WHERE first_name LIKE &#x27;%1%%&#x27; ESCAPE &#x27;1’;    --  不将“1”后的“%”认为是通配符 </span><br></pre></td></tr></table></figure><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数:"></a><strong>日期时间函数:</strong></h3><ol><li>NOW()： 当前日期和时间；</li><li>DATE(date)： 返回日期；</li><li>CURDATE()： 当前日期；</li><li>CURTIME()： 当前时间；</li><li>YEAR(date)： 返回date中的年份；</li><li>MONTH(date)： 返回date中的月份；</li><li>DAY(date)：    返回date的中的日；</li><li>DATE_ADD(date, INTERVAL expr type)：日期加减。type类型可以是DAY、WEEK、MONTH、YEAR等。例：SELECT DATE_ADD( ‘2017-11-20’, INTERVAL 2 DAY);</li><li>DATEDIFF()：返回两个日期之间的天数；</li><li>DATE_FORMAT( date, format)：日期时间格式化。例如%d、%m、%Y等</li></ol><h3 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数:"></a><strong>信息函数:</strong></h3><ol><li>CONNECTION_ID()：返回数据库的连接次数</li><li>DATABASE()：  当前数据库；</li><li>LAST_INSERT_ID()： 最后插入记录的id；</li><li>USER()： 当前用户；</li><li>VERSION()： 版本信息</li></ol><h3 id="加密函数："><a href="#加密函数：" class="headerlink" title="加密函数："></a><strong>加密函数：</strong></h3><ol><li>MD5()：信息摘要算法；</li><li>PASSWORD()：密码算法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL语法&quot;&gt;&lt;a href=&quot;#SQL语法&quot; class=&quot;headerlink&quot; title=&quot;SQL语法&quot;&gt;&lt;/a&gt;SQL语法&lt;/h1&gt;&lt;p&gt;本地启动： sudo  &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;mysql&amp;#x2F;support-f</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL扩展</title>
    <link href="http://example.com/2022/03/12/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A4-Mysql%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2022/03/12/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A4-Mysql%E6%89%A9%E5%B1%95/</id>
    <published>2022-03-12T13:55:36.000Z</published>
    <updated>2022-04-19T13:05:22.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL扩展"><a href="#MySQL扩展" class="headerlink" title="MySQL扩展"></a>MySQL扩展</h1><h3 id="Mysql-数据库连接池参数："><a href="#Mysql-数据库连接池参数：" class="headerlink" title="Mysql 数据库连接池参数："></a>Mysql 数据库连接池参数：</h3><p>user<br>password<br>characterEncoding  编码方式<br>autoReconnect：    当数据库连接异常中断时，是否自动重新连接？<br>maxReconnects：   autoReconnect设置为true时，重试连接的次数<br>connectTimeout：   和数据库服务器建立 socket连接时的超时，单位：毫秒。 0表示永不超时<br>allowMultiQueries： mysql驱动开启批量执行sql的开关</p><h3 id="Mysql-的参数："><a href="#Mysql-的参数：" class="headerlink" title="Mysql 的参数："></a>Mysql 的参数：</h3><p>max_connections&#x3D;3000:  MySql的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量<br>default-storage-engine:   MySQL的 默认存储引擎 </p><p>innodb_buffer_pool_size:  (默认128M) 存储页面缓存数据<br>innodb_change_buffer_max_size： changeBuffer缓存区,修改记录的<br>read_rnd_buffer_size : 随机读缓冲区大小  MRR 做随机IO时使用，这里会对主键进行排序<br>read_buffer_size : 读入缓冲区大小。对表进行 顺序扫描的请求将分配一个读入缓冲区<br>innodb_log_buffer_size :  事务日志所使用的缓冲区； redo_log日志需要先缓存，再刷盘</p><p>wait_timeout&#x3D;1800:  MySQL连接闲置 超过一定时间后将会被强行关闭<br>back_log&#x3D;500  : 连接数据达到 max_connections时，新来请求将会被存在堆栈中，等待某一连接释放资源，该堆栈数量即back_log<br>max_user_connections ： 同一个账号能够同时连接到mysql服务的最大连接数。设置为0表示不限制</p><h3 id="MySQL主机宕机后，如何恢复？"><a href="#MySQL主机宕机后，如何恢复？" class="headerlink" title="MySQL主机宕机后，如何恢复？"></a>MySQL主机宕机后，如何恢复？</h3><p>主库宕机：<br>1.确保所有从节点 relay log 全部更新完毕； 在每个从库上执行 show processlist 查看<br>2.登录所有 从节点，查看 master.info文件， 找 最大的  pos 节点作为新主库，数据最全<br>3.登录 pos 最大从节点，执行 stop slave;   删 relay-log.info 等从相关文件； 开启 bin-log 来记录sql 日志； 执行 reset master<br>4.创建用于 同步的用户并授权slave<br>5.登录其他从节点 ，执行 stop slave停止同步，再 执行 start slave ；<br>6.测试 新master 和 slave 数据是 否同步</p><h3 id="从库宕机："><a href="#从库宕机：" class="headerlink" title="从库宕机："></a>从库宕机：</h3><p>1)查看 从库上 mysql 的错误日志，里面有记录 主从挂掉时的binlog信息<br>2)有了 binlog和postion信息后，只需要 重新在 从库上进行change master to配置； 配置后开启slave 状态，没有报错<br>3)查看 slave状态，发现slave已经正常了，开始进行 延时数据恢复 </p><h3 id="MHA-多节点集群："><a href="#MHA-多节点集群：" class="headerlink" title="MHA+多节点集群："></a>MHA+多节点集群：</h3><p>MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master，整个故障转移过程对应用程序完全透明。<br>1）service mysql stop (关闭主库)<br>2）备库自动提升为主，IP地址同时漂移至备机<br>3）从库自动同步备库<br>修复原主库，将角色变为备，连接至现主库，三台主从又恢复了正常，重新建立MHA</p><h3 id="redo-log-与-binlog-区别："><a href="#redo-log-与-binlog-区别：" class="headerlink" title="redo log 与 binlog 区别："></a>redo log 与 binlog 区别：</h3><p>1）作用不同：<br>redo log是用于保证MySQL宕机也不会影响持久性；<br>binlog是用于 保证服务器可以 基于时间点恢复数据，此外 binlog还用于主从复制。<br>2）层次不同：<br>redo log是 InnoDB存储引擎实现的；<br>binlog 是MySQL的服务器层实现的，同时支持InnoDB和其他存储引擎。<br>3）内容不同：<br>redo log 是物理日志，内容基于磁盘的Page；<br>binlog 内容是二进制的，根据binlog_format参数的不同，可能基于 sql语句，基于数据本身或者二者的混合。<br>4）写入时机不同：<br>binlog在事务提交时写入；<br>redo log 写入时机相对多元：<br>** 当事务提交时会调用 fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。<br>** 除事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样好处是不一定要等到commit时刷盘，commit速度加快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL扩展&quot;&gt;&lt;a href=&quot;#MySQL扩展&quot; class=&quot;headerlink&quot; title=&quot;MySQL扩展&quot;&gt;&lt;/a&gt;MySQL扩展&lt;/h1&gt;&lt;h3 id=&quot;Mysql-数据库连接池参数：&quot;&gt;&lt;a href=&quot;#Mysql-数据库连接池参数：&quot; c</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
</feed>
