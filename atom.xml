<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TurboCome</title>
  
  <subtitle>Wang Hongqiang</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-04-20T01:57:52.664Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TurboCome</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组小和</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T01:57:52.664Z</updated>
    
    <content type="html"><![CDATA[<p>归并排序类型题（美团实习二面原题）</p><p>数组小和 定义如下：给定一个数组 s，实现 函数返回 s 的小和</p><p>例如： 数组s&#x3D;[1,3,5,2,4,6]</p><p>s[0] 左边 &lt; &#x3D; s[0]的数的和为0，</p><p>s[1]左边 &lt;&#x3D; s[1] 的数的和为1，</p><p>s[2]左边 &lt;&#x3D; s[2]的数的和为1+3&#x3D;4，</p><p>s[3]左边 &lt;&#x3D; s[3]的数的和为1，</p><p>s[4]左边 &lt;&#x3D; s[4]的数的和为1+3+2&#x3D;6，</p><p>s[5]左边 &lt;&#x3D; s[5]的数的和为1+3+5+2+4&#x3D;15，</p><p>所以s 小和为 0+1+4+1+6+15&#x3D;27 </p><p>In:  arr&#x3D;[1, 3, 5, 2, 4, 6]</p><p>Out:  27</p><p>要求：时间复杂度O( NlogN)，额外空间复杂度O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallSum2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="literal">null</span> || arr.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>); <span class="comment">//归并排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//归并排序的过程会进行拆组再合并，即：拆左组，拆右组，合并左右组</span></span><br><span class="line">    <span class="keyword">return</span> func(s,l,mid) +func(s, mid+<span class="number">1</span>,r) + merge(s, l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hi=<span class="number">0</span>; <span class="comment">// h 的首位</span></span><br><span class="line">    <span class="type">int</span> i= left; <span class="comment">// 左组首位</span></span><br><span class="line">    <span class="type">int</span> j= mid+<span class="number">1</span>; <span class="comment">// 右组首位</span></span><br><span class="line">    <span class="type">int</span> sum= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( i&lt;=mid &amp;&amp; j&lt;=right)&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( s[i]&lt;=s[j])&#123;</span><br><span class="line">            sum += s[i]*(right-j+<span class="number">1</span>);<span class="comment">//生成小和</span></span><br><span class="line">            h[hi++] =s[i++]; <span class="comment">//左组动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> h[hi++]=s[j++]; <span class="comment">//右组动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; (j&lt;right+<span class="number">1</span>)||(i&lt;mid+<span class="number">1</span>); j++,i++)&#123;</span><br><span class="line">        h[hi++]= i&gt;mid? s[j]:s[i]; <span class="comment">//左右组合成h</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k!=h.length; k++) s[left++]=h[k];  <span class="comment">// 合成s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;归并排序类型题（美团实习二面原题）&lt;/p&gt;
&lt;p&gt;数组小和 定义如下：给定一个数组 s，实现 函数返回 s 的小和&lt;/p&gt;
&lt;p&gt;例如： 数组s&amp;#x3D;[1,3,5,2,4,6]&lt;/p&gt;
&lt;p&gt;s[0] 左边 &amp;lt; &amp;#x3D; s[0]的数的和为0，&lt;/p&gt;
&lt;p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>01背包--目标和_494</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.0-1%E8%83%8C%E5%8C%85-%E7%9B%AE%E6%A0%87%E5%92%8C_494/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.0-1%E8%83%8C%E5%8C%85-%E7%9B%AE%E6%A0%87%E5%92%8C_494/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:56:51.054Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个非负整数数组 { a1, a2, …, an } 和一个目标数 S,  现有两个符号 + 和 - , 对于数组中的任意一个整数，可以从 + 或 - 中选择一个符号添加在前面。返回可以使最终数组和 为目标数 S 的所有 添加符号的方法数</p><p>输入：nums: [1, 1, 1, 1, 1],    S: 3  ； 不一定都是 1<br>输出：5<br>解释：<br>    -1+1+1+1+1 &#x3D; 3<br>    +1-1+1+1+1 &#x3D; 3<br>    +1+1-1+1+1 &#x3D; 3<br>    +1+1+1-1+1 &#x3D; 3<br>    +1+1+1+1-1 &#x3D; 3<br>一共有5种方法让最终目标和为 3</p><p>思路：<br>换种理解方式：就是从数组中挑出一部分数，作为正数，其余数为负，使其加和为S的所有方案<br>关键是这个选出哪些数作为正数呢？<br>设选出 正数的所有数求和 x ， 选出负数的所有数求和 y （不计符号）<br>x + y &#x3D; sum (  数组中所有元素和 )<br>x - y &#x3D; S<br>x &#x3D; (sum + S ) &#x2F; 2<br>之后此题便转化为一个 0-1背包问题； 即：装满背包容量X 的条件下，有多少种方案</p><p>设 dp(i)(j)表示在 数组中元素个数为 i 的条件下，背包容量为 j  的所有方案<br>第 i 个元素 有 2中可能 &#x3D; 不选 + 选<br>dp(i)(j)&#x3D;dp(i-1)(j)+dp(i-1)(j-nums[i])</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: nums) sum +=v;</span><br><span class="line">    <span class="keyword">if</span>( (sum+S)%<span class="number">2</span>!=<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> (sum+S)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>][ W+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&lt; nums[i-<span class="number">1</span>]) dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个非负整数数组 { a1, a2, …, an } 和一个目标数 S,  现有两个符号 + 和 - , 对于数组中的任意一个整数，可以从 + 或 - 中选择一个符号添加在前面。返回可以使最终数组和 为目标数 S 的所有 添加符号的方法数&lt;/p&gt;
&lt;p&gt;输入：nums:</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="动态规划" scheme="http://example.com/categories/LeetCode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    
    <category term="动态规划" scheme="http://example.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 57 - II.和为s的连续正数序列</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:19:31.787Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个 正整数 target ，输出 <strong>所有和为 target</strong> 的 连续 **<em>*正整数序列*<em>（至少含有两个数）</em></em></p><p>序列内的 数字由小到大排列，不同序列按照首个数字从小到大排列</p><p>输入：target &#x3D; 9</p><p>输出：[[2,3,4],[4,5]]</p><p>输入：target &#x3D; 15</p><p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p><p>思路：</p><p>当窗口的和 &lt; target 时:  右边界向右移动 ，增加</p><p>当窗口的和 &gt; target 时:  左边界向右移动 ，减少</p><p>当窗口的和 &#x3D;&#x3D; target 时， 记录结果</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fypl95qcj213e0qcjuc.jpg" alt="76F3FB9B-80E0-4AA1-AEB9-0E0C15368462" width="650" height="400" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findContinuousSequence</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    List&lt; List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= target/<span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">            sum+=r;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            sum-=l;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k=l; k&lt;r; k++) tmp.add(k);</span><br><span class="line">           res.add(tmp);</span><br><span class="line">            <span class="comment">// 左边界继续右移，仍要继续前进</span></span><br><span class="line">            sum-=l; </span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入一个 正整数 target ，输出 &lt;strong&gt;所有和为 target&lt;/strong&gt; 的 连续 **&lt;em&gt;*正整数序列*&lt;em&gt;（至少含有两个数）&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;序列内的 数字由小到大排列，不同序列按照首个数字从小到大排列&lt;/p&gt;
&lt;p&gt;输</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="滑动窗口" scheme="http://example.com/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>最小覆盖子串_76</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_76/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_76/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:25:56.856Z</updated>
    
    <content type="html"><![CDATA[<p>一个字符串 s , 一个字符串  t ， 返回 s 中 涵盖 t 所有字符的最小子串?</p><p>如果 s 中  不存在涵盖 t 所有字符的子串，则返回空字符串 “” </p><p>注意：如果 s 中存在这样的子串，保证它是唯一的答案。</p><p>输入：s &#x3D; “ADOBECODEBANC”,  t &#x3D; “ABC”</p><p>输出：”BANC”</p><p>输入：s &#x3D; “a”,  t &#x3D; “a”</p><p>输出：”a”</p><p>提示：</p><p>1 &lt;&#x3D; s.length,  t.length &lt;&#x3D; 105</p><p>s 和 t 由英文字母组成  </p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>左右指针，依次截取判断是否包含。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( s.length() &lt; t.length() ) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map_test = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: t.toCharArray()) map_test.put( c, map_test.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, len=Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt; s.length(); r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">         <span class="comment">// 包括的话，就添加进来</span></span><br><span class="line">        <span class="keyword">if</span>( map_test.containsKey(c)) map.put(c, map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l&lt;=r &amp;&amp; check(map_test, map) )&#123;</span><br><span class="line">            <span class="keyword">if</span>(len&gt; r-l+<span class="number">1</span>)&#123;</span><br><span class="line">                res= s.substring(l, r+<span class="number">1</span>);</span><br><span class="line">                len = r-l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 内部缩减， 左指针前移</span></span><br><span class="line">            <span class="keyword">if</span>(map_test.containsKey(s.charAt(l)))</span><br><span class="line">                map.put(s.charAt(l), map.getOrDefault( s.charAt(l),<span class="number">0</span>)-<span class="number">1</span> );</span><br><span class="line">            l++;  <span class="comment">// 可以考虑使用 map&lt;v, id&gt; 优化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Map&lt;Character, Integer&gt; map_test, Map&lt;Character, Integer&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( Map.Entry&lt;Character,Integer&gt; it: map_test.entrySet())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> it.getKey();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> it.getValue();</span><br><span class="line">        <span class="keyword">if</span>(map.getOrDefault(key, <span class="number">0</span>)&lt; value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个字符串 s , 一个字符串  t ， 返回 s 中 涵盖 t 所有字符的最小子串?&lt;/p&gt;
&lt;p&gt;如果 s 中  不存在涵盖 t 所有字符的子串，则返回空字符串 “” &lt;/p&gt;
&lt;p&gt;注意：如果 s 中存在这样的子串，保证它是唯一的答案。&lt;/p&gt;
&lt;p&gt;输入：s &amp;#x</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="滑动窗口" scheme="http://example.com/categories/LeetCode/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    
    <category term="滑动窗口" scheme="http://example.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
  </entry>
  
  <entry>
    <title>二叉树路径总和-112-113-437</title>
    <link href="http://example.com/2022/04/20/Y-LeetCode/C-%E9%80%92%E5%BD%92/2.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C_112_113_437/"/>
    <id>http://example.com/2022/04/20/Y-LeetCode/C-%E9%80%92%E5%BD%92/2.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C_112_113_437/</id>
    <published>2022-04-20T01:55:19.000Z</published>
    <updated>2022-04-20T02:36:36.822Z</updated>
    
    <content type="html"><![CDATA[<ol start="112"><li></li></ol><p>给定一个二叉树和一个 <strong>目标和</strong>，判断该树中 <strong>是否存在 根节点到叶子节点的路径</strong>，这条路径上所有节点值 <strong>相加等于目标和</strong><br>说明: 叶子节点是指没有 子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><p>​         5</p><p>​        &#x2F;  \</p><p>​       4    8</p><p>​      &#x2F;    &#x2F;  \</p><p>​     11   13  4</p><p>​     &#x2F; \   \</p><p>​    7  2    1</p><p>{5,4,8,11,null, 13, 4, 7, 2, null, 1}</p><p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径  5-&gt;4-&gt;11-&gt;2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span> &amp;&amp; sum-root.val==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="113"><li></li></ol><p>给定一个二叉树和一个目标和，找到所有从 根节点到 <strong>叶子节点路径总和 &#x3D;&#x3D;给定目标和的路径</strong><br>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p><p>​            5<br>​         &#x2F;     <br>​        4       8<br>​       &#x2F;  \     &#x2F;  \<br>​      11   N    13   4<br>​     &#x2F; \  &#x2F; \   &#x2F;\   &#x2F;<br>​    7   2 N N  N  N 5  1</p><p>{5,4,8, 11, null, 13, 4, 7,2, null, null,null, null, 5,1}</p><p>返回:</p><p>[</p><p>  [5,4,11,2],</p><p>  [5,8,4,5]</p><p>]</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    pathSum(root, sum, item);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    item.add(root.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span> &amp;&amp; sum-root.val==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>(item) );  <span class="comment">// 一定要重新赋值，注意深浅copy</span></span><br><span class="line">      <span class="comment">//此处不要 return; 会导致item中末尾节点没有删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处 不能放在 else 中，否则在 添加满足条件后，无法将最后一个元素删除： 回溯</span></span><br><span class="line">    pathSum(root.left, sum-root.val, item);</span><br><span class="line">    pathSum(root.right, sum-root.val, item);</span><br><span class="line">   item.remove(item.size()-<span class="number">1</span>);  <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>437.链接：<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a><br>二叉树的每个结点都存放着一个整数值, 找出 路径和 等于 给定数值的路径总数<br>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p><p>root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1] , sum &#x3D; 8</p><pre><code>         10       /    \     5      -3   /  \     / \  3    2   N   11 / \      / \3  -2    N   1</code></pre><p>{10,5,-3,3,2,null,11,3,-2,null,1} </p><p>返回 3<br>和等于 8 的路径有:</p><ol><li>5 -&gt; 3</li><li>5 -&gt; 2 -&gt; 1</li><li>-3 -&gt; 11</li></ol><p>思路：<br>1.以当前节点为起始，dfs深搜遍历左右几点，找到所有sum&#x3D;target<br>2.递归遍历root.left ; root.right</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root, sum); <span class="comment">//加入 root 节点</span></span><br><span class="line">    <span class="comment">// 不加入root 节点</span></span><br><span class="line">    pathSum(root.left, sum);</span><br><span class="line">    pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(sum-root.val==<span class="number">0</span>) res++;</span><br><span class="line">    dfs(root.left, sum-root.val);</span><br><span class="line">    dfs(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;ol start=&quot;112&quot;&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;给定一个二叉树和一个 &lt;strong&gt;目标和&lt;/strong&gt;，判断该树中 &lt;strong&gt;是否存在 根节点到叶子节点的路径&lt;/strong&gt;，这条路径上所有节点值 &lt;strong&gt;相加等于目标和&lt;/stro</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="递归" scheme="http://example.com/categories/LeetCode/%E9%80%92%E5%BD%92/"/>
    
    
    <category term="递归" scheme="http://example.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
  <entry>
    <title>防止怠慢，经常自勉</title>
    <link href="http://example.com/2022/04/19/Z-%E9%9A%8F%E7%AC%94/%E8%87%AA%E5%8B%89/"/>
    <id>http://example.com/2022/04/19/Z-%E9%9A%8F%E7%AC%94/%E8%87%AA%E5%8B%89/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-19T13:31:01.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="防止怠慢，经常自勉"><a href="#防止怠慢，经常自勉" class="headerlink" title="防止怠慢，经常自勉"></a>防止怠慢，经常自勉</h1><ol><li><h4 id="不受些挫，永远不知道自己有多差劲！"><a href="#不受些挫，永远不知道自己有多差劲！" class="headerlink" title="不受些挫，永远不知道自己有多差劲！"></a>不受些挫，永远不知道自己有多差劲！</h4></li><li><h4 id="你已不再年轻，请别把自己当作一个孩子了！"><a href="#你已不再年轻，请别把自己当作一个孩子了！" class="headerlink" title="你已不再年轻，请别把自己当作一个孩子了！"></a>你已不再年轻，请别把自己当作一个孩子了！</h4></li><li><h4 id="做什么事情，请用心去做，不是什么事都那么随便就可以成功的！"><a href="#做什么事情，请用心去做，不是什么事都那么随便就可以成功的！" class="headerlink" title="做什么事情，请用心去做，不是什么事都那么随便就可以成功的！"></a>做什么事情，请用心去做，不是什么事都那么随便就可以成功的！</h4></li><li><h4 id="以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！"><a href="#以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！" class="headerlink" title="以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！"></a>以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！</h4></li><li><h4 id="这一路走来容易么？你经历了什么？你得到了什么？你想要什么？"><a href="#这一路走来容易么？你经历了什么？你得到了什么？你想要什么？" class="headerlink" title="这一路走来容易么？你经历了什么？你得到了什么？你想要什么？"></a>这一路走来容易么？你经历了什么？你得到了什么？你想要什么？</h4></li><li><h4 id="不要那么鲁莽，生活终究会为你的粗心而付出代价！"><a href="#不要那么鲁莽，生活终究会为你的粗心而付出代价！" class="headerlink" title="不要那么鲁莽，生活终究会为你的粗心而付出代价！"></a>不要那么鲁莽，生活终究会为你的粗心而付出代价！</h4></li><li><h4 id="有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！"><a href="#有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！" class="headerlink" title="有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！"></a>有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！</h4></li><li><h4 id="平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？"><a href="#平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？" class="headerlink" title="平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？"></a>平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？</h4></li><li><h4 id="要有自己的梦想，你的潜力不止于此！"><a href="#要有自己的梦想，你的潜力不止于此！" class="headerlink" title="要有自己的梦想，你的潜力不止于此！"></a>要有自己的梦想，你的潜力不止于此！</h4></li><li><h4 id="抱怨没有任何意义，那是曾经！我要的是未来！"><a href="#抱怨没有任何意义，那是曾经！我要的是未来！" class="headerlink" title="抱怨没有任何意义，那是曾经！我要的是未来！"></a>抱怨没有任何意义，那是曾经！我要的是未来！</h4></li><li><h4 id="经常总结经验，失败并不可怕，但一定要有所成长！"><a href="#经常总结经验，失败并不可怕，但一定要有所成长！" class="headerlink" title="经常总结经验，失败并不可怕，但一定要有所成长！"></a>经常总结经验，失败并不可怕，但一定要有所成长！</h4></li><li><h4 id="今天的怠慢在以后一定会让你加倍偿还！"><a href="#今天的怠慢在以后一定会让你加倍偿还！" class="headerlink" title="今天的怠慢在以后一定会让你加倍偿还！"></a>今天的怠慢在以后一定会让你加倍偿还！</h4></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;防止怠慢，经常自勉&quot;&gt;&lt;a href=&quot;#防止怠慢，经常自勉&quot; class=&quot;headerlink&quot; title=&quot;防止怠慢，经常自勉&quot;&gt;&lt;/a&gt;防止怠慢，经常自勉&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;h4 id=&quot;不受些挫，永远不知道自己有多差劲！&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>快速排序</title>
    <link href="http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-20T01:56:34.456Z</updated>
    
    <content type="html"><![CDATA[<p>思路： </p><p>取第一个元素，右–&gt;左：直到碰到&lt; 赋值给左； 再 左–&gt;右：直到碰到&gt; 赋值给右；</p><p>一次遍历完划分左右 2部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;   <span class="comment">// 终止条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不对数组进行截取时，要定义 起止下标</span></span><br><span class="line">    <span class="type">int</span> high=r, low=l;       </span><br><span class="line">    <span class="type">int</span> base=nums[l];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; base&lt;=nums[r]) r--;</span><br><span class="line">        nums[l]=nums[r];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; base&gt;nums[l]) l++;</span><br><span class="line">        nums[r]=nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l]=base;</span><br><span class="line">    <span class="comment">// 分支递归</span></span><br><span class="line">    quick_sort(nums,low,l-<span class="number">1</span>);</span><br><span class="line">    quick_sort(nums,l+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;思路： &lt;/p&gt;
&lt;p&gt;取第一个元素，右–&amp;gt;左：直到碰到&amp;lt; 赋值给左； 再 左–&amp;gt;右：直到碰到&amp;gt; 赋值给右；&lt;/p&gt;
&lt;p&gt;一次遍历完划分左右 2部分&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆排序算法</title>
    <link href="http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
    <id>http://example.com/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.%E5%A0%86%E6%8E%92%E5%BA%8F/</id>
    <published>2022-04-19T13:55:19.000Z</published>
    <updated>2022-04-19T13:50:44.370Z</updated>
    
    <content type="html"><![CDATA[<h3 id="堆排序算法："><a href="#堆排序算法：" class="headerlink" title="堆排序算法："></a>堆排序算法：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[] ,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 i 作为节点时， 进行的左 右子树的调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l= <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r= <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l&lt;len &amp;&amp; arr[base]&lt;arr[l]) base=l;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;len &amp;&amp; arr[base]&lt;arr[r]) base=r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(base!= i)&#123;</span><br><span class="line">        swap(arr, i, base);</span><br><span class="line">        heapify(arr, base, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heap_sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="type">int</span> len=arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (len-<span class="number">1</span>)/<span class="number">2</span>;   <span class="comment">//最后一个节点的父节点</span></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(arr,<span class="number">0</span>, i);</span><br><span class="line">        heapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类型题：</p><p>查找第K大的数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find_K_nums</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="type">int</span> parent=(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(nums, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;len-K; i--)&#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, i);</span><br><span class="line">        heapify(nums, <span class="number">0</span>, i);</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;堆排序算法：&quot;&gt;&lt;a href=&quot;#堆排序算法：&quot; class=&quot;headerlink&quot; title=&quot;堆排序算法：&quot;&gt;&lt;/a&gt;堆排序算法：&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="排序" scheme="http://example.com/categories/LeetCode/%E6%8E%92%E5%BA%8F/"/>
    
    
    <category term="排序算法" scheme="http://example.com/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL优化实践</title>
    <link href="http://example.com/2022/04/13/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A5-MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://example.com/2022/04/13/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A5-MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</id>
    <published>2022-04-13T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:26.808Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL优化实践"><a href="#MySQL优化实践" class="headerlink" title="MySQL优化实践"></a>MySQL优化实践</h1><h3 id="1-大数据量拆分："><a href="#1-大数据量拆分：" class="headerlink" title="1.大数据量拆分："></a>1.大数据量拆分：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update coupons </span><br><span class="line">set status = 1 </span><br><span class="line">where status= 0 and create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59&#x27;;</span><br></pre></td></tr></table></figure><p>问题： 一个 SQL只能使用一个 cpu core去处理，如果 SQL很复杂或执行很慢，就会阻塞后面的 SQL请求，造成活动连接数暴增，MySQL CPU 100%，相应的接口Timeout，同时对于主从复制架构，做了业务读写分离，更新500w数据需要5分钟，Master上执行了5分钟，binlog传到了slave也需要执行5分钟，那就是Slave延迟5分钟，在这期间会造成 业务脏数据，比如重复下单等。<br>1.先获取 where 条件中的 最小id  ，最大id，<br>2.然后 分批次去更新，每个批次 1000条，这样既能快速完成更新，又能保证 主从复制不会出现延迟</p><p>先获取要更新的 数据范围内的 最小id和最大id（表没有物理delete，所以id是连续的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select min(id) min_id, max(id) max_id from coupons </span><br><span class="line">where status=0 </span><br><span class="line">and create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59’; </span><br><span class="line"></span><br><span class="line">current_id = min_id;</span><br><span class="line">for current_id &lt; max_id do</span><br><span class="line">    update coupons set status=1 </span><br><span class="line">    where id&gt;= current_id and id&lt;= current_id + 1000;    //通过主键id更新1000条很快</span><br><span class="line">commit;</span><br><span class="line">current_id += 1000;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>充分利用 辅助索引包含主键id的特性，先通过索引获取主键 id走覆盖索引扫描，不需要回表，然后再通过id去关联操作是高效的，同时根据 MySQL的特性 使用分而治之的思想既能高效完成操作，又能避免主从复制延迟产生的业务数据混乱。</p><h3 id="2-分解多表连接："><a href="#2-分解多表连接：" class="headerlink" title="2.分解多表连接："></a>2.分解多表连接：</h3><p>例如，使用 IN() 代替连接查询（in 等价于等值查询）可排序，让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">    JOIN tag_post ON tag_post.tag_id= tag.id</span><br><span class="line">    JOIN post ON tag_post.post_id= post.id</span><br><span class="line">    WHERE tag.tag=&#x27;mysql’;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;           --&gt; tag_id = 1234</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;      —&gt; (123,456,567,9098,8904)</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure><h3 id="3-MRR优化："><a href="#3-MRR优化：" class="headerlink" title="3.MRR优化："></a>3.MRR优化：</h3><p><strong>应用实例一：</strong>（mysql优化器改变where 条件顺序—&gt;匹配联合索引） </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM t WHERE key_part1&gt;=1000 and key_part1&lt;2000 AND key_part2=1000;</span><br></pre></td></tr></table></figure><p>表 t 有 ( key_part1,  key_part2 ) 的联合索引 ，因此索引根据 key_part1,  key_part2 的位置关系进行排序。<br>没有MRR：SQL优化器会先将 key_part1&gt;1000 and key_part2&lt;2000 的数据查询出来，待取出的数据后，再根据key_part2的条件进行过滤。这会导致无用的数据被取出，如果有大量的数据是 key_part2 !&#x3D;1000，则启用MRR优化会使性能有巨大的提升.<br>启用MRR优化：优化器会先 将查询条件进行拆分，然后在进行数据查询。优化器会将查询条件拆分为(1000,1000),(1001,1000),(1002,1000),…,(1999,1000)，然后在根据这些拆分出的条件，使用索引下推进行数据查询，避免回表。</p><h4 id="应用实例二："><a href="#应用实例二：" class="headerlink" title="应用实例二："></a><strong>应用实例二：</strong></h4><p> 在没有MRR之前,或没有开启 MRR特性时，MySQL 针对基于辅助索引的查询策略是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select non_key_column </span><br><span class="line">from tb where key_column=x;</span><br></pre></td></tr></table></figure><p>MySQL 执行查询的伪代码<br>第一步 先根据 where 条件中的 辅助索引，获取辅助索引与主键的集合，结果集为 rest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select key_column, pk_column from tb </span><br><span class="line">where key_column=x order by key_column </span><br></pre></td></tr></table></figure><p>第二步 通过第一步获取的主键来获取 对应的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for each pk_column value in rest do:</span><br><span class="line">select non_key_column from tb where pk_column=val</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryagegrej60ko0im3zx02.jpg" alt="71AD8A06-C4D7-4035-A63F-E0978354FC50" width="450" height="350"/><p>由于MySQL存储数据的方式： 辅助索引的存储顺序并非与主键的顺序一致，从图中可以看出,根据辅助索引获取的主键来访问表中的数据会导致随机的IO . 不同主键不在同一个page 里面时必然导致多次IO 和随机读。<br>在使用 MRR优化特性的情况下，MySQL 针对基于辅助索引的查询策略是这样的：<br>第一步 先根据 where条件中的辅助索引获取辅助索引与主键的集合，结果集为rest</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select key_column, pk_column from tb where key_column = x order by key_column </span><br></pre></td></tr></table></figure><p>第二步 将结果集rest 放在buffer里面(read_rnd_buffer_size 大小直到buffer满了)，然后对结果集 rest按照pk_column排序，得到结果集是rest_sort<br>第三步 利用已经排序过的结果集，访问表中的数据，此时是顺序IO.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select non_key_column fromtb where pk_column in ( rest_sort )</span><br></pre></td></tr></table></figure><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryaq9apaj60y80hkwge02.jpg" alt="863DB3B3-6049-45F0-B0DC-16D319E21722" width="650" height="350"/><p>​    从图示MRR原理，MySQL 将根据 辅助索引获取的结果集根据主键进行排序，将乱序化为有序，可以用-主键顺序访问基表，将随机读转化为顺序读，多页数据记录可一次性读入或 根据此次的主键范围分次读入，以减少IO操作，提高查询效率。<br>MRR的使用与否，是由 MySQL中的开关控制，只要设置开启，它会自动在 read_rnd_buffer_size 缓冲区 内，对primaryKey进行排序。但这个开关并不是一直开着，因为对于 大多数的单条查询，重新在中间添加一步排序，是对性能的损失，没有必要。所以Mysql 中还有一个 mrr_cost_based 开关，如果设置关闭，则完全按照 mrr 开关来执行了；如果设为开启，MySQL的优化器会通过 CBO算法确定是否开启MRR特性（进行对 primaryKey的排序）<br>​    mrr&#x3D;{on|off}<br>​    mrr_cost_based&#x3D;{on|off}</p><h3 id="4-大数据量下分页查询-limit-offset-batchSize"><a href="#4-大数据量下分页查询-limit-offset-batchSize" class="headerlink" title="4.大数据量下分页查询 limit offset, batchSize:"></a>4.大数据量下分页查询 limit offset, batchSize:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select  * from trade_info </span><br><span class="line">where status = 0 and </span><br><span class="line">create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59’ </span><br><span class="line">order by id desc </span><br><span class="line">limit 102120, 20;</span><br></pre></td></tr></table></figure><p>表 trade_info 上有索引 idx_status_create_time(status, create_time); 等价于索引（status, create_time,id)<br>对于典型的 分页 limit m, n来说，越往后翻页越慢( m越大会越慢);  因为要 定位 m位置需要扫描的数据越来越多，导致IO开销比较大。这里可以利用 辅助索引的覆盖扫描来进行优化，先获取id，这一步就是 索引覆盖扫描，不需要回表，然后通过 id 跟原表 trade_info进行关联<br>&#x2F;&#x2F; 改写后的SQL如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select * </span><br><span class="line">from trade_info a , </span><br><span class="line">   (select id from trade_info </span><br><span class="line">    where status = 0 </span><br><span class="line">    and create_time &gt;=&#x27;2020-10-01 00:00:00&#x27; and create_time &lt;=&#x27;2020-10-07 23:59:59’ </span><br><span class="line">    order by id desc limit 102120, 20)  as b    -- 这一步走的是索引覆盖扫描，不需要回表</span><br><span class="line"> where a.id = b.id;</span><br></pre></td></tr></table></figure><p><strong>问题：</strong> 分页查询时，MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，而且在取offset+N 行数据时，因为是select * … 的操作，所以是需要回表的，查询到索引叶子节点数据，根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值。<br>那当 offset 特别大的时候，此时使用 limit m,n 效率就非常的低下，因为回表了 M 行无用的数据，并且占用了大量的 buffer pool 缓存。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>1.控制返回的总页数；<br>2.对超过特定阈值的页数进行 SQL 改写<br>SELECT a.* FROM USER a  INNER JOIN  (SELECT id  FROM USER WHERE age &#x3D; 10 LIMIT 100000,10) b  ON a.id &#x3D; b.id;  结果0.53s<br>需要对 where条件增加索引，id 因为是主键自带索引，select返回减少回表可以提升查询性能, 所以采用查询主键字段后进行关联大幅度提升了查询效率。<br>3.使用Redis 来保存lastMaxtId, 下一次分页查询时直接拼接在 where 条件后边，直接跨过 offset 行数据。</p><h3 id="常见慢查询问题："><a href="#常见慢查询问题：" class="headerlink" title="常见慢查询问题："></a>常见慢查询问题：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryax8sv9j61860oan1002.jpg" alt="14B56083-7EBD-4768-AD40-E3C00DFA418D" width="850" height="500" /><p>1.确定主键，索引字段，将它们作为查询条件<br>2.数据量过大，使用 limit 做分页处理，  limit  起始id, 条数count<br>3.当 limit 起始行数很大时， 查询效率会降低， 可以考虑使用自增 id </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Select *. From table limit  150000 , 5000</span><br><span class="line"></span><br><span class="line">优化： Select * from table where id&gt;150000 and id&lt;200000;  -- 速度会有提升</span><br></pre></td></tr></table></figure><p>4.数据导入，可尝试批量导入数据 ；<br><strong>性能：Load  &gt; insert.</strong><br>load 只操作一次，之后数据 批量插入<br>insert 每个数据操作一次，’就要遍历 一次字段索引</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL优化实践&quot;&gt;&lt;a href=&quot;#MySQL优化实践&quot; class=&quot;headerlink&quot; title=&quot;MySQL优化实践&quot;&gt;&lt;/a&gt;MySQL优化实践&lt;/h1&gt;&lt;h3 id=&quot;1-大数据量拆分：&quot;&gt;&lt;a href=&quot;#1-大数据量拆分：&quot; class</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>TCP/UDP/Http</title>
    <link href="http://example.com/2022/04/10/E-%E7%BD%91%E7%BB%9C/2.TCP-UDP-Http%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>http://example.com/2022/04/10/E-%E7%BD%91%E7%BB%9C/2.TCP-UDP-Http%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-04-10T13:55:19.000Z</published>
    <updated>2022-04-19T13:04:25.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TCP-x2F-UDP-x2F-Http"><a href="#TCP-x2F-UDP-x2F-Http" class="headerlink" title="TCP&#x2F;UDP&#x2F;Http"></a>TCP&#x2F;UDP&#x2F;Http</h1><h3 id="http-中的长，短链接："><a href="#http-中的长，短链接：" class="headerlink" title="http 中的长，短链接："></a>http 中的长，短链接：</h3><p>​    在 HTTP&#x2F;1.0中 默认短连接，客户端和 服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就 中断连接。当客户端浏览器访问某个Web页中包含有其他的 Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>​    从HTTP&#x2F;1.1起，默认长连接，用以 保持连接特性。使用长连接的 HTTP协议，会在 响应头加入这行代码：Connection:keep-alive；<br>使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间 用于传输 HTTP数据的 TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，有一个保持时间，可以设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p>HTTP 协议的长，短连接，实质上是 TCP协议的长，短连接。<br><strong>http 长连接：</strong>设置 connection 为 keep-alive ；在 header 中有个超时时间，超过此时间就断开长连接<br>长连接： 多个 http 请求复用同一个 TCP ； 频繁通信<br>短链接： 一个 http 用一个 TCP；  长时间不通信，创建，关闭都会浪费时间</p><p>长优点： 省去较多的 TCP建立和关闭操作，减少浪费，节约时间，对于 频繁请求资源的客户端较适合<br>短优点： 管理起来简单，存在的连接都是有用的连接，不需要额外的控制手段 </p><p>像 Web 网站的 http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 web网站有大量的客户端连接 用 短连接会省一些资源，如果用长连接，同时有成千上万的用户，每个 用户都占用一个连接的话，并发量很大，资源消耗很大； 而且每个用户无需频繁操作。</p><h3 id="浏览器中输入一个网址-url，执行过程："><a href="#浏览器中输入一个网址-url，执行过程：" class="headerlink" title="浏览器中输入一个网址 url，执行过程："></a>浏览器中输入一个网址 url，执行过程：</h3><p>1.应用层：浏览器看是否有缓存（浏览器，本地）; 没有则通过 DNS 解析，将 域名 转成其所对应的 服务器 ip地址，确定从浏览器到服务器的一条路径<br>2.传输层：将 http 会话通过 TCP 协议封装成数据包，在 源，目的端添加 对应的端口号, 来保证端到端的可靠传输<br>3.网络层：通过 IP 协议，查找 路由表，确定如何路由线路，到达服务器<br>4.数据链路层： 通过 邻居发现协议 ND， 查找到 给定 IP 地址的 mac 地址，发送 ARP 请求查找目的地址<br>5.物理层：将 ip 数据包转换成比特流，在物理链路上传输</p><h3 id="Web-页面请求过程："><a href="#Web-页面请求过程：" class="headerlink" title="Web 页面请求过程："></a>Web 页面请求过程：</h3><p>1.浏览器进行DNS域名解析，得到对应的IP地址<br>2.根据这个IP，找到对应的服务器，建立连接（三次握手）<br>3.建立TCP连接后发起 HTTP请求（一个完整的 http请求报文）<br>4.服务器响应HTTP请求，浏览器得到 html代码（服务器如何响应）<br>5.浏览器解析 html代码，并请求 html代码中的资源（如js，css，图片等）<br>6.浏览器对页面进行渲染呈现给用户<br>7.服务器关闭 TCP连接（四次挥手）</p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>1.首先会搜索浏览器自身的 DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p><p>2.如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p><p>3.如果还没有找到，那么尝试从 hosts文件里面去找</p><p>4.在前面三个过程都没获取到的情况下，浏览器会发起一个DNS的系统调用，向本地配置的首选DNS服务器（一般是电信运营商提供）发起域名解析请求（通过 UDP协议向 DNS的 53端口发起请求，这个请求是递归的，就是要求运营商的DNS服务器必须提供给我们该域名的IP地址）<br>DNS优化两个方面： DNS缓存, DNS负载均衡</p><h3 id="TCP-与-UDP-区别："><a href="#TCP-与-UDP-区别：" class="headerlink" title="TCP 与 UDP 区别："></a>TCP 与 UDP 区别：</h3><p>1.基于 TCP有连接； UDP 无连接；<br>2.TCP数据正确性，可靠传输，无差错，不丢失，不重复，且按序到达；<br>   UDP可能丢包，不可靠传输，UDP 尽最大努力交付，即不保   证可靠交付<br>   UDP没有拥塞控制，因此网络出现 拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>3.UDP 程序结构较简单，速度快，适合传输大数据； TCP 速度慢，适合小数据传输<br>4.TCP面向字节流;  UDP是面向报文的<br>5.每一条 TCP连接只能是点到点的;  UDP支持一对一，一对多，多对一和多对多的交互通信<br>6.TCP首部开销 20字节;  UDP的首部开销 8个字节<br>7.TCP通信 信道是 全双工的可靠信道，UDP则是 不可靠信道</p><h3 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h3><p><strong>点对点  让发送速率不要过快</strong>，使接收方来得及接收;  利用 滑动窗口机制就可以实施流量控制<br><strong>原理：</strong>运用 TCP报文段中的 窗口大小字段来控制，发送方的发送窗口不能  &gt; 接收方发回的窗口大小<br>滑动窗口协议是传输层进行流控的一种措施，接收方告知发送方自己可以接受缓冲区大小（此字段越大–网络吞吐量越高），从而控制发送方的发送速度，如果接收端缓冲区面临数据溢出，窗口大小值会被设置一个更小的值通知给发送端，从而控制数据发送量（发送端根据接收端指示，进行流量控制）</p><p><strong>拥塞控制：</strong>整个网络解决 过多的 数据注入到网络,  导致网络崩溃,  超过负荷, 拥塞控制包含四个策略<br>防止过多的数据注入到网络中，导致网络中的 路由器或链路过载；发送方控制 拥塞窗口的原则是：只要网络 没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去； 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><h3 id="拥塞控制四个策略："><a href="#拥塞控制四个策略：" class="headerlink" title="拥塞控制四个策略："></a><strong>拥塞控制四个策略：</strong></h3><p><strong>1.慢开始：</strong>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2,4,8 …； 慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，慢开始结束。</p><p><strong>2.拥塞避免：</strong>慢开始结束后 是 拥塞避免, 此时拥塞窗口 每个传输轮次 + 1,  直到 触发网络拥塞；如果出现超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始。</p><p><strong>3.快重传：</strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 快重传要求接收方在 收到一个失序的报文段后 ，立即发出重复确认，而  不是等到自己发送数据时 捎带确认；发送方只要一连收到三个重复确认ACK， 就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>4.快恢复：配合快重传使用</strong>，在收到三个重复确认ACK后，这种情况下只是丢失个别报文段，不是网络拥塞。因此执行快恢复，设ssthresh &#x3D; cwnd&#x2F;2 ，cwnd &#x3D; ssthresh，注意到此时直接进入 拥塞避免。 </p><p>注意：在采用快恢复算法时，慢开始算法只是在 TCP连接建立时和网络出现超时时才使用</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru93o6d9j612w0gimzi02.jpg" alt="0043A64C-1752-4B59-805F-250ED799F749" width="700" height="300"  /><h3 id="流量控制与拥塞控制-区别："><a href="#流量控制与拥塞控制-区别：" class="headerlink" title="流量控制与拥塞控制 区别："></a>流量控制与拥塞控制 区别：</h3><p><strong>相同点：</strong> 都会丢包；实现机制都是让发送方发的 慢一点，发的少一点； 提高网络性能<br><strong>不同点：</strong><br>1.丢包位置不同，流量控制丢包位置是在接收端上；  拥塞控制丢包：在路由器上<br>2.作用对象不同：流量控制对象是 接收方，防止发送方发的太快，来不及接受； 拥塞控制对象是 网络，防止发送方发的太快，造成网络拥塞，超过网络负荷。<br>3.联系：拥塞控制是一个全局性的过程，涉及网络中的所有主机，所有路由器，考虑网络负荷；流量控制是局部的，发生在端和端之间，是点到点的控制。</p><h3 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru9fuobcj60nr0fddh202.jpg" alt="Image" width="650" height="400" /><p>客户端和 服务器建立的是可靠的   全双工连接：<br>客户端：确定，服务器是可以接受，发送数据<br>服务器：确定，客户端是可以接受，发送数据</p><p><strong>第一次握手：</strong>建立连接时，客户端发送 syn包 (syn&#x3D;j)到服务器，并进入 SYN_SEND状态，等待服务器确认；此时对于服务器而言，服务器知道自己的 “接收”能力正常，客户端的 “发送”能力正常。<br><strong>第二次握手：</strong>服务器收到 syn包，确认客户 SYN（ack&#x3D;j+1），同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包 ，此时服务器进入 SYN_RECV状态；<br>此时对于客户端而言，客户端知道自己的“发送”能力正常；客户端的“接收”能力正常； 知道服务器的“发送”、“接收”能力正常<br>此时对于服务器而言，服务器知道客户端“发送”能力正常，但客户端“接收”能力不确定，同时，服务器知道自己“接收”能力正常，但“发送”能力不确定 。<br><strong>第三次握手：</strong>客户端收到服务器SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)，发送完毕后客户端和服务器进入 ESTABLISHED状态，完成三次握手。<br>此时对于服务器而言，服务器就能确定自己的“发送”能力正常，客户端的“接收”能力正常。<br>通过这样的三次握手，双方都能确定自己和对方的收，发能力正常，客户端与 服务端建立起 可靠的双工的连接，开始传送数据。</p><p>TCP 协议为实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要 重传。 为了实现这个需求，就涉及到 序号（sequence number） 和 确认号（acknowledgement number） 这2个概念 。<br><strong>序列号 seq：</strong>TCP 连接中传送的数据流中每一个字节都编上一个序号，序号字段的值是 本报文段所发送的数据的第一个字节的序号。<br><strong>确认号 ack：</strong>期望收到对方下一个报文段数据的第一个字节的序号。</p><h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru9mrx5dj60ft0ap3za02.jpg" alt="C04AF208-878B-4928-A90D-ABB44B58C24C" width="650" height="400"  /><p><strong>第一次：</strong>A 应用进程先向其 TCP发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。<br><strong>第二次：</strong>B 收到连接释放报文段后即发出确认报文段，（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。<br>A 收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。<br>此时客户端不再向服务器发送数据，服务器不再接受数据； 但服务器还会将没发送完的数据发给客户端，客户端可以继续接受服务器发来的数据。<br><strong>第三次：</strong>当B没有要发的数据时，释放报文段(FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1)，B进入LAST-ACK最后确认状态，等待A确认。<br><strong>第四次：</strong>A收到B的连接释放报文段后，对此发出确认报文段(ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1)，A进入 TIME-WAIT（时间等待）状态。此时 TCP未释放掉，需要 经过时间 等待计时器设置的时间 2MSL后，A才进入CLOSED状态。</p><h4 id="为什么-A-在-TIME-WAIT状态等待-2MSL的时间？"><a href="#为什么-A-在-TIME-WAIT状态等待-2MSL的时间？" class="headerlink" title="为什么 A 在 TIME-WAIT状态等待 2MSL的时间？"></a>为什么 A 在 TIME-WAIT状态等待 2MSL的时间？</h4><p>MSL 最长报文段寿命 Maximum Segment Lifetime，MSL&#x3D;2<br><strong>1.避免B 服务端无法 closed 关闭；</strong>确保有足够时间让 服务器 收到 对方的 ACK 包，一来一去就是2MSL； TCP 可靠的，服务器在 2MSL 时间后没收到ACK 会超时重传 ；ACK 报文段可能丢失，使得处于LAST-ACK状态的B 收不到对已发送的 FIN+ACK报文段的确认，B 超时重传FIN+ACK报文段，而 A 能在 2MSL时间内收到这个重传的 FIN+ACK报文段，接着 A重传一次确认，重新启动 2MSL计时器，最后A和B都进入到CLOSED状态；若A在TIME-WAIT状态不等待一段时间，而是 发送完 ACK报文段后立即释放连接，则 无法收到 B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则 B无法正常进入到CLOSED状态。</p><p><strong>2.避免 新旧连接混: 即 不会跟后面的 新连接混淆；</strong>  防止“ 已失效的连接请求 报文段”出现在本连接中；A 在发送完最后一个 ACK报文段后，再经过 2MSL，可以使 本连接持续时间内所产生的所有报文段 都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p><h4 id="为什么连接时三次握手，关闭时四次握手？"><a href="#为什么连接时三次握手，关闭时四次握手？" class="headerlink" title="为什么连接时三次握手，关闭时四次握手？"></a>为什么连接时三次握手，关闭时四次握手？</h4><p>当 Server 端收到 Client 端的 SYN连接请求报文后，可以直接 <strong>发送SYN+ACK报文</strong>。其中 ACK报文是用来应答的，SYN报文是用来同步的<br>但是关闭连接时，当 Server端收到FIN报文时，可能不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉 Client端，你发的FIN报文我收到。只有等到我 Server端所有的报文都发送完，我才能发送FIN报文，因此不能一起发送,  故需要四步握手。</p><h4 id="SYN泛洪（SYN-flood）攻击："><a href="#SYN泛洪（SYN-flood）攻击：" class="headerlink" title="SYN泛洪（SYN flood）攻击："></a>SYN泛洪（SYN flood）攻击：</h4><p>​    如果大量的握手请求涌向TCP服务端，而它们只发出SYN报文而不以ACK响应结束握手，服务端就要为这每一个请求都维持约一分多钟的连接去等待ACK，也就形成所谓的“半连接”。维护这些半连接是需要消耗很多服务器的网络连接资源的。如果短时间内这些资源几乎都被半连接占满，那么正常的业务请求在这期间就得不到服务，处于等待状态。如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这就形成了DoS（Denial of Service拒绝服务）攻击。</p><h3 id="Http的方法："><a href="#Http的方法：" class="headerlink" title="Http的方法："></a>Http的方法：</h3><p>Get, post 是客户端和服务器端进行请求-响应的常用方法<br><strong>GET 请求： 获取资源</strong><br>1.可被 缓存<br>2.保留在 浏览器历史记录中<br>3.有长度限制；URL 的最大长度是 2048 个字符<br>4.可被 收藏为书签<br>5.数据在 URL 中对所有人都是可见的<br>6.传输的表单在 url中</p><p><strong>POST 请求： 传输实体主体</strong><br>1.不会被缓存<br>2.不会保留在浏览器历史记录中<br>3.没有对数据长度的限制<br>4.不能 被收藏为书签<br>5.数据不会显示在 URL 中<br>6.传输的表单在request请求的 body中</p><p><strong>HEAD： 获取报文首部</strong></p><p>和GET方法类似，但服务器在响应中 只返回首部，不返回实体的主体部分；允许客户端在未获取实际资源情况下，对资源首部进行检查<br>优点：<br>1.在 不获取资源的情况下 了解资源（比如：判断其类型）；<br>2.通过查看 响应的状态码，看看某个对象是否存在；<br>3.通过查看首部，测试资源是否被修改  </p><p><strong>PUT： 上传文件</strong><br>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p><h3 id="HTTP-和-HTTPs-区别："><a href="#HTTP-和-HTTPs-区别：" class="headerlink" title="HTTP 和 HTTPs 区别："></a>HTTP 和 HTTPs 区别：</h3><p>HTTP 的请求过程：<br>1.TCP 建立连接后，客户端会发送报文给服务端；<br>2.服务端接收报文并作出响应；<br>3.客户端收到响应后解析给用户；<br>HTTP协议 不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信,非常不安全</p><p>HTTPS 在 HTTP 的基础上加入 SSL 层，HTTPS 的安全基础是 SSL，HTTPS 存在 不同于 HTTP 的默认端口和 一个加密&#x2F;身份验证层(在HTTP与 TCP之间）这个系统提供了 身份验证与加密通讯方法;  它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。</p><h3 id="HTTPS的请求过程："><a href="#HTTPS的请求过程：" class="headerlink" title="HTTPS的请求过程："></a>HTTPS的请求过程：</h3><p>1.客户端 发送请求到 服务端；<br>2.服务器返回 数字证书（公钥，明文数据，签名，服务器域名）<br>3.客户端 根据数字证书来验证服务器是不是自己要访问的（有效性），有效则随机生成对称加密的密钥X，并使用公钥加密密钥X，然后发送到服务端；<br>4.服务端使用 私钥解密，得到 对称密钥X ； 后续使用密钥 X 对报文加密传输</p><p><strong>数字证书：</strong>验证访问的 服务器网站是有效的，合法的<br><strong>签名：</strong> 验证 数字证书是有效的<br>CA 机构对数字证书中的 明文数据，做 hash ，然后使用 私钥加密得到 签名 S<br>浏览器收到 数字证书后，通过 公钥对签名 S 解密得到 T， 然后对 明文数据进行 hash 得到 T’ ；通过验证T&#x3D;&#x3D;T’ 来保证数字证书没有被篡改<br>Hash 作用：证书信息一般较长，而 hash后得到固定长度的信息(比如用 md5算法hash后得到固定的 128位的值),这样加密，解密会快很多<br><strong>数字证书公钥：</strong> 操作系统，浏览器本身会预装一些它们信任的根证书，其中会有 CA机构的根证书，这样就可以拿到它对应的 可信公钥，不是每次请求都经历一次密钥传输过程：服务器 会为每个浏览器维护一个 session ID，浏览器生成好 密钥X传给服务器，服务器把该 密钥X存到相应的 session ID，之后 浏览器每次请求都会携带 session ID，服务器根据 session ID 找到相应的密钥进行解密，加密操作。<br>        服务器端有个session ID 表，客户端第一次带着账户信息请求时，服务端查库，并产生一个 sessionID 返回给客户端，客户端之后请求时，会把 sessionID 放到cookie 中，携带cookie 请求，服务端通过校验sessionID，如果在sessionID表中，直接通过避免查库。</p><h4 id="HTTPS-缺点："><a href="#HTTPS-缺点：" class="headerlink" title="HTTPS 缺点："></a>HTTPS 缺点：</h4><p>1.https协议是 多次握手，导致页面 加载时间延长近50%;<br>2.https 连接 缓存不如HTTP高效，会 增加数据开销和功耗;<br>3.申请SSL 证书需要钱，功能越强大的证书费用越高;<br>4.SSL涉及到的安全算法会 消耗 CPU 资源，对服务器资源消耗较大</p><h4 id="http-和-https-区别："><a href="#http-和-https-区别：" class="headerlink" title="http 和 https 区别："></a>http 和 https 区别：</h4><p>1.https 是 http 协议的安全版本<br>2.http 协议的 数据传输是明文的，是不安全的;   https使用 SSL&#x2F;TLS 非对称加密协议进行加密处理， 是安全的<br>3.http 和https 使用连接方式不同，默认端口不一样，http是80，https是443<br>4.https协议对传输的数据进行加密，内容传输上使用对称加密，证书验证上使用非对称加密</p><h3 id="Https整体过程分为证书验证和数据传输阶段："><a href="#Https整体过程分为证书验证和数据传输阶段：" class="headerlink" title="Https整体过程分为证书验证和数据传输阶段："></a>Https整体过程分为证书验证和数据传输阶段：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guruaqnpc6j60y40u0tcd02.jpg" alt="2BD4ED6C-0A4F-49AE-AD91-A0675CDBC23C" width="700" height="500"  /><p>​    非对称加密的 <strong>加解密效率</strong>是 非常低的，而 http 应用场景中通常 端与端之间存在大量的交互，非对称加密的效率是无法接受的。<br>在 https场景中只有 服务端保存私钥，一对公钥，私钥只能实现单向的加密和解密，所以https 中内容传输加密是 对称加密，证书验证是非对称加密。</p><h3 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurvv95xvsj61a60q0q8102.jpg" alt="image-20210924172152459" width="750" height="400"  /><p>301 永久重定向；  302 暂时重定向；  网站调整； 网页移到新地址； 扩展名改变</p><h3 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。<br>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。<br>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><ul><li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li><li>个性化设置（如用户自定义设置、主题等）</li><li>浏览器行为跟踪（如跟踪分析用户行为等）</li></ul><h3 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h3><p>​    除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<br>使用 Session 维护用户登录状态的过程如下：</p><ul><li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li><li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li><li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li><li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</li></ul><h3 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h3><ul><li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li><li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li><li>对于大型网站，如果用户所有信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有用户信息都存储到 Session 中。#</li></ul><h3 id="RPC-与http-区别："><a href="#RPC-与http-区别：" class="headerlink" title="RPC 与http 区别："></a>RPC 与http 区别：</h3><p>RPC ： 远程调用其他计算机服务，底层使用 TCP 传输协议； 指定数据传输格式，序列化方式<br>相同点： 底层都是基于 socket 编程，使用 TCP 协议，实现远程调用，服务调用 服务<br>不同：<br>RPC ： 提供方，消费方 都使用 统一的RPC 框架（ dubbo）, 跨操作系统，同一编程语言内使用；  调用快，处理快，实现复杂<br>HTTP： 跨操作系统，跨编程语言； 通用性强， 实现简单</p><h3 id="区分-MSS-与-MTU："><a href="#区分-MSS-与-MTU：" class="headerlink" title="区分 MSS 与 MTU："></a><strong>区分 MSS 与 MTU：</strong></h3><p>最大传输单元（Maximum Transmission Unit, MTU）， 最大报文段长度（Maximum Segment Size ，MSS）协议用来定义最大长度的<br>MTU 应用于 数据链接层，并无具体针对的协议。 MTU限制数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知 某局域网的 MTU为1500字节，则在网络层的因特网协议（ IP）里最大数据包大小为 1500字节（包含IP协议头）。<br>MSS 应用于 传输层的TCP协议，因为 MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制</p><p>参考：<a href="https://zhuanlan.zhihu.com/p/161560683">https://zhuanlan.zhihu.com/p/161560683</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TCP-x2F-UDP-x2F-Http&quot;&gt;&lt;a href=&quot;#TCP-x2F-UDP-x2F-Http&quot; class=&quot;headerlink&quot; title=&quot;TCP&amp;#x2F;UDP&amp;#x2F;Http&quot;&gt;&lt;/a&gt;TCP&amp;#x2F;UDP&amp;#x2F;Http&lt;/</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>请求代理服务器--加密</title>
    <link href="http://example.com/2022/04/09/E-%E7%BD%91%E7%BB%9C/3.%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8A%A0%E5%AF%86/"/>
    <id>http://example.com/2022/04/09/E-%E7%BD%91%E7%BB%9C/3.%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8A%A0%E5%AF%86/</id>
    <published>2022-04-09T13:55:19.000Z</published>
    <updated>2022-04-19T13:04:31.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="请求代理服务器–加密"><a href="#请求代理服务器–加密" class="headerlink" title="请求代理服务器–加密"></a>请求代理服务器–加密</h1><p><strong>代理服务器：</strong> 提供代理服务的电脑系统或其它类型的网络终端,代替网络用户去取得网络信息。</p><p>使用代理的<strong>主要目的：</strong></p><ul><li><p>缓存：提高访问速度，由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到缓存的作用，尤其对于热门网站能明显提高访问速度。</p></li><li><p>网络访问控制：防火墙作用，由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。</p></li><li><p>突破访问限制：互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。</p></li><li><p>负载均衡，通过配置后台各个服务器的权重参数，实现多机负载</p></li></ul><h4 id="正向代理的应用"><a href="#正向代理的应用" class="headerlink" title="正向代理的应用"></a><strong>正向代理的应用</strong></h4><ol><li><p>访问原来无法访问的资源</p></li><li><p>用作缓存，加速访问速度</p></li><li><p>对客户端访问授权，上网进行认证</p></li><li><p>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p></li></ol><h4 id="反向代理的应用"><a href="#反向代理的应用" class="headerlink" title="反向代理的应用"></a><strong>反向代理的应用</strong></h4><ol><li>保护内网安全</li><li>负载均衡</li><li>缓存，减少服务器的压力</li></ol><p><strong>正向代理：</strong>一个位于客户端和原始服务器之间的服务器，为了从 <strong>原始服务器取得内容</strong>，客户端向代理发送一个请求并制定目标（原始服务器），然后 <strong>代理向原始服务器转发请求</strong>并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2sm4zxj60i907mwem02.jpg" alt="img" width="450" height="200"  /><p><strong>反向代理：</strong>以 <strong>代理服务器来接受internet上的连接请求</strong>，然后 将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2psrynj60ec076mx702.jpg" alt="img" width="450" height="200"  /><h3 id="正向-x2F-反向区别："><a href="#正向-x2F-反向区别：" class="headerlink" title="正向&#x2F;反向区别："></a>正向&#x2F;反向区别：</h3><p><strong>1.位置不同</strong></p><ul><li><p>正向代理，架设在客户机和目标主机之间；</p></li><li><p>反向代理，架设在服务器端；</p></li></ul><p><strong>2.代理对象不同</strong></p><ul><li><p>正向代理，代理客户端，服务端不知道实际发起请求的客户端；</p></li><li><p>反向代理，代理服务端，客户端不知道实际提供服务的服务端；</p></li></ul><p><strong>3.安全性不同</strong></p><ul><li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务；</li><li>反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。</li></ul><h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术:"></a>加密技术:</h3><p>是对信息进行编码和解码的技术，编码是把原来可读信息（明文）译成代码形式（密文），其逆过程就是解码（解密），加密技术要点是加密算法，加密算法可分为三类：</p><h4 id="对称加密，如AES："><a href="#对称加密，如AES：" class="headerlink" title="对称加密，如AES："></a>对称加密，如AES：</h4><p>​    基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。<br>​    优势：算法公开、计算量小、加密速度快、加密效率高<br>​    缺陷：双方都使用 同样密钥，安全性得不到保证</p><h4 id="非对称加密，如RSA："><a href="#非对称加密，如RSA：" class="headerlink" title="非对称加密，如RSA："></a>非对称加密，如RSA：</h4><p>​    基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端<br>​    私钥加密，持有 私钥、公钥才可以解密<br>​    公钥加密，持有 私钥才可解密<br>​    优点：安全，难以破解<br>​    缺点：算法比较耗时</p><h4 id="不可逆加密，如MD5，SHA："><a href="#不可逆加密，如MD5，SHA：" class="headerlink" title="不可逆加密，如MD5，SHA："></a>不可逆加密，如MD5，SHA：</h4><p>​    基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。</p><h4 id="1-在没有RSA加密时："><a href="#1-在没有RSA加密时：" class="headerlink" title="1.在没有RSA加密时："></a>1.在没有RSA加密时：</h4><p>在微服务架构中，可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru1r5iujj60mi0fc75902.jpg" alt="1527312464328" width="650" height="400"  /><p>1.用户请求登录<br>2.Zuul将请求转发到授权中心，请求授权<br>3.授权中心校验完成，颁发JWT凭证<br>4.客户端请求其它功能，携带JWT<br>5.Zuul将jwt交给授权中心校验，通过后放行<br>6.用户请求到达微服务<br>7.微服务将jwt交给鉴权中心，鉴权同时解析用户信息<br>8.鉴权中心返回用户数据给微服务<br>9.微服务处理请求，返回响应<br>问题： 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。</p><h4 id="2-在结合RSA的鉴权："><a href="#2-在结合RSA的鉴权：" class="headerlink" title="2.在结合RSA的鉴权："></a>2.在结合RSA的鉴权：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2cq63ej60ma0ezt9t02.jpg" alt="1527313765010" width="650" height="400"  /><p>1.利用RSA生成公钥和私钥，私钥保存在授权中心，公钥保存在Zuul和各个信任的微服务<br>2.用户请求登录<br>3.授权中心校验，通过后用私钥对JWT进行签名加密<br>4.返回jwt给用户<br>5.用户携带JWT访问<br>6.Zuul直接通过 公钥解密 JWT，进行验证，验证通过则放行<br>7.请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;请求代理服务器–加密&quot;&gt;&lt;a href=&quot;#请求代理服务器–加密&quot; class=&quot;headerlink&quot; title=&quot;请求代理服务器–加密&quot;&gt;&lt;/a&gt;请求代理服务器–加密&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;代理服务器：&lt;/strong&gt; 提供代理服务的电脑系统或其它</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络概述</title>
    <link href="http://example.com/2022/04/08/E-%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
    <id>http://example.com/2022/04/08/E-%E7%BD%91%E7%BB%9C/1.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</id>
    <published>2022-04-08T13:55:19.000Z</published>
    <updated>2022-04-19T13:04:20.210Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络概述："><a href="#计算机网络概述：" class="headerlink" title="计算机网络概述："></a>计算机网络概述：</h1><p>网络是把主机连接起来，互连网（internet）是把多种不同的网络连接起来。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvo14kvhj60pe0gkjsy02.jpg" width="350" height="200"  /><h4 id="主机之间的通信方式"><a href="#主机之间的通信方式" class="headerlink" title="主机之间的通信方式"></a>主机之间的通信方式</h4><p>1.客户-服务器(C&#x2F;S)：客户是服务的请求方，服务器是服务的提供方</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvoxas2uj60ds0b0aa502.jpg" alt="103AEF76-2D90-48D2-8F3F-48F45A280D2D" width="250" height="150"  /><p>2.对等(P2P):  不区分客户和服务器</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvptl5y4j60d20b0dg002.jpg" alt="240FE4DC-14A2-49AB-8C9F-8F0105C7BF4B" width="250" height="150"  /><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>每台计算机通信时把数据包进行分组打包，只要在头部附上本机的信息和组号就可以多台计算机共用一条通信线路，这样就提高了通信线路的利用率。分组交换过程中发送端计算机发送给路由器，路由器会缓存这部分数据然后再转发给目标计算机。路由器不一定按照队列先进先出然后再发出去，也有可能优先发出一些特殊的数据。<br>每个分组都有首部和尾部，包含源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互不影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。</p><p>网络传输时延：</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvqjh6ovj60l407gjro02.jpg" alt="9DDA2E4C-67B6-42EC-911E-35C0355914AC" width="650" height="200"  /><p>总时延  &#x3D;  排队时延 +  处理时延 +  传输时延 +  传播时延</p><ol><li>排队时延：分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。</li><li>处理时延：主机或路由器收到分组时进行处理所需要的时间；例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。</li><li>传输时延：主机或路由器传输数据帧所需要的时间。</li></ol><p>4.传播时延：电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvqsrrjjj60gl06rdh002.jpg" alt="FFE6973C-138C-48DB-90FC-3C6794A1DB0D" width="650" height="300"  /><h3 id="七层协议："><a href="#七层协议：" class="headerlink" title="七层协议："></a>七层协议：</h3><ul><li>应用层 ：为特定 应用程序提供数据传输服务；例如 HTTP、DNS 等协议。数据单位：报文</li><li>表示层 ：数据压缩、加密以及数据描述，使应用程序不必关心在各台主机中数据内部格式不同的问题。</li><li>会话层 ：建立及管理会话。</li><li>传输层 ：为进程提供通用数据传输服务。应用层协议很多，定义通用的传输层协议可以支持不断增多的应用层协议。<br>传输层包括：TCP，UDP</li><li>网络层 ：为主机提供数据传输服务。传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递下来的报文段或用户数据报封装成分组。</li><li>数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。</li><li>物理层 ：在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</li></ul><h3 id="协议的层次、模型："><a href="#协议的层次、模型：" class="headerlink" title="协议的层次、模型："></a><strong>协议的层次、模型：</strong></h3><p>OSI 七层模型：<br>应用层： 允许有访问OSI 环境的手段，HTTP，FTP,DNS, SMTP, Telnet<br>表示层： 对数据进行翻译，加密、压缩  JPEG，MPEG<br>会话层： 建立，管理和终止会话 SQL， RPC<br>传输层： 提供不同端系统的进程间通信 TCP，UDP<br>网络层： 提供主机间的通信， IP， ICMP， ARP，<br>数据链路层： 提供网络中点到点之间数据帧的传递PPP，MAC（网桥，交换机）<br>物理层： 提供在物理介质上每一比特的传输 CLOCK， IEEE802.3（中继器，集线器，网关）</p><p>Internet 五层模型：<br>应用层：   将应用程序的 报文交给传输层<br>传输层：  将接收的报文分段，封装TCP&#x2F;UDP头部信息，将报文段传递给网络层<br>网络层：  将接收的报文段封装 IP头部信息，将数据报交给数据链路层<br>数据链路层： 将接收网络层的数据报，封装数据帧头部信息，将数据帧从一个节点通过链路传到另一个节点<br>物理层： 数据链路层负责将一个个数据帧从一点传递到另一点，物理层负责一个个比特从一点传递到另一点</p><h4 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h4><p>HTTP、DNS 、FTP等协议</p><h4 id="传输层：-两种协议"><a href="#传输层：-两种协议" class="headerlink" title="传输层： 两种协议"></a>传输层： 两种协议</h4><p>传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；<br>用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。</p><h4 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h4><p>IP 协议：根据路由表实现IP数据报的路由转发</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gujvrggomrj60zs0k2dj302.jpg" alt="F9F897CF-D0C9-4F9A-A010-3985E6274581" width="680" height="350" /><h4 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h4><p>信道分类： </p><ol><li>广播信道： 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。</li><li>点对点信道： 一对一通信： 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</li></ol><p>信道复用技术： 频分复用；时分复用；统计时分复用；波分复用；码分复用</p><p>MAC 地址：<br>链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。一台主机拥有多少个网络适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p><p>交换机：<br>有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。</p><p>地址解析协议 ARP<br>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。<br>ARP 实现由 IP 地址得到 MAC 地址。</p><h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p>根据信息在传输线上的传送方向，分为以下三种通信方式：<br>单工通信：单向传输；<br>半双工通信：双向交替传输；<br>全双工通信：双向同时传输</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;计算机网络概述：&quot;&gt;&lt;a href=&quot;#计算机网络概述：&quot; class=&quot;headerlink&quot; title=&quot;计算机网络概述：&quot;&gt;&lt;/a&gt;计算机网络概述：&lt;/h1&gt;&lt;p&gt;网络是把主机连接起来，互连网（internet）是把多种不同的网络连接起来。&lt;/p&gt;
&lt;im</summary>
      
    
    
    
    <category term="网络" scheme="http://example.com/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="网络" scheme="http://example.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>SQL实践案例</title>
    <link href="http://example.com/2022/03/15/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B2-SQL%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/"/>
    <id>http://example.com/2022/03/15/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B2-SQL%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/</id>
    <published>2022-03-15T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:35.845Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL实践案例"><a href="#SQL实践案例" class="headerlink" title="SQL实践案例"></a>SQL实践案例</h1><p>查寻每个省份中，金额排 前三的数据</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryq33sqkj60q00g0mys02.jpg" alt="779BB0D3-D123-45C3-9705-FBE5B65973CA" width="350" height="200" />          <img src="https://tva1.sinaimg.cn/large/008i3skNly1guryq7vz98j60pe08swfa02.jpg" alt="A8F514AE-FB66-4027-B813-4FA44385AE55" width="350" height="150" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># a.province = b.province 表示分组，里外统一省份</span><br><span class="line"># b.amount &gt; a.amount 表示 内部金额 &gt; 外部金额的 条数</span><br><span class="line"># 先确定 外部金额，在从内部金额中找到满足条件的数量</span><br><span class="line">select * </span><br><span class="line">from city_order as a </span><br><span class="line">where 3 &gt; ( select count(*) from city_order as b </span><br><span class="line">            where a.province=b.province and a.amount&lt; b.amount );</span><br><span class="line">ORDER BY amount desc;</span><br></pre></td></tr></table></figure><p>使用group by 分组统计之后，select 后面只能跟：  group by 的字段、聚合函数</p><p>select 中的非多行函数列，都必须出现在group by 中,在group by 中的列，可以出现或不出现在 select 字句中:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select deptno, avg(sal)</span><br><span class="line">from emp</span><br><span class="line">group by deptno;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select province , max(amount) amount</span><br><span class="line">from city_order</span><br><span class="line">group by province;</span><br><span class="line"></span><br><span class="line">select province , avg(amount) amount</span><br><span class="line">from city_order</span><br><span class="line">group by province</span><br><span class="line">having max(amount)&gt; 500;  # amount&gt;500 报错，</span><br></pre></td></tr></table></figure><p>在 having ,select 的字段中，只能写 group by 分组的字段 + 聚合函数（其他字段）</p><p>不适用 order by ， 实现在 salaries 表 中找 第二大 的员工信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select b.emp_no, max(b.salary),  a.last_name, a.first_name</span><br><span class="line">from  employees a,  salaries b  on a.emp_no = b.emp_no</span><br><span class="line">where b.salary &lt; (select max(bb.salary) from salaries bb);</span><br></pre></td></tr></table></figure><p><strong>知识点：</strong><br>在 from 后边写 连接 left join,  right join ,  inner join;   通过 on  连接2个表的相连字段。<br>对所有员工的 薪水按照 salary降序进行 1-N的排名，要求相同 salary并列且按照 emp_no升序排列：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select emp_no, salary, </span><br><span class="line">    (select  count(distinct salary) from salaries s2  where s1.salary&lt;=s2.salary )</span><br><span class="line">from salaries s1</span><br><span class="line">order by salary Desc, emp_no Asc;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL实践案例&quot;&gt;&lt;a href=&quot;#SQL实践案例&quot; class=&quot;headerlink&quot; title=&quot;SQL实践案例&quot;&gt;&lt;/a&gt;SQL实践案例&lt;/h1&gt;&lt;p&gt;查寻每个省份中，金额排 前三的数据&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://tva1.si</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>SQL语法</title>
    <link href="http://example.com/2022/03/14/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B1-SQL%E8%AF%AD%E6%B3%95/"/>
    <id>http://example.com/2022/03/14/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B1-SQL%E8%AF%AD%E6%B3%95/</id>
    <published>2022-03-14T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:31.943Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><p>本地启动： sudo  &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server start –skip-grant-tables<br>关闭： sudo pkill -9 mysql<br>登陆 docker 中的 mysql:  mysql -h  10.85.172.27 -P  4058  -u  rootName -p  passWord  cashier<br>忘记密码启动： 修改  mysql.user 表里面的password字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;  update mysql.user <span class="built_in">set</span> password=‘***<span class="string">&#x27;  where host=‘***&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; flush privileges;</span></span><br></pre></td></tr></table></figure><h4 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a><strong>数据库：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">create database **if not exists dbName character set utf8;**</span><br><span class="line">**show databases;**</span><br><span class="line">**drop database if exists dbName;**</span><br><span class="line">use dbName;</span><br><span class="line">select database();  -- 显示当前打开的数据库</span><br></pre></td></tr></table></figure><h4 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a><strong>创建表：</strong></h4><p>PRIMARY KEY:  主键约束</p><p>UNIQUE KEY:   唯一约束</p><p>NOT NULL:     非空约束</p><p>DEFAULT:      默认约束</p><p>FOREIGN KEY:  外键约束</p><p>主键可自动编号，则可加上 “AUTO_INCREMENT”</p><p>级联外键字段：</p><p>CASCADE：父表的删除、更新操作会使得子表中匹配的行也自动进行删除或更新；</p><p>SET NULL：父表的删除、更新操作会使得子表中的外键列为NULL，并且前提是外键列没有指定为NOT NULL；</p><p>RESTRICT：拒绝对父表的删除或更新操作；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists teacher(</span><br><span class="line">  id   **int primary key** unique key ,</span><br><span class="line">  name  varchar(20) not null ,</span><br><span class="line">  score  float(8,2) UNIQUE,</span><br><span class="line">  age   int not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">\# 子表</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">  id    SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username VARCHAR(10) NOT NULL,</span><br><span class="line">  pid    SMALLINT UNSIGNED, </span><br><span class="line">  FOREIGN KEY (pid) REFERENCES province (id)  /* 外键列，外键列和参照列必须具有相似的数据类型 */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE user3(</span><br><span class="line">  id     SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username  VARCHAR(10) NOT NULL,</span><br><span class="line">  pid     SMALLINT UNSIGNED,</span><br><span class="line">  FOREIGN KEY (pid) REFERENCES province (id) ON DELETE CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 外键</span><br><span class="line">create table province(</span><br><span class="line">  id   **SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,** </span><br><span class="line">  pname  VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line">**show columns** from teacher; -- 查看数据表结构</span><br></pre></td></tr></table></figure><h4 id="修改表属性："><a href="#修改表属性：" class="headerlink" title="修改表属性："></a><strong>修改表属性：</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table user3  add  age tinyint unsigned not null; -- 添加一列</span><br><span class="line">alter table teacher add  (class varchar(20),  address varchar(10) not null);  —- 添加多列</span><br><span class="line">alter table teacher drop class; -- 删除一列</span><br></pre></td></tr></table></figure><p><strong>– 添加约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table  teacher  add  unique(age);</span><br><span class="line">alter table  user3   add  foreign key(pid) references province(id);</span><br></pre></td></tr></table></figure><p><strong>– 删除约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3  drop primary key;</span><br></pre></td></tr></table></figure><p><strong>– 修改列定义</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3 modify id smallint unsigned not null first;</span><br></pre></td></tr></table></figure><p><strong>– 修改列名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3 change age userage tinyint unsigned;</span><br></pre></td></tr></table></figure><p><strong>– 修改表名</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table user3 rename as user33;</span><br></pre></td></tr></table></figure><p><strong>删除表：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table user;  </span><br></pre></td></tr></table></figure><p><strong>增删改：</strong></p><h4 id="增-删-改"><a href="#增-删-改" class="headerlink" title="增-删-改:"></a><strong>增-删-改:</strong></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**insert into** teacher (id,name,score) values (0,&#x27;whq&#x27;,98.3241),(1,&#x27;wxb&#x27;,34.42);</span><br><span class="line"></span><br><span class="line">**delete from** teacher where id = 1;</span><br><span class="line"></span><br><span class="line">**update** teacher **set age=24** where name=&#x27;whq&#x27;;</span><br></pre></td></tr></table></figure><h4 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">SELECT select_expr1[,select_expr2,...]</span><br><span class="line">[</span><br><span class="line">  FROM table_name</span><br><span class="line">  [WHERE   where_condition]</span><br><span class="line">  [GROUP BY  &#123;col_name | position&#125; [ASC | DESC],...]</span><br><span class="line">  [HAVING   where_condition]</span><br><span class="line">  [ORDER BY  &#123;col_name | expr | position&#125; [ASC | DESC],...]</span><br><span class="line">  [LIMIT   &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">select name, age</span><br><span class="line">from teacher</span><br><span class="line">group by age asc;</span><br><span class="line">select name, age</span><br><span class="line">from teacher</span><br><span class="line">group by age asc having age&gt;=10;</span><br><span class="line"></span><br><span class="line">/* 从查询结果中的第3行开始（从0开始计数），共返回4行 */</span><br><span class="line">SELECT name,age </span><br><span class="line">FROM teacher </span><br><span class="line">ORDER BY age ASC </span><br><span class="line">LIMIT 3,4;</span><br><span class="line"></span><br><span class="line">/* 子查询的结果作为上一层查询的条件。可使用IN()/NOT IN()、ANY()、SOME()、ALL()等操作符和比较运算符搭配使用。 */</span><br><span class="line">SELECT goods_id,goods_name,goods_price </span><br><span class="line">FROM tdb_goods </span><br><span class="line">WHERE goods_price &gt;= (SELECT AVG(goods_price) FROM tdb_goods);</span><br><span class="line"></span><br><span class="line">-- LEFT/RIGHT [OUTER] JOIN左外连接/右外连接</span><br><span class="line">SELECT goods_id, goods_name, cate_name </span><br><span class="line">FROM tdb_goods as tg **LEFT JOIN** tdb_goods_cates as tgc</span><br><span class="line">**ON tg.cate_id = tgc.cate_id;**</span><br></pre></td></tr></table></figure><h4 id="–-多表删除"><a href="#–-多表删除" class="headerlink" title="– 多表删除"></a>– 多表删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DELETE t1 </span><br><span class="line">FROM tdb_goods AS t1 </span><br><span class="line">LEFT JOIN (SELECT goods_id,goods_name </span><br><span class="line">  FROM tdb_goods </span><br><span class="line">GROUP BY goods_name </span><br><span class="line">HAVING count(goods_name) &gt;= 2 ) AS t2 </span><br><span class="line">ON t1.goods_name = t2.goods_name </span><br><span class="line">WHERE t1.goods_id &gt; t2.goods_id;</span><br></pre></td></tr></table></figure><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数:"></a><strong>聚合函数:</strong></h3><ol><li><p>AVG()：求平均值；</p></li><li><p>COUNT()：计数；</p></li><li><p>MAX()：求最大值；</p></li><li><p>MIN()：求最小值；</p></li><li><p>SUM()：求和</p></li></ol><h3 id="数值运算："><a href="#数值运算：" class="headerlink" title="数值运算："></a><strong>数值运算：</strong></h3><ol><li>ceil(x)：返回大于 x的最小整数值；</li><li>div：整数除法，即结果中只保留整数部分；</li><li>floor(x)：返回小于 x的最大整数值；</li><li>mod：取余；</li><li>power(x, y)：幂运算，即 x的y次方；</li><li>round(x, y)：四舍五入，即将数值 x四舍五入为y位小数。</li><li>truncate(x, y)：数字截取，将数值 x保留y位小数（不进行四舍五入）</li></ol><h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算:"></a><strong>比较运算:</strong></h3><ol><li>[NOT] BETWEEN…AND…：【不】在范围之内；</li><li>[NOT] IN()：【不】在列出值范围内；</li><li>IS [NOT] NULL：【非】空</li></ol><h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数:"></a><strong>字符函数:</strong></h3><ol><li><p>CONCAT(  str1, str2, …)： 字符连接；</p></li><li><p>CONCAT_WS(separator, str1, str2, …)： 使用指定的分隔符进行字符连接；</p></li><li><p>FORMAT(x, d)： x为某数字，d为小数位；</p></li><li><p>LOWER(str)： 将字符串转化为小写字母；</p></li><li><p>UPPER(str)： 将字符串转化为大写字母；</p></li><li><p>LEFT(str, len)：  返回指定长度的字符串的左侧部分；</p></li><li><p>RIGHT(str, len)： 返回指定长度的字符串的右侧部分；</p></li><li><p>MID(str, pos[, len])： 返回str里从pos位置开始，长度为len的字符串部分；</p></li><li><p>SUBSTRING(str, pos, len)： 返回str里从pos位置开始，长度为len的字符串部分；</p></li><li><p>LENGTH(str)： 返回字符串str的长度，空格也会一起计算长度，以字节为单位；</p></li><li><p>LTRIM(str)： 删除前导空格；</p></li><li><p>RTRIM(str)： 删除后续空格；</p></li><li><p>TRIM([{BOTH | LEADING | TRAILING} [removed_str]] FROM str)： 删除前后缀不需要的字符；</p></li><li><p>[NOT]LIKE()： 与通配符一起使用选择数据。MySQL提供两个通配符（%和_），其中，“%”用于匹配任何字符串，“_”用于匹配任何单个字符。如果需要匹配的字符本身就是通配符，可使用ESCAPE；</p></li><li><p>REPLACE(str, old_str, new_str)：将str字符串里的old_str字符串部分替换为new_str；</p></li><li><p>LOCATE(substr,str)： 返回子符串substr在字符串str的第一个出现的位置；</p></li><li><p>LOCATE(substr,str,pos)：返回子符串substr在字符串str，从pos处开始的第一次出现的位置。</p></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/* LIKE()举例 */</span><br><span class="line">SELECT * FROM test WHERE first_name LIKE &#x27;%1%%&#x27; ESCAPE &#x27;1’;    --  不将“1”后的“%”认为是通配符 </span><br></pre></td></tr></table></figure><h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数:"></a><strong>日期时间函数:</strong></h3><ol><li>NOW()： 当前日期和时间；</li><li>DATE(date)： 返回日期；</li><li>CURDATE()： 当前日期；</li><li>CURTIME()： 当前时间；</li><li>YEAR(date)： 返回date中的年份；</li><li>MONTH(date)： 返回date中的月份；</li><li>DAY(date)：    返回date的中的日；</li><li>DATE_ADD(date, INTERVAL expr type)：日期加减。type类型可以是DAY、WEEK、MONTH、YEAR等。例：SELECT DATE_ADD( ‘2017-11-20’, INTERVAL 2 DAY);</li><li>DATEDIFF()：返回两个日期之间的天数；</li><li>DATE_FORMAT( date, format)：日期时间格式化。例如%d、%m、%Y等</li></ol><h3 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数:"></a><strong>信息函数:</strong></h3><ol><li>CONNECTION_ID()：返回数据库的连接次数</li><li>DATABASE()：  当前数据库；</li><li>LAST_INSERT_ID()： 最后插入记录的id；</li><li>USER()： 当前用户；</li><li>VERSION()： 版本信息</li></ol><h3 id="加密函数："><a href="#加密函数：" class="headerlink" title="加密函数："></a><strong>加密函数：</strong></h3><ol><li>MD5()：信息摘要算法；</li><li>PASSWORD()：密码算法</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL语法&quot;&gt;&lt;a href=&quot;#SQL语法&quot; class=&quot;headerlink&quot; title=&quot;SQL语法&quot;&gt;&lt;/a&gt;SQL语法&lt;/h1&gt;&lt;p&gt;本地启动： sudo  &amp;#x2F;usr&amp;#x2F;local&amp;#x2F;mysql&amp;#x2F;support-f</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>MySQL扩展</title>
    <link href="http://example.com/2022/03/12/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A4-Mysql%E6%89%A9%E5%B1%95/"/>
    <id>http://example.com/2022/03/12/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A4-Mysql%E6%89%A9%E5%B1%95/</id>
    <published>2022-03-12T13:55:36.000Z</published>
    <updated>2022-04-19T13:05:22.659Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL扩展"><a href="#MySQL扩展" class="headerlink" title="MySQL扩展"></a>MySQL扩展</h1><h3 id="Mysql-数据库连接池参数："><a href="#Mysql-数据库连接池参数：" class="headerlink" title="Mysql 数据库连接池参数："></a>Mysql 数据库连接池参数：</h3><p>user<br>password<br>characterEncoding  编码方式<br>autoReconnect：    当数据库连接异常中断时，是否自动重新连接？<br>maxReconnects：   autoReconnect设置为true时，重试连接的次数<br>connectTimeout：   和数据库服务器建立 socket连接时的超时，单位：毫秒。 0表示永不超时<br>allowMultiQueries： mysql驱动开启批量执行sql的开关</p><h3 id="Mysql-的参数："><a href="#Mysql-的参数：" class="headerlink" title="Mysql 的参数："></a>Mysql 的参数：</h3><p>max_connections&#x3D;3000:  MySql的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量<br>default-storage-engine:   MySQL的 默认存储引擎 </p><p>innodb_buffer_pool_size:  (默认128M) 存储页面缓存数据<br>innodb_change_buffer_max_size： changeBuffer缓存区,修改记录的<br>read_rnd_buffer_size : 随机读缓冲区大小  MRR 做随机IO时使用，这里会对主键进行排序<br>read_buffer_size : 读入缓冲区大小。对表进行 顺序扫描的请求将分配一个读入缓冲区<br>innodb_log_buffer_size :  事务日志所使用的缓冲区； redo_log日志需要先缓存，再刷盘</p><p>wait_timeout&#x3D;1800:  MySQL连接闲置 超过一定时间后将会被强行关闭<br>back_log&#x3D;500  : 连接数据达到 max_connections时，新来请求将会被存在堆栈中，等待某一连接释放资源，该堆栈数量即back_log<br>max_user_connections ： 同一个账号能够同时连接到mysql服务的最大连接数。设置为0表示不限制</p><h3 id="MySQL主机宕机后，如何恢复？"><a href="#MySQL主机宕机后，如何恢复？" class="headerlink" title="MySQL主机宕机后，如何恢复？"></a>MySQL主机宕机后，如何恢复？</h3><p>主库宕机：<br>1.确保所有从节点 relay log 全部更新完毕； 在每个从库上执行 show processlist 查看<br>2.登录所有 从节点，查看 master.info文件， 找 最大的  pos 节点作为新主库，数据最全<br>3.登录 pos 最大从节点，执行 stop slave;   删 relay-log.info 等从相关文件； 开启 bin-log 来记录sql 日志； 执行 reset master<br>4.创建用于 同步的用户并授权slave<br>5.登录其他从节点 ，执行 stop slave停止同步，再 执行 start slave ；<br>6.测试 新master 和 slave 数据是 否同步</p><h3 id="从库宕机："><a href="#从库宕机：" class="headerlink" title="从库宕机："></a>从库宕机：</h3><p>1)查看 从库上 mysql 的错误日志，里面有记录 主从挂掉时的binlog信息<br>2)有了 binlog和postion信息后，只需要 重新在 从库上进行change master to配置； 配置后开启slave 状态，没有报错<br>3)查看 slave状态，发现slave已经正常了，开始进行 延时数据恢复 </p><h3 id="MHA-多节点集群："><a href="#MHA-多节点集群：" class="headerlink" title="MHA+多节点集群："></a>MHA+多节点集群：</h3><p>MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master，整个故障转移过程对应用程序完全透明。<br>1）service mysql stop (关闭主库)<br>2）备库自动提升为主，IP地址同时漂移至备机<br>3）从库自动同步备库<br>修复原主库，将角色变为备，连接至现主库，三台主从又恢复了正常，重新建立MHA</p><h3 id="redo-log-与-binlog-区别："><a href="#redo-log-与-binlog-区别：" class="headerlink" title="redo log 与 binlog 区别："></a>redo log 与 binlog 区别：</h3><p>1）作用不同：<br>redo log是用于保证MySQL宕机也不会影响持久性；<br>binlog是用于 保证服务器可以 基于时间点恢复数据，此外 binlog还用于主从复制。<br>2）层次不同：<br>redo log是 InnoDB存储引擎实现的；<br>binlog 是MySQL的服务器层实现的，同时支持InnoDB和其他存储引擎。<br>3）内容不同：<br>redo log 是物理日志，内容基于磁盘的Page；<br>binlog 内容是二进制的，根据binlog_format参数的不同，可能基于 sql语句，基于数据本身或者二者的混合。<br>4）写入时机不同：<br>binlog在事务提交时写入；<br>redo log 写入时机相对多元：<br>** 当事务提交时会调用 fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。<br>** 除事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样好处是不一定要等到commit时刷盘，commit速度加快。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MySQL扩展&quot;&gt;&lt;a href=&quot;#MySQL扩展&quot; class=&quot;headerlink&quot; title=&quot;MySQL扩展&quot;&gt;&lt;/a&gt;MySQL扩展&lt;/h1&gt;&lt;h3 id=&quot;Mysql-数据库连接池参数：&quot;&gt;&lt;a href=&quot;#Mysql-数据库连接池参数：&quot; c</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>数据库隔离级别</title>
    <link href="http://example.com/2022/03/11/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://example.com/2022/03/11/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2022-03-11T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:18.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><h4 id="MVCC：MVCC（Multi-Version-Concurrency-Control）多版本的并发控制协议"><a href="#MVCC：MVCC（Multi-Version-Concurrency-Control）多版本的并发控制协议" class="headerlink" title="MVCC：MVCC（Multi-Version Concurrency Control）多版本的并发控制协议"></a>MVCC：MVCC（Multi-Version Concurrency Control）多版本的并发控制协议</h4><p>1.同一时刻，不同的事务读取到的数据可能是不同的 (即多版本)——在T5时刻，事务A和事务C可以读取到不同版本的数据。</p><p>​                            <img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx63fribj60vs0nwgo602.jpg" alt="620165EF-CFEB-4480-AA0F-49D6F836E3B2" width="450" height="350"/>       </p><p><strong>MVCC最大的优点：</strong> 读不加锁，因此 读写不冲突，并发性能好<br>InnoDB 存储引擎中，SELECT 操作的不可重复读问题 通过 MVCC 得到解决，而 UPDATE、DELETE 的不可重复读问题通过 Record Lock 解决，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。</p><p>InnoDB 实现 MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：<br><strong>1）隐藏列：</strong>InnoDB中 每行数据都有隐藏列，隐藏列中包含本行数据的事务id，指向 undo log的指针等。<br><strong>2）基于undo log的版本链：</strong>前面说到每行数据的隐藏列中包含了指向 undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。<br><strong>3）ReadView：</strong>通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但具体要恢复到哪个版本，需要根据 ReadView来确定。</p><p>ReadView：指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行 读操作时，会将读取到的数据中的事务 id与 trx_sys快照比较，从而判断数据对该 ReadView是否可见，即对事务A是否可见。</p><p>trx_sys 中的主要内容，判断可见性的方法如下：</p><ul><li>low_limit_id：生成ReadView时系统中应该分配给下一个事务的id，如果数据的事务 id&gt;&#x3D;low_limit_id，则对该ReadView不可见。</li><li>up_limit_id：生成ReadView时当前系统中活跃的读写事务中最小的事务id，如果数据的事务 id&lt;up_limit_id，则对该ReadView可见。</li><li>rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务 id列表。<br>如果数据的事务 low_limit_id &lt; id &lt; up_limit_id ，则需要判断事务 id 是否在rw_trx_ids中：<br>如果在，说明生成 ReadView时事务仍在活跃中，因此数据对ReadView不可见；<br>如果不在，说明生成 ReadView时事务已经提交了，因此数据对ReadView可见。</li></ul><h3 id="RR隔离级别为例："><a href="#RR隔离级别为例：" class="headerlink" title="RR隔离级别为例："></a>RR隔离级别为例：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx7nmijaj60ug0hsgn702.jpg" alt="955EFA49-F4D3-4F25-B180-2CE6CA78E73C" width="550" height="350" /><p>​    当事务 A在T3时刻读取zhangsan的余额前，会生成ReadView，由于此时事务B没有提交仍然活跃，因此其事务id一定在ReadView的rw_trx_ids中，因此根据前面介绍的规则，事务B的修改对ReadView不可见。接下来，事务A根据指针指向的 undo log查询上一版本的数据，得到zhangsan的余额为100，这样事务A就避免了脏读。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx7jj81uj60ti0mcjti02.jpg" alt="7EBA    16D3-DE67-4CB1-8E64-14B06468BAA9" width="450" height="350"/><p>当事务A在T2时刻读取zhangsan 的余额前，会生成 ReadView。此时事务 B 分两种情况讨论:<br>一种是如图中所示，事务已经开始但没有提交，此时其事务id在ReadView的rw_trx_ids中；<br>一种是事务B还没有开始，此时其事务id &gt;&#x3D; ReadView的 low_limit_id；<br>无论是 哪种情况，根据前面介绍的规则，事务B的修改对ReadView都不可见。当事务A在 T5时刻再次读取zhangsan的余额时，会根据T2时刻生成的ReadView对数据的可见性进行判断，从而判断出事务B的修改不可见；因此事务A根据指针指向的undo log查询上一版本的数据，得到zhangsan的余额为100，从而避免了不可重复读。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx8dda69j60t20swjtp02.jpg" alt="41C08622-F246-4B8C-84E7-58F2AA86A073" width="450" height="400" /><p>MVCC避免幻读机制与避免不可重复读非常类似。当事务 A在 T2时刻读取 0&lt;id&lt;5的用户余额前，会生成ReadView。此时事务 B分两种情况讨论：<br>一种是 如图中所示，事务已经开始但没有提交，此时其事务 id在ReadView的rw_trx_ids中；<br>一种是 事务B还没有开始，此时其事务 id &gt;&#x3D; ReadView 的low_limit_id。<br>无论是哪种情况，根据前面介绍的规则，事务B的修改对 ReadView都不可见。<br>当事务A在 T5时刻再次读取0&lt;id&lt;5的用户余额时，会根据 T2时刻生成的ReadView对数据的可见性进行判断，从而判断出事务B的修改不可见。因此对于新插入的数据 lisi(id&#x3D;2)，事务A根据其指针指向的 undo log查询上一版本的数据，发现该数据并不存在，从而避免了幻读</p><h3 id="可重复读隔离级别实现过程："><a href="#可重复读隔离级别实现过程：" class="headerlink" title="可重复读隔离级别实现过程："></a>可重复读隔离级别实现过程：</h3><p>​    当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p><h3 id="MVCC-："><a href="#MVCC-：" class="headerlink" title="MVCC ："></a>MVCC ：</h3><p>A 事务读取数据，记录此时刻的快照 id 值， 放在 ReadView 中保存，每次对数据修改都会改变快照 id 值，此id 值保持递增；当后来再次读取 数据时，会比较此时的数据版本 id 值，是否 &gt; 之前的 id 值，如果 &gt; , 说明已经被修改；<br>通 undo log 日志，查询之前的记录数据的快照，访问那个版本时的数据</p><p>RR：  可避免 脏读，不可重复读，不能避免 幻读<br>RC： 可避免  脏读， 不能避免 不可重复读，幻读<br>因为 B 线程修改数据提交后，A线程在第二次 select 时，此时不再进行 id 值的比较，会重建ReadView, 使得数据丢失</p><h3 id="MVCC是RR-隔离级别下“非加锁读”实现隔离性的方式"><a href="#MVCC是RR-隔离级别下“非加锁读”实现隔离性的方式" class="headerlink" title="MVCC是RR 隔离级别下“非加锁读”实现隔离性的方式"></a>MVCC是RR 隔离级别下“非加锁读”实现隔离性的方式</h3><h4 id="1）读已提交（RC）隔离级别下的非加锁读"><a href="#1）读已提交（RC）隔离级别下的非加锁读" class="headerlink" title="1）读已提交（RC）隔离级别下的非加锁读"></a>1）读已提交（RC）隔离级别下的非加锁读</h4><p>RC与RR一样，都使用了 MVCC，其主要区别在于：<br>RR 是在事务开始后第一次执行select前创建ReadView，直到事务提交都不会再创建；RR可以避免脏读，不可重复读和幻读。<br>RC 每次执行select前都会重新建立一个新的ReadView，因此如果事务 A第一次select之后，事务B对数据进行了修改并提交，那么事务A第二次select 时会重新建立新的ReadView，因此事务 B的修改对事务 A是可见的；因此RC隔离级别可以避免脏读，但是无法避免不可重复读和幻读。</p><h4 id="2）加锁读-与-next-key-lock"><a href="#2）加锁读-与-next-key-lock" class="headerlink" title="2）加锁读 与 next-key lock"></a>2）加锁读 与 next-key lock</h4><p>按照是否加锁，MySQL的读可以分为两种：<br>1.非加锁读（快照读，一致性读），使用普通 select语句，这种情况下使用 MVCC避免了脏读，不可重复读，幻读，保证了隔离性。<br>2.加锁读，在查询时会对查询的 数据加锁（共享锁或排它锁）；由于锁的特性，当某事务对数据进行加锁读后，其他事务无法对数据进行写操作，因此可以 避免脏读和不可重复读。而避免幻读，则需要通过 next-key lock，它是一种行锁，相当于 record lock(记录锁) + gap lock(间隙锁)；其不仅会锁住 记录本身(record lock功能)，还会 锁定一个范围(gap lock功能)；因此，加锁读同样可以避免脏读，不可重复读和幻读，保证隔离性。<br>#共享锁读取<br>select…lock in share mode<br>#排它锁读取<br>select…for update</p><p>参考：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;数据库隔离级别&quot;&gt;&lt;a href=&quot;#数据库隔离级别&quot; class=&quot;headerlink&quot; title=&quot;数据库隔离级别&quot;&gt;&lt;/a&gt;数据库隔离级别&lt;/h1&gt;&lt;h4 id=&quot;MVCC：MVCC（Multi-Version-Concurrency-Control）多</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>联合索引</title>
    <link href="http://example.com/2022/03/10/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"/>
    <id>http://example.com/2022/03/10/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</id>
    <published>2022-03-10T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:40.789Z</updated>
    
    <content type="html"><![CDATA[<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><h3 id="联合索引使用："><a href="#联合索引使用：" class="headerlink" title="联合索引使用："></a>联合索引使用：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a=1 and b=1 and c =1;     #利用到定义的索引（a,b,c）,用上a,b,c</span><br><span class="line">select * from t where a=1 and b=1;              #利用到定义的索引（a,b,c）,用上a,b</span><br><span class="line"></span><br><span class="line">select * from t where b=1 and a=1;   -- 利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器）</span><br><span class="line">select * from t where a=1;           -- 可以利用到定义的索引（a,b,c）,用上a</span><br><span class="line"></span><br><span class="line">select * from t where b=1 and c=1;    -- 不可以利用到定义的索引（a,b,c）； 最左 a 不匹配</span><br><span class="line">select * from t where a=1 and c=1;    -- 利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到</span><br></pre></td></tr></table></figure><p>通过最左匹配原则你可以定义一个联合索引，但是使得多中查询条件都可以用到该索引。<br>值得注意的是，当遇到范围查询( &gt;、&lt;、between、like )就会停止匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a=1 and b&gt;1 and c =1;  -- 这样a,b可以用到（a,b,c），c索引用不到 </span><br></pre></td></tr></table></figure><p>但是如果是建立 (a,c,b)联合索引，则 a,b,c都可以使用索引，因为优化器会自动改写为最优查询语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a=1 and b &gt;1 and c=1; -- 如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引</span><br></pre></td></tr></table></figure><h4 id="优化器改写为："><a href="#优化器改写为：" class="headerlink" title="优化器改写为："></a>优化器改写为：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a=1 and c=1 and b &gt;1;  </span><br></pre></td></tr></table></figure><p>最左匹配原则，索引index1:(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询； 注意：a,c也走，但是只走a字段索引，不会走c字段。<br>特殊情况说明： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from table where a = &#x27;1&#x27; and b &gt; ‘2’ and c=&#x27;3&#x27;; -- 这种类型只会有 a与b走索引，c不会走</span><br></pre></td></tr></table></figure><p>以index （a,b,c）为例建立这样的索引相当于建立了索引a、ab、abc三个索引。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryje2r28j60lt0i8jse02.jpg" alt="236D41B5-19F2-4ADE-B133-7CCA5383265C" width="650" height="450" /><p>​    该图就是一个形如 (a,b,c) 联合索引的 b+ 树，其中的非叶子节点存储的是第一个关键字的索引 a，而叶子节点存储的是三个关键字的数据。这里可以看出 a 是有序的，而 b，c 都是无序的。但是当在 a 相同的时候，b 是有序的，b 相同的时候，c 又是有序的。最左匹配原则中如果遇到范围查询就会停止, </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from t where a=5 and b&gt;0 and c =1;   -- 这样a,b可以用到（a,b,c），c不可以</span><br></pre></td></tr></table></figure><p>例子: 当查询到 b 的值以后（这是一个范围值），c 是无序的, 所以就不能根据联合索引来确定应该取哪一行。</p><p>在 InnoDB 中联合索引只有先确定前一个（左侧的值）后，才能确定下一个值。如果有范围查询的话，那么联合索引中使用范围查询的字段后的索引在该条 SQL 中都不会起作用。</p><p>值得注意的是，in 和 &#x3D;  都可以乱序，比如有索引（a,b,c），语句:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select * from t where c =1 and a=1 and b=1，</span><br><span class="line">这样的语句也可以用到最左匹配，因为 MySQL 中有一个优化器，他会分析 SQL 语句，将其优化成索引可以匹配的形式，即：</span><br><span class="line">select * from t where a =1 and a=1 and c=1 </span><br></pre></td></tr></table></figure><h4 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引:"></a>为什么要使用联合索引:</h4><p><strong>1.减少开销：</strong> 建一个联合索引(col1,col2,col3)，实际相当于建 (col1),(col1,col2),(col1,col2,col3)三个索引,每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！<br><strong>2.覆盖索引：</strong> 对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1&#x3D;1 and col2&#x3D;2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作，覆盖索引是主要的提升性能的优化手段之一。<br><strong>3.效率高：</strong> 索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1&#x3D;1 and col2&#x3D;2 and col3&#x3D;3, 假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从 100w条数据中找到符合col2&#x3D;2 and col3&#x3D; 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%&#x3D;1w，效率明显提升.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;联合索引&quot;&gt;&lt;a href=&quot;#联合索引&quot; class=&quot;headerlink&quot; title=&quot;联合索引&quot;&gt;&lt;/a&gt;联合索引&lt;/h1&gt;&lt;h3 id=&quot;联合索引使用：&quot;&gt;&lt;a href=&quot;#联合索引使用：&quot; class=&quot;headerlink&quot; title=&quot;联合索</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql:原理-优化</title>
    <link href="http://example.com/2022/03/09/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A2-%E5%8E%9F%E7%90%86-%E4%BC%98%E5%8C%96/"/>
    <id>http://example.com/2022/03/09/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A2-%E5%8E%9F%E7%90%86-%E4%BC%98%E5%8C%96/</id>
    <published>2022-03-09T13:55:28.000Z</published>
    <updated>2022-04-19T13:05:15.009Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工作原理-优化"><a href="#工作原理-优化" class="headerlink" title="工作原理-优化"></a>工作原理-优化</h1><h3 id="mysql-执行过程："><a href="#mysql-执行过程：" class="headerlink" title="mysql 执行过程："></a>mysql 执行过程：</h3><p>客户端 —&gt;连接器 —&gt;缓存—&gt;分析器 —&gt;优化器—&gt;执行器 —&gt;引擎 —&gt; 查询结果<br>客户端 —&gt;连接器 —&gt;缓存—&gt; 查询结果  </p><p>调优是在执行器执行之前的分析器，优化器阶段完成</p><h3 id="主从复制同步原理："><a href="#主从复制同步原理：" class="headerlink" title="主从复制同步原理："></a>主从复制同步原理：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwuc4hfij60h307zaab02.jpg" alt="216B1176-D897-40A4-BED9-E0784E96CFE8" width="650" height="250"   /><p>1.从库启动复制时，首先创建  I&#x2F;O 线程连接主库，主库随后创建 Binlog 线程将主库上的改变记录到二进制日志中<br>2.从库通过  I&#x2F;O 线程，将主库的 二进制日志文件 copy 到 从库的中继日志 Relay Log<br>3.从库上的 SQL线程 读取中继日志 Relay Log，重做 中继日志中的事件，将数据的改变更新到自己的数据库中</p><ul><li><p><strong>异步复制：</strong>主库执行完提交的事务后，会立即将结果返给给客户端，并不关心从库是否已经接收并处理，如果主 crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p></li><li><p><strong>全同步复制：</strong>指当主库执行 完一个事务，所有的从库都执行该事务后，主库才返回给客户端。需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p></li><li><p><strong>半同步复制：</strong>主库执行完客户端提交的事务后 不是立刻返回给客户端，而是等待 至少一个从库接收到并写到 relay log中才返回给客户端。半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</p></li></ul><h3 id="MySQL-数据一致性："><a href="#MySQL-数据一致性：" class="headerlink" title="MySQL 数据一致性："></a>MySQL 数据一致性：</h3><p>1.半同步，从库 ack 确认机制<br>2.缓存， 先写缓存再入主库，读从时先读缓存</p><h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h4><p>主服务器：写 +  读 （实时性要求高）<br>从服务器：读 </p><h4 id="读写-分离能提高性能的原因在于："><a href="#读写-分离能提高性能的原因在于：" class="headerlink" title="读写 分离能提高性能的原因在于："></a><strong>读写 分离能提高性能的原因在于：</strong></h4><p>1.主从服务器负责各自的读和写，极大程度缓解了锁的争用</p><p>2.从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</p><p>3.增加冗余，提高可用性</p><p>读写分离常用代理方式来实现： 代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwumox9hj60x20q4gne02.jpg" alt="DD2CC108-950E-4E49-B982-E984E6AD8076" width="650" height="450"   /><h3 id="explain-分析-select查询语句的参数："><a href="#explain-分析-select查询语句的参数：" class="headerlink" title="explain 分析 select查询语句的参数："></a>explain 分析 select查询语句的参数：</h3><p>select_type：常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY子查询等<br>Table：要查询的表<br>possible_keys：可选择的索引<br>key： 实际使用的索引<br>rows： 扫描的行数<br>type：索引查询类型，经常用到的索引查询类型：<br>    **const：使用 主键或 唯一索引 进行查询的时候只有一行匹配<br>    **ref： 使用 非唯一索引<br>    **range：使用 主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询<br>    **index： 和 all的区别是 只扫描索引树  1.查询字段是索引的一部分，覆盖索引;  2.使用主键进行排序<br>    **all：扫描全表<br>system：触发条件：表只有一行，这是一个 const type 的特殊情况</p><h3 id="查询优化："><a href="#查询优化：" class="headerlink" title="查询优化："></a>查询优化：</h3><p>1.只返回必要的列，行： 最好不要使用 SELECT*语句； 使用  LIMIT语句来限制返回的数据；只有一条数据 limit 1<br>2.多使用普通索引,  背景：写多读少，对唯一性要求不高，或业务代码来保证唯一性时<br>  普通索引使用 change buffer ，可以把一些写操作缓存下来，在读取的时候进行，避免磁盘操作，提高效率<br>3.注意：String字段，但 DB中是int ,用到隐式转换 cast(str) 函数转换，导致不走索引<br>  碰到不走索引情况，可以考虑使用 force index，强制走索引；<br>4.建立联合索引：出现频率较高，常在一起作为 where条件的字段，考虑建立联合索引，减少建立索引的数量；并借助索引下推减少回表；<br>  减少服务器端扫描的行数, 使用索引来覆盖查询。对于业务中有一些不好的索引，考虑使用覆盖索引(最左匹配原则)，把设置错误的索引给覆盖掉</p><p>5.开启MRR（mult-range Read）：此操作可以在 回表之前，进行一个排序，把原来一个随机操作变成一个顺序操作<br>原理：根据辅助索引的叶子结点，找到主键值的集合并存储到read_rnd_buffer中，在该buffer中对主键值进行排序，最后利用已经排序好的主键值的集合，去访问表中的数据，这样就由原来的 随机&#x2F;O变成为 顺序I&#x2F;O，降低查询过程中的I&#x2F;O消耗。</p><h4 id="6-分解大连接查询："><a href="#6-分解大连接查询：" class="headerlink" title="6.分解大连接查询："></a>6.分解大连接查询：</h4><p>将一个大连接查询分解成 对每一个表进行一次单表查询，然后在 应用程序中进行关联，这样做的好处有：<br>1.让缓存更高效；对于连接查询，如果一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用<br>2.分解成多个单表查询；这些单表查询的缓存结果 更可能被其它查询使用到，从而减少冗余记录的查询。<br>3.减少锁竞争；在应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。查询本身效率也可能会有所提升。</p><h4 id="7-分页查询优化："><a href="#7-分页查询优化：" class="headerlink" title="7.分页查询优化："></a>7.分页查询优化：</h4><p>1.控制返回的总页数；<br>2.对超过特定 阈值的页数进行 SQL 改写，借助主键 id 的索引覆盖<br>SELECT a.* FROM USER a  INNER JOIN  (SELECT id  FROM USER WHERE age &#x3D; 10 LIMIT 100000,10) b  ON a.id &#x3D; b.id;  结果0.53s<br>需要对 where条件增加索引，id 因为是主键自带索引，select返回减少回表可以提升查询性能, 所以采用查询主键字段后进行关联大幅度提升了查询效率。<br>3.使用Redis 来保存lastMaxtId, 下一次分页查询时直接拼接在 where 条件后边，直接跨过 offset 行数据。</p><h4 id="8-很长的字段如何设置索引："><a href="#8-很长的字段如何设置索引：" class="headerlink" title="8.很长的字段如何设置索引："></a>8.很长的字段如何设置索引：</h4><p>索引选取越长，占用磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。<br>1.短长度：把字段 hash为另外一个字段存起来，每次校验 hash就好了，hash的索引也不大，hash 后的数值要 区分度过高。<br>2.高区分：通过函数处理倒序，删减字符串减少字段长度，并增加区分度； 如：身份证区域开头，同区域人很多，REVERSE() 函数翻转一下，提高区分度。</p><h3 id="MySQL-工作原理："><a href="#MySQL-工作原理：" class="headerlink" title="MySQL 工作原理："></a>MySQL 工作原理：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwvhdqzkj60j20eq76s02.jpg" alt="EE963375-2D0A-44B3-A209-211FEFFB0A07" width="650" height="450"   /><h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>MySQL 不会直接去修改磁盘的数据，因为这样做太慢了，MySQL 会先记录 redo log，再改内存 Buffer Pool ，等有空了再刷磁盘，如果内存 Buffer Pool里没有数据，就去磁盘 load ；Buffer Pool 是 一个以 页为元素的链表。<br>持久化： 宕机时，Buffer Pool 丢失数据，重做 redo log； 先 redo log, 再 buffer pool<br>Buffer Pool 链表结构：基于 LRU， 和缓存一样，需要淘汰算法来管理数据；</p><p>​          <img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwvnzevmj60ip0cuq4a02.jpg" alt="4EC434C3-08BC-41E3-A059-E31B470752DB" width="650" height="450"  /></p><h3 id="Change-buffer"><a href="#Change-buffer" class="headerlink" title="Change  buffer:"></a>Change  buffer:</h3><p>​    查询数据时，如果内存里没有对应页的数据，MySQL 会从磁盘里 load ，如果每次需要的 页 都不同（或不是相邻的页），那每次都要去 load，很慢。如果 MySQL 发现你要修改的页不在内存里，就把要对页的修改，先记到一个叫 Change Buffer 的地方，同时记录 redo log，然后再慢慢把数据 load 到内存，load 过来后再把 Change Buffer 里记录的修改，应用到内存 Buffer Pool中，此操作： merge； 把内存数据刷到磁盘操作： <strong>purge</strong> </p><p><strong>ChangeBuffer</strong> 只在操作「二级索引」时才使用，原因是「聚簇索引」必须是「唯一」的，也就意味着每次插入&#x2F;更新，都需要检查 是否已经有相同的字段存在，也就没有必要使用 Change Buffer ；另外「聚簇索引」操作的随机性比较小，通常在相邻的「页」进行操作，比如使用自增主键的「聚簇索引」，那么 insert 时就是递增有&#x2F;序的，不像「二级索引」，访问非常随机。</p><p>​    MySQL 以16KB「页」 为 读取和写入单位，一个「页」里面有多行数据，写入数据时，MySQL 会先写 内存中的页，然后再刷新到磁盘中的页。假设在某一次从 内存刷新到磁盘的过程中，一个「页」刷了一半，突然操作系统或 MySQL 进程 崩了，此时内存里的 页数据被清除了，而磁盘里的页数据，刷了一半，处于一个中间状态，可以说是一个「不完整」，甚至是「坏掉的」的页。<br>redo log 在 磁盘中的页数据是正常、没有损坏情况下，才能把磁盘里页数据 load 到内存，如果磁盘中的页数据已经损坏，是无法应用 redo Log 的。</p><h3 id="Doublewrite-Buffer："><a href="#Doublewrite-Buffer：" class="headerlink" title="Doublewrite Buffer："></a><strong>Doublewrite Buffer：</strong></h3><p>在 刷数据到 磁盘之前，先把数据写到另外一个地方 DoubleWrite Buffer， 写完后再开始写磁盘；Doublewrite Buffer 是一个备份，当发生 crash时，就可以利用 它来 修复磁盘里的数据</p><p>1.刷数据之前宕机：内存—&gt; 磁盘，重做 redo log 日志<br>2.刷数据时宕机： 利用 Doublewrite Buffer 修复磁盘数据</p><p>​    要更新一个数据页时，如果数据页在 内存中就直接更新；但如果这个数据页还没有在内存中，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在 change buffer中，这样就不需要 从磁盘中读入这个数据页。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。<br>Change buffer 是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上，将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge。</p><h3 id="Merge触发条件："><a href="#Merge触发条件：" class="headerlink" title="Merge触发条件："></a>Merge触发条件：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutxx7tvv9j60l80wsabd02.jpg" alt="E84FCF6C-D50D-46D4-92A6-93B6B4CC1FD9" width="250" height="350"   /><p>1.访问这个数据页<br>2.系统后台线程定期 merge<br>3.在数据库正常关闭（shutdown）的过程中，也会执行merge将更新操作先记录在 change buffer，可以减少读磁盘，语句的执行速度会得到明显的提升, 数据读入 内存是需要占用 buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率</p><h3 id="使用-change-buffer-的条件？"><a href="#使用-change-buffer-的条件？" class="headerlink" title="使用 change buffer 的条件？"></a>使用 change buffer 的条件？</h3><p>普通索引可以使用 change buffer ,唯一索引（主键，聚簇索引）的更新就不能使用 change buffer<br>唯一索引更新操作都要先判断这个操作 是否违反唯一性约束, 要判断表中是否存在这个数据，就必须要将数据页读入内存才能判断，都已经读入到内存，那直接更新内存会更快，就没必要使用change buffer</p><p>change buffer 是 buffer pool里的内存，不能无限增大；<br>change buffer大小可以通过参数 innodb_change_buffer_max_size来动态设置，设置为50 表示change buffer大小最多只能占用buffer pool的50%</p><h3 id="change-buffer-使用场景："><a href="#change-buffer-使用场景：" class="headerlink" title="change buffer 使用场景："></a>change buffer 使用场景：</h3><p>适合：写多读少业务，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，业务模型常见：账单类,日志类的系统<br>不适合：读多写少（写入后马上会做查询 ）将更新先记录在change buffer，但由于马上要访问这个数据页，会立即触发merge过程，访问IO次数不会减少，反而增加 change buffer的维护代价</p><p>数据库进行 Merge 时，是真正进行 数据更新的时刻，而 change buffer 主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer 记录的变更越多（页面上要更新的数据越多），收益就越大</p><p><strong>flush 操作：</strong> redo log 会找个时间去更新到磁盘，这个操作就是flush<br>脏页：在更新之前，当内存数据页跟磁盘数据页内容不一致的时候<br>干净页：内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致</p><h3 id="flush-操作条件："><a href="#flush-操作条件：" class="headerlink" title="flush 操作条件："></a>flush 操作条件：</h3><ol><li>InnoDB的 redo log写满了</li><li>系统内存不足，需要淘汰一些数据页，空出内存给别的数据页使用。 如果淘汰“脏页”，就要先将脏页写到磁盘。</li><li>MySQL认为系统 “空闲”的时候，只要有机会就刷一点 “脏页”</li><li>MySQL正常关闭，会把内存的脏页都flush到磁盘上，这样下次启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li></ol><p>​            </p><h3 id="MySQL-中数据的存储："><a href="#MySQL-中数据的存储：" class="headerlink" title="MySQL 中数据的存储："></a><strong>MySQL 中数据的存储：</strong></h3><p>各个 数据页 组成一个 双向链表；<br>每个 数据页中的记录又组成一个 单向链表<br>每个 数据页都会为存储的记录 生成页目录，一个数据页内： 主键查找，二分法快速定位 ； 其他非主键列查找，从最小记录开始一次遍历单链表</p><h3 id="数据库连接池设置："><a href="#数据库连接池设置：" class="headerlink" title="数据库连接池设置："></a>数据库连接池设置：</h3><p>如果你有 10000个并发用户，设置一个10000的连接池基本等于失了智, 即是100也太多了。你需要一个10来个连接的小连接池，然后让剩下的业务线程都在队列里等待。连接池中的连接数量应该等于你的数据库能够有效同时进行的查询任务数（通常不会高于2*CPU核心数）。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工作原理-优化&quot;&gt;&lt;a href=&quot;#工作原理-优化&quot; class=&quot;headerlink&quot; title=&quot;工作原理-优化&quot;&gt;&lt;/a&gt;工作原理-优化&lt;/h1&gt;&lt;h3 id=&quot;mysql-执行过程：&quot;&gt;&lt;a href=&quot;#mysql-执行过程：&quot; class=&quot;he</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>Mysql:索引-事务</title>
    <link href="http://example.com/2022/03/08/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A1-%E7%B4%A2%E5%BC%95-%E4%BA%8B%E5%8A%A1/"/>
    <id>http://example.com/2022/03/08/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A1-%E7%B4%A2%E5%BC%95-%E4%BA%8B%E5%8A%A1/</id>
    <published>2022-03-08T13:55:19.000Z</published>
    <updated>2022-04-19T13:05:09.525Z</updated>
    
    <content type="html"><![CDATA[<h1 id="索引-事务"><a href="#索引-事务" class="headerlink" title="索引-事务"></a>索引-事务</h1><h3 id="搜索引擎："><a href="#搜索引擎：" class="headerlink" title="搜索引擎："></a>搜索引擎：</h3><p><strong>InnoDB :</strong>   支持事务，外键，行锁（用MVCC支持高并发）；聚簇索引，叶子节点data域存行记录；跨平台copy 容易复制；Delete 表时一行一行删除<br><strong>MyIsAM:</strong>  不支持 事务，外键，行锁；   非聚簇索引，叶子节点data域中存引用地址；   跨平台难 copy 不易复制； Delete表时先Drop 再Create； </p><h4 id="InooDB"><a href="#InooDB" class="headerlink" title="InooDB:"></a>InooDB:</h4><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。<br>默认级别时可重复读（REPEATABLE READ），在可串行化级别下，通过 MVCC + Next-Key Lock防止幻读。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwcf2dv8j60zk0hgmz202.jpg" alt="CB82D46E-3719-4F4B-BCC8-515631B077E7" width="650" height="300"  /><h4 id="MyIsam索引："><a href="#MyIsam索引：" class="headerlink" title="MyIsam索引："></a>MyIsam索引：</h4><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1f9ljnyb4j21dy0rcq7u.jpg" alt="image-20220419193858190" width="650" height="350" /><h3 id="索引优点："><a href="#索引优点：" class="headerlink" title="索引优点："></a>索引优点：</h3><p>1.提高数据检索的效率，降低数据库的 IO成本，类似于书的目录</p><p>2.索引列对 数据进行排序，降低数据排序的成本，降低CPU消耗</p><p>**被索引的列会 自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。如果按照 索引列的顺序进行排序，对应 order by语句来说，效率就会提高很多。</p><h3 id="索引缺点："><a href="#索引缺点：" class="headerlink" title="索引缺点："></a>索引缺点：</h3><p>1.索引会占据磁盘空间 </p><p>2.索引虽然会 提高查询效率，但是会降低更新表的效率。每次对表增删改，不仅要保存数据，还保存或更新对应的索引文件。</p><h3 id="为什么索引结构使用B-树？"><a href="#为什么索引结构使用B-树？" class="headerlink" title="为什么索引结构使用B+树？"></a>为什么索引结构使用B+树？</h3><p>Hash :  不适合范围查找；无法用于排序与分组；<br>二叉树：根节点的取值，容易导致 二叉树不分叉<br>平衡二叉树： 不支持 范围查询快速查找； 范围查询时需要从根节点多次遍历，查询效率不高。</p><p><strong>B树：</strong><br>1.B树 不支持范围查询 的快速查找（节点保存记录）；<br>2.每个节点的 data域存储 行记录，行的大小随着列数的增多，所占空间会变大。 这时一个 页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</p><p><strong>B+ 树：</strong> 可以保证等值，范围查询的快速查找范围查询时，因为主键具备唯一性（后面不会有 &lt;&#x3D; max_val 数据），不需再向后查找，终止。<br>InnoDB存储引擎一次 IO读取一页（默认16K）的数据量，MySQL的数据存储在磁盘文件中，查询处理数据时，需先把 磁盘中数据加载到内存中，磁盘IO操作很耗时，所以优化重点就是 尽量减少磁盘 IO 操作。</p><p><strong>自适应Hash:</strong>  InnoDB 存储引擎中，当某个 索引值被频繁使用时，会在 B+Tree 索引之上 再创建一个哈希索引，让 B+Tree 索引可以根据哈希值来快速查找。MySQL 会自动评估使用自适应索引是否值得，如果观察到建立哈希索引可以提升速度，则建立。<br>一般情况下 聚簇索引 &#x3D;&#x3D; 主键索引，当一个表没有创建主键索引时，<strong>InnoDB会 自动构建聚簇索引，规则如下：</strong>                                                                                                                             1.在表上定义 主键 PRIMARY KEY，InnoDB 将主键索引用作聚簇索引<br>2.如果表没有定义主键，InnoDB会选择 第一个不为NULL的 唯一索引列  用作聚簇索引                                                   3.如果以上两个都没有，InnoDB 使用一个 6 字节长整型的字段 ROWID字段构建聚簇索引，该 ROWID字段会在 插入新行时自动递增<br> 辅助索引： 聚簇索引之外的所有其他索引。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwdw8ihtj60we0u0n3r02.jpg" alt="8F527CD4-0314-4103-BB56-350BEB31EE6E" width="650" height="450"  /><h4 id="联合索引查询："><a href="#联合索引查询：" class="headerlink" title="联合索引查询："></a>联合索引查询：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwed8u8zj60uj0u0jv602.jpg" alt="91A14DB9-9D64-45B1-9856-D319978A60B0" width="650" height="500"  /><h3 id="前缀索引："><a href="#前缀索引：" class="headerlink" title="前缀索引："></a>前缀索引：</h3><p>​    MySQL 支持前缀索引，可以定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，索引默认包含整个字符串<br><strong>优点：</strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用 额外增加太多的查询成本。<br>有前缀索引的联合索引 一定要回表： 联合索引已包涵相关信息，还是会回表，因为有前缀索引，不确定到底是不是一个完整的信息。<br>就算是 <a href="http://www.aobing@mogu.com/">www.aobing@mogu.com</a> 一个完整的邮箱去查询，但无法判断后续是否有数据，不知道是否是完整的数据，所以需要回表去判断</p><p><strong>最左匹配原则：</strong> 在条件允许的情况下 使用组合索引替代多个单列索引使用。<br><strong>组合索引最左匹配：</strong>组合索引查询时，mysql 一直向右匹配直至遇到范围查询 ( &gt;、&lt;、between、like ) 停止匹配<br>**最左前缀匹配原则：** MySQL会一直向右匹配直到遇到范围查询 （&gt;,&lt;,BETWEEN,LIKE）就停止匹配。<br><strong>覆盖索引：</strong> 使用辅助索引的时候，只可以拿到主键值，获取数据还需要再根据主键查询主键索引取到数据。在上面abc_innodb 表中的组合索引查询时，如果只需要 abc字段，则查询到组合索引的叶子节点就可以直接返回，不需要回表。like 模糊匹配支持索引，支持最左匹配原则； Like 要使索引生效，like后不能以%开头， like %字段名%、like %字段名 这类语句会使索引失效</p><p>索引列不能参与计算，尽量保持列“干净”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FROM_UNIXTIME(create_time) = &#x27;2016-06-06’ </span><br></pre></td></tr></table></figure><p>不能使用索引，原因：B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优化：  create_time = UNIX_TIMESTAMP(&#x27;2016-06-06&#x27;)。</span><br></pre></td></tr></table></figure><h3 id="复合（联合）索引设计原则"><a href="#复合（联合）索引设计原则" class="headerlink" title="复合（联合）索引设计原则"></a>复合（联合）索引设计原则</h3><p>1.把频繁使用的列、区分度高的列放在前面<br>2.将范围查询的列放在复合索引的最后面，例如 idx_status_create_time<br>3.在常需要作为 查询返回的字段上增加到联合索引中，在联合索引上增加一个字段而使用到覆盖索引，此时建议这种情况下使用联合索引</p><p>索引下推：在使用联合索引时</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select * from table </span><br><span class="line">where name like &#x27;敖%&#x27; and size=22 and age = 20;</span><br></pre></td></tr></table></figure><p>语句在搜索索引树时只能用 “敖”，找到第一个满足条件的记录ID1，然后判断其他条件是否满足，比如 size等后续条件；<br>在 MySQL 5.6之前，只能从 ID1开始 一个个回表，到主键索引上找出数据行，再对比字段值。</p><p><strong>索引下推优化：</strong> 可以在索引遍历过程中对 联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1f9r7n2oqj21bq0dewgs.jpg" alt="image-20220419194536370" width="850" height="280" /><h4 id="唯一索引、普通索引区别：（核心-change-buffer）"><a href="#唯一索引、普通索引区别：（核心-change-buffer）" class="headerlink" title="唯一索引、普通索引区别：（核心 change buffer）"></a>唯一索引、普通索引区别：（核心 change buffer）</h4><p>普通索引使用 change buffer, 唯一索引不适用 change buffer</p><h3 id="索引字段选取："><a href="#索引字段选取：" class="headerlink" title="索引字段选取："></a>索引字段选取：</h3><p>1.主键，外键<br>2.尽量保持自增，差异性大的字段<br>3.出现频率高，常在where子句中出现的字段<br>4.小的字段（减少所占用的空间）</p><h3 id="破坏使用索引的场景："><a href="#破坏使用索引的场景：" class="headerlink" title="破坏使用索引的场景："></a>破坏使用索引的场景：</h3><p>1.索引列 有函数运算&#x2F; 运算<br>2.索引列有  !&#x3D;   &lt;&gt;    not in    not exist<br>3.like <code>%刘</code>  百分号在前的索引<br>4.字符型索引列<br>5.隐式类型转换<br>select * from t where id &#x3D; 1<br>如果 id 是字符类型的，1是数字类型的，explain会发现走全表扫描，根本用不上索引；<br>因为MySQL底层会对 比较进行转换，相当于加了 cast( id AS signed int ) 这样的一个函数，上面说过函数会导致走不上索引。</p><h3 id="MySQL-联接方式："><a href="#MySQL-联接方式：" class="headerlink" title="MySQL 联接方式："></a>MySQL 联接方式：</h3><p>1、内联接（ 使用  &#x3D; ， &lt; ，&gt; 比较运算符）： 包括相等联接、自然联接<br>内联接使用比较运算符根据 每个表 共有的列的值 匹配两个表中的行。例如，检索 students和courses表中 学生标识号相同的所有行  </p><p>2、外联接：左向外联接、右向外联接、完整外部联接<br>在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：<br>1）LEFT  JOIN或 LEFT OUTER JOIN<br>左向外联接的结果集包括  LEFT OUTER 子句中指定的左表的所有行，而不仅仅是 联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的 结果集行中右表的所有选择列表列均为空值 null<br>2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN<br>右向外联接是 左向外联接的反向联接, 将返回右表的所有行, 如果右表的某行在左表中没有匹配行，则将为左表返回空值 null<br>3）FULL  JOIN 或 FULL OUTER JOIN<br>完整 外部联接返回 左表和右表中的所有行。当某行在 另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。   </p><p>3、自然连接(笛卡尔积) 返回左表中的所有行，左表中的每一行与右表中的所有行组合</p><h3 id="事务四大特性：-原子性，一致性，隔离性，持久性"><a href="#事务四大特性：-原子性，一致性，隔离性，持久性" class="headerlink" title="事务四大特性：  原子性，一致性，隔离性，持久性"></a>事务四大特性：  原子性，一致性，隔离性，持久性</h3><p><strong>1.持久性：</strong>保证事务 提交后不会因为宕机等原因导致数据丢失； redo log<br><strong>2.原子性：</strong>语句要么 全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；undo log （回滚找到前版本数据）<br><strong>3.隔离性：</strong>保证 事务执行尽可能不受其他事务影响；undo log<br><strong>4.一致性：</strong>事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障<br>InnoDB默认的隔离级别是RR，RR的实现主要基于 锁机制（包含next-key lock），MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）</p><p>Redo log 保证事务 持久性； undo log 保证事务原子性、隔离性</p><h3 id="持久性：-redo-log（重做日志）"><a href="#持久性：-redo-log（重做日志）" class="headerlink" title="持久性： redo log（重做日志）"></a>持久性： redo log（重做日志）</h3><p>InnoDB 作为存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool  中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会 定期刷新到磁盘中（这一过程称为刷脏）。Buffer Pool 的使用提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。<br>Redo log 解决这个问题：当数据修改时，除了修改 Buffer Pool中的数据，还会在 redo log记录这次操作；当事务提交时，会调用 fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是 预写日志，（WAL Write-ahead logging），所有 修改先写入日志，再更新到Buffer Pool，保证数据不会因MySQL宕机而丢失，从而满足持久性要求。<br>redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快？<br>主要有以下两方面的原因：<br>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写 redo log是追加操作，属于顺序IO<br>（2）刷脏是以 数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而 redo log中只包含真正需要写入的部分，无效IO 减少。</p><h3 id="原子性：undo-log-（回滚日志）"><a href="#原子性：undo-log-（回滚日志）" class="headerlink" title="原子性：undo log （回滚日志）"></a>原子性：undo log （回滚日志）</h3><p>undo log: 当 事务回滚时能够撤销所有已经成功执行的sql语句，当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行 失败或调用了rollback，导致事务需要回滚，可以利用undo log中的信息将数据回滚到修改之前的样子。<br>undo log属于逻辑日志： 记录的是 sql执行相关的信息，当发生回滚时，InnoDB 会根据undo log的内容 做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p><h3 id="隔离性：undo-log"><a href="#隔离性：undo-log" class="headerlink" title="隔离性：undo log"></a>隔离性：undo log</h3><p>并发情形下事务之间互不干扰， 隔离性主要可以分为两个方面（读、写操作）：<br>1.锁： (一个事务) 写操作对(另一个事务)写操作；</p><ol start="2"><li><p>MVCC： (一个事务) 写操作对 (另一个事务)读操作</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwfv4xltj61bk0e43zo02.jpg" alt="207BFD43-7158-4542-8CD9-87A50C94B083" width="650" height="200"  /></li></ol><p><strong>未提交读：</strong> 事务可以读取 其他未提交事务的执行结果<br><strong>已提交读：</strong> 事务可以读取  已经提交事务所做的改变<br><strong>可重复读：</strong> 同一事务在 多次读取数据时，可以读取到相同的结果<br><strong>可串行化：</strong> 各个事务间串行执行， 在每个读数据行上加上共享锁。在这个级别，导致大量的超时现象和锁竞争。</p><p><strong>脏读：</strong> 不同事务下，当前事务可以读取到 另外事务未提交的数据<br><strong>不可重复读：</strong> 同一事务内 多次读取同一数据，读取到的数据是不一样的<br><strong>幻读：</strong> 一个事务读取 某一范围的数据行时，另一个事务在该范围内 插入新行，当此事务再次读取范围内的数据行时，返回之前不存在的行。 幻读是一种特殊的不可重复读问题。</p><h3 id="InnoDB-锁类型"><a href="#InnoDB-锁类型" class="headerlink" title="InnoDB 锁类型 :"></a>InnoDB 锁类型 :</h3><p><strong>行锁：</strong>行锁则只锁定需要操作的数据，并发性能好 </p><p><strong>共享锁（S Lock）：</strong> 共享锁可以和其他锁共存；<br>多个事务可以同时访问 同一数据，但 只能读不能修改<br><strong>排他锁（X Lock）：</strong> 排他锁和其他锁不能共存；<br>一个事务获取一个数据行的排他锁，其他事务就不能再获取该行的 共享锁和排他锁，获取排他锁的事务可以对数据进行读取和修改。<br>有排他锁的数据行，其他事务不能修改此数据行，也不能通过 for update和 lock in share mode 锁的方式查询数据，但可以直接通过 select …from…查询数据，因为 普通查询没有任何锁机制<br>读时加共享锁，其他事务可以并发读，但不能写； 写时加排它锁，其他事务不能并发写，也不能并发读</p><p><strong>Record Lock：</strong>行记录锁；<br><strong>Gap Lock：</strong>间隙锁，在索引记录间隙上的锁，在第一条索引记录之前，最后一条索引记录之后上的间隙锁；<br><strong>Next-key lock：</strong>下键锁，上面2个锁的组合锁；</p><p>间隙锁（Gap锁）</p><p>在使用范围条件检索数据，请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于 键值在条件范围内但并不存在的记录，叫做 “间隙(GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是 间隙锁（GAP锁）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT c1 FROM t </span><br><span class="line">WHERE c1 BETWEEN 10 and 20 </span><br><span class="line">FOR UPDATE;</span><br></pre></td></tr></table></figure><p>字面上意思是锁住 10-15的数据，如果id&#x3D;10的数据已存在，那么别的用户 不可以修改该条数据，但是如果 id&#x3D;15的数据并不存在，也是不可以插入的，因为无论该列中是否已有这样的值，因为该范围中 id 在 （10，15）所有 现有值之间的间隙也是锁定的。</p><h3 id="间隙锁的目的："><a href="#间隙锁的目的：" class="headerlink" title="间隙锁的目的："></a>间隙锁的目的：</h3><p>1.防止幻读，满足相关隔离级别的要求，要是不使用间隙锁，其他事务插入(10,20)闭区间的任何记录，本事务再次执行上述语句，就会发生幻读<br>2.为满足其恢复和复制的需要，有关其恢复和复制机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p><p><strong>Record Lock：</strong> 锁定一个 记录上的索引，而不是记录本身；<br><strong>Gap Lock：</strong>锁定索引之间的间隙，但不包含索引本身。</p><p>当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT c FROM t </span><br><span class="line">WHERE c BETWEEN 10 and 20 </span><br><span class="line">FOR UPDATE;</span><br></pre></td></tr></table></figure><p><strong>Next-Key Lock：</strong> Record Locks + Gap Locks 结合，不仅锁定 一个记录上的索引，也锁定索引之间的间隙。</p><p>一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure><h3 id="间隙锁作用："><a href="#间隙锁作用：" class="headerlink" title="间隙锁作用："></a>间隙锁作用：</h3><p>​    当事务A执行 update user set name&#x3D;’风筝2号’ where age &#x3D; 10 时，由于条件 where age &#x3D; 10 ，数据库不仅在 age &#x3D;10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷, 10]， (10,30] 这两个区间加了间隙锁，从而导致事务 B插入操作无法完成，只能等待事务A提交。不仅插入 age &#x3D; 10 的记录需要等待事务A提交，age&lt;10， 10&lt;age&lt;30 记录页无法完成，而 &gt;&#x3D; 30的记录不受影响，这足以解决幻读问题了.这是有索引的情况，如果 age 不是索引列，那数据库会为整个表加上间隙锁，不管 age 是否 &gt;&#x3D; 30，都要等待事务 A提交才可以成功插入.<br>​    </p><h4 id="表锁：表锁在操作数据时会锁定整张表，并发性能较差；"><a href="#表锁：表锁在操作数据时会锁定整张表，并发性能较差；" class="headerlink" title="表锁：表锁在操作数据时会锁定整张表，并发性能较差；"></a>表锁：表锁在操作数据时会锁定整张表，并发性能较差；</h4><p><strong>意向共享锁（IS Lock）：</strong>事务对 一张表中 某几行的数据加上共享锁；</p><p><strong>意向排他锁：</strong> 事务对一张表中 某几行的数据加上 排他锁；<br>一个事务想要给一张表加上表锁，前提是 没有其他任何事务已经锁定这张表的任意一行数据，需要去全表扫描，确认是否有哪一行数据被其他事务锁定，但这非常低效。因此引入意向锁，意向锁相当于一个标识，表示 是否有其他事务 锁定该表中的某几行数据。</p><p><strong>未提交读 ：</strong>  总是 读取最新的数据行，没有任何加锁，更新数据就会被读取到<br><strong>可串行化：</strong>  MVCC + Next-Key Lock（Record Lock + Gap Lock）所有 读取的行都加锁</p><h3 id="已提交读："><a href="#已提交读：" class="headerlink" title="已提交读："></a><strong>已提交读：</strong></h3><p>根据 MVCC 实现，事务每次查询开始时 都会生成一个独立的 ReadView<br>在数据库表中看到的一行记录可能有多个版本，每个版本记录除了有数据本身外，还有一个 表示版本的字段（row trx_id），它在事务开始的时候向事务系统申请，按时间先后顺序递增<br>已提交读是  每次执行语句时都重新生成一次快照，可重复读在事务开始的时候生成一个当前事务全局性的快照</p><p>一个快照能够读到那些版本数据，要遵循以下规则：<br>1.当前事务内的更新，可以读到；<br>2.版本 未提交，不能读到；<br>3.版本 已提交，但是却在快照创建后提交的，不能读到；<br>4.版本 已提交，且是在快照创建前提交的，可以读到；</p><p>已提交读-可重复读：主要区别是在快照的创建上，可重复读仅在事务开始时创建一次， 已提交读每次执行语句时都重新创建一次</p><h3 id="对于已提交读-—-可重复读区别："><a href="#对于已提交读-—-可重复读区别：" class="headerlink" title="对于已提交读-—-可重复读区别："></a>对于已提交读-—-可重复读区别：</h3><p>它们生成 ReadView的策略不同，已提交读每次查询时都会生成一个新的 ReadView，而可重复读每次查询都复用第一次生成的ReadView，ReadView中保存数据版本号。</p><h3 id="可重复读："><a href="#可重复读：" class="headerlink" title="可重复读："></a><strong>可重复读：</strong></h3><p>InnoDB 存储引擎中，<br>1.SELECT 操作的不可重复读问题 通过 MVCC 得到了解决；<br>2.UPDATE，DELETE 的不可重复读问题通过 Record Lock 解决<br>3.INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决<br>根据 MVCC实现，只会根据事务中第一次查询时生成的 ReadView </p><p><strong>MVCC：</strong> 多版本并发控制（Multi-Version Concurrency Control）<br>InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 已提交读、可重复读 这两种隔离级别。 </p><p>版本号：<br>**系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增</p><p>**事务版本号：事务开始时的系统版本号</p><p>隐藏的列： MVCC 在每行记录后面都保存着 两个隐藏的列，用来存储两个版本号</p><ul><li>创建版本号：指示 创建一个数据行的快照时的系统版本号；</li><li>删除版本号：如果该快照的 删除版本号 &gt; 当前事务版本号 表示该快照有效，否则表示该快照已经被删除</li></ul><p>MVCC 使用 快照存储在 Undo 日志中，该日志通过 回滚指针把一个数据行（Record）的所有快照连接起来</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwgdnb4cj60yi0bcwf602.jpg" alt="856A41D0-5919-46E6-8477-421AFA8595D8" width="450" height="180"   /><h3 id="快照读、当前读："><a href="#快照读、当前读：" class="headerlink" title="快照读、当前读："></a>快照读、当前读：</h3><p>问题：在可重复读级别中，通过 MVCC机制让数据变得可重复读，但读到的数据可能是历史数据，不是数据库当前的数据！<br>这在一些对于数据的 时效特别敏感 的业务中，可能出问题。<br>快照读： 读取历史数据； MVCC 的 select 操作是快照中的数据，不需要进行加锁操作。<br>当前读： 读取数据库当前版本数据； MVCC 对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行 加锁操作，从而读取最新的数据。</p><p>MVCC 也使用加锁，但是 避免了 SELECT 的加锁 , MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得 select不用加锁。<br>而 update，insert ，delete 这些 “当前读”的隔离性，就需要通过加锁来实现</p><p><strong>未提交读隔离级别：</strong>直接返回记录上的最新值，没有视图概念，也就是图中丙丙那一栏，脏读，幻读，不可重复读都有可能发生。</p><p><strong>串行化隔离级别：</strong> 直接用 加锁的方式来避免并行访问。 </p><p><strong>已提交读、可重复读这两种隔离级别使用了MVCC：</strong></p><p>事务在 执行普通的 SELECT操作， 访问记录版本链过程中，可以使不同事务的读-写，写-读操作并发执行，从而提升系统性能</p><p>RC，RR 隔离级别不同： RC 在每一次进行 普通 SELECT操作前都会生成一个ReadView；</p><p>RR 只在第一次进行普通 SELECT操作前生成一个ReadView，数据的可重复读其实就是 ReadView的重复使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;索引-事务&quot;&gt;&lt;a href=&quot;#索引-事务&quot; class=&quot;headerlink&quot; title=&quot;索引-事务&quot;&gt;&lt;/a&gt;索引-事务&lt;/h1&gt;&lt;h3 id=&quot;搜索引擎：&quot;&gt;&lt;a href=&quot;#搜索引擎：&quot; class=&quot;headerlink&quot; title=&quot;搜索引</summary>
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="Mysql" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/"/>
    
    
    <category term="Mysql" scheme="http://example.com/tags/Mysql/"/>
    
  </entry>
  
  <entry>
    <title>段/页式存储</title>
    <link href="http://example.com/2022/02/27/D-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8/"/>
    <id>http://example.com/2022/02/27/D-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8/</id>
    <published>2022-02-27T13:55:19.000Z</published>
    <updated>2022-04-19T13:03:10.226Z</updated>
    
    <content type="html"><![CDATA[<h1 id="段-x2F-页式存储"><a href="#段-x2F-页式存储" class="headerlink" title="段&#x2F;页式存储"></a>段&#x2F;页式存储</h1><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>​    在多进程环境下，为使进程之间的内存地址不受影响，相互隔离，操作系统为 每个进程独立分配一套 虚拟地址空间，每个程序只关心自己的虚拟地址，多进程通过 虚拟地址 映射到不同的物理地址内存。</p><p>​    作为程序，也不用关心物理地址的事情。每个进程都有自己的虚拟空间，而物理内存只有一个；当启用大量的进程，物理内存必然会很紧张，于是操作系统会通过 内存交换技术，把不常使用的内存暂时存放到硬盘 （换出），在需要时再装载回物理内存（换入）。</p><p>​    有了虚拟地址空间，必然要把 虚拟地址「映射」到 物理地址，这个事情通常由操作系统来维护，对于虚拟地址与物理地址的映射关系，可以有 分段，分页，段页的方式。访问虚拟地址时，由操作系统转换成不同的 物理地址，这样不同进程运行的时候，写入不同的物理地址，就不会冲突。</p><p>程序所使用的内存地址： <strong>虚拟内存地址</strong><br>实际存硬件里面的空间地址：<strong>物理内存地址</strong></p><h3 id="内存分段（Segmentation）"><a href="#内存分段（Segmentation）" class="headerlink" title="内存分段（Segmentation）"></a>内存分段（Segmentation）</h3><p>​    程序由若干个逻辑分段组成： 代码分段、数据分段、栈段、堆段；不同段 有不同的属性，用分段形式把这些段分离出来。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0omkxpj612e0rwjt702.jpg" alt="F3F67004-8E73-43E9-9085-55FD89A5D40D" width="750" height="500"/><h3 id="内存分段-寻址方式"><a href="#内存分段-寻址方式" class="headerlink" title="内存分段-寻址方式"></a>内存分段-寻址方式</h3><p><strong>段选择因子：</strong>保存在段寄存器里；</p><p><strong>段号：</strong>段表的索引，段表里面保存 段的基地址、段的界限和 特权等级等；</p><p><strong>段内偏移量：</strong>位于（0~段界限）；  </p><p>物理内存地址 &#x3D; 段基地址 + 段内偏移量； 虚拟地址：通过 段表与 物理地址映射，分段机制把程序的虚拟地址分成 4 个段，每个段在 段表中有一个项，在这一项找到段的基地址，再加上偏移量，就能找到物理内存中的地址。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0m9lzqj60tb0i376302.jpg" alt="255BA9F7-C651-478C-AC47-73750F6D3619" width="600" height="350" /><h3 id="段式存储问题：-1-内存碎片；2-内存交换的效率低"><a href="#段式存储问题：-1-内存碎片；2-内存交换的效率低" class="headerlink" title="段式存储问题： 1.内存碎片；2.内存交换的效率低"></a><strong>段式存储问题：</strong> 1.内存碎片；2.内存交换的效率低</h3><h4 id="1-内存锁片："><a href="#1-内存锁片：" class="headerlink" title="1.内存锁片："></a>1.内存锁片：</h4><p><strong>外部内存碎片：</strong>在物理内存中产生多个 不连续的小物理内存，导致 新的程序无法被装载；<br><strong>内部内存碎片：</strong>程序所有的内存都被装载到物理内存，但程序 有部分的内存 可能并不是很常使用，这也会导致内存的浪费；</p><p><strong>内存交换：</strong>解决–外部内存碎片问题<br>        把一个程序占用的 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回时，不装载回原来位置，而是紧紧跟在已经被占用的 512MB 内存后面。这样就 就使得空间利用连续，避免内存碎片产生。</p><h4 id="2-内存交换的效率低："><a href="#2-内存交换的效率低：" class="headerlink" title="2.内存交换的效率低："></a>2.内存交换的效率低：</h4><p>​        内存交换空间在 Linux 系统里就是 Swap 空间，这块 空间是从硬盘划分出来，用于内存与硬盘的空间交换<br>对于多进程系统，内存碎片很容易产生，需要经常进行 内存交换操作，但Swap空间是硬盘，有性能瓶颈；硬盘访问速度比内存慢很多，每次内存交换都需要把 一大段连续的内存数据写到硬盘上。如果内存交换时，交换占内存空间很大的程序，整个机器都会卡顿。</p><h3 id="内存分页："><a href="#内存分页：" class="headerlink" title="内存分页："></a><strong>内存分页：</strong></h3><p>解决 内存碎片，内存交换效率低；把整个 虚拟，物理内存空间切成一段段 固定尺寸的大小-页（Page）：一个连续并尺寸固定的内存空间，Linux 一页大小 4KB。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0jfow0j60tn0m575h02.jpg" alt="5724EB13-9A0A-4AA4-9C44-043EA8D0D3D0" width="600" height="450" /><p>虚拟地址分为： 页号，页内偏移<br><strong>页号：</strong> 页表的索引，页表包含 物理页每页所在 物理内存的基地址，物理内存地址 &#x3D;  基地址 与 页内偏移的组合<br>内存分页寻址过程：<br>1.把虚拟内存地址，切分成 页号，偏移量<br>2.根据页号，从 页表里查询对应的物理页号<br>3.直接拿 物理页号 + 偏移量，得到 物理内存地址</p><p>**内存空间： **预先划分好，不像分段那样产生 间隙非常小的内存，这正是分段会产生内存碎片的原因。释放的内存都是以页为单位释放的，也不会产生无法给进程使用的小内存。<br>**页表： **存储在 CPU 内存管理单元 （MMU） 中；  CPU 可以直接 通过 MMU 找出实际要访问的 物理内存地址。<br>当 进程访问的虚拟地址在页表中查不到时，系统会产生：缺页异常<br><strong>解决：</strong> 进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0h4ljqj61320nt76302.jpg" alt="C547F405-C521-41CA-AA71-DD30DC86D94F" width="650" height="350" /><p>​    如果内存空间不够，操作系统会把 其他正在运行的进程中的「最近没被使用LRU」的 内存页面换出（Swap Out）， 暂时写在硬盘上；需要时再加载进来，称为换入（Swap In）。一次性写入磁盘只有少数一个页或几个页，不会花太多时间，内存交换效率相对比较高。<br>​    分页方式在加载程序时，不需要一次性把程序加载到物理内存中。在虚拟内存 和物理内存的页映射之后，并不真的把页加载到物理内存里，而 只有在 程序运行中，需要用到对应虚拟内存页里面的 指令和数据时，再加载到 物理内存里面去。</p><h3 id="页式存储空间上的缺陷："><a href="#页式存储空间上的缺陷：" class="headerlink" title="页式存储空间上的缺陷："></a>页式存储空间上的缺陷：</h3><p>操作系统可以同时运行非常多的进程，意味着页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，一个页大小 4KB，就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，整个 4GB 空间的映射就需要有 4MB 内存来存储页表。每个进程都是有自己的虚拟地址空间，如果有 100 个进程的话，就需要 400MB 内存来存储页表，这是非常大的内存，而 64 位环境则会更大。</p><p><strong>多级页表  解决：</strong>多进程页表占用空间过大问题<br>使用 二级分页，一级页表 就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表，即可以在需要时才创建二级页表。例如：假设只有 20% 一级页表项被用到，那么页表占用内存空间就只有  4KB（一级页表）+  20% * 4 MB（二级页表）&#x3D; 0.804MB</p><h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>​    每个进程有 4GB 虚拟地址空间，对于大多数程序来说，其使用的空间远未达到4GB，因为会有部分对应的页表项都是空的，没有分配，对于已分配的页表项，如果是最近一段时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，不会占用物理内存。</p><h4 id="程序的局部性"><a href="#程序的局部性" class="headerlink" title="程序的局部性"></a><strong>程序的局部性</strong></h4><p>​    把常访问的 几个页表项存储到访问速度更快的硬件，在 CPU 芯片中加入一个专门存放 程序最常访问的 页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为：页表缓存、转址旁路缓存、快表等。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0ern33j60s00e53zb02.jpg" alt="F2665293-6C21-4F33-8C0D-16EA3F0A15E9" width="600" height="300" /><h4 id="地址转换："><a href="#地址转换：" class="headerlink" title="地址转换："></a>地址转换：</h4><p>在 CPU 芯片里封装了 内存管理单元（Memory Management Unit）芯片，它用来完成 地址转换和 TLB 的访问与交互。CPU 在寻址时，会先查 TLB，如果没找到，才继续查常规的页表。TLB 命中率其实是很高的，因为程序最常访问的页就那几个 。</p><h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><p>内存分段和内存分页并不是对立的，它们可以组合起来在同一个系统中使用，组合后称为：段页式内存管理<br><strong>段页式内存管理：</strong><br>1.先将程序划分为 多个有逻辑意义的段<br>2.再把 每个段划分为 多个页，对分段划分出来的连续空间，再划分 固定大小的页<br>这样地址结构就由 段号、段内页号，页内位移 三部分组成。用于 段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址 是 页表的起始地址，而 页表中的地址是 某页的物理页号 </p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0blh3cj614c0jfac602.jpg" alt="431DF29B-F743-4129-B9C7-377E6C0D1DE8" width="600" height="300" /><h3 id="段页式地址–-gt-物理地址过程："><a href="#段页式地址–-gt-物理地址过程：" class="headerlink" title="段页式地址–&gt;物理地址过程："></a><strong>段页式地址–&gt;物理地址过程：</strong></h3><p>1.访问段表，得到页表起始地址<br>2.访问页表，得到物理页号<br>3.将物理页号 + 页内位移 组合，得到物理地址</p><p>Linux 虚拟地址和物理地址映射方式：<br>Linux 系统中，每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位），所有段的起始地址都是一样的。Linux 系统中的代码，包括操作系统本身的代码和 应用程序代码，所面对的 地址空间都是线性地址空间（虚拟地址），相当于屏蔽处理器中的 逻辑地址概念，段只被用于 访问控制和内存保护。<br>Linux 本身采用的实际是段式和页式都有，但不叫段页式； linux的段和页式顺序的两个过程，只不过 段式相当于啥也不干，目的是为了保证兼容性，所以 Linux内存管理的方式实际上相当于 只有页式管理，但查询过程 经过一层段式查询。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>内存分段：</strong><br>根据程序逻辑角度，分成 栈段、堆段、数据段、代码段 等，分离出不同属性的段，同时是一块连续的空间。<br>每个段的 大小都不是统一的，这会导致 内存碎片，内存交换效率低 的问题。<br>于是出现：内存分页<br>把 虚拟空间和 物理空间分成 大小固定的页，在 Linux 系统中每一页大小为 4KB。<br>1.分页后就不会 产生细小的内存碎片。<br>2.在内存交换时，写入硬盘是 一个页或几个页，提高内存交换的效率。<br>多级页表：为解决 简单分页产生页表过大 问题，但会导致 CPU 在寻址过程中，需要 有很多层表参与，加大时间上的开销。<br>根据程序局部性原理，在 CPU 芯片中加入了 Cache 就是TLB（Translation Lookaside Buffer），负责 缓存最近常被访问的页表项，来提高 地址的转换速度。<br>Linux 系统主要采用 分页管理，但由于 Intel 处理器的发展史，Linux 系统无法避免 分段管理。于是 Linux 把所有 段的基地址设为 0，所有程序的地址空间都是 线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。<br>另外，Linxu 系统中 虚拟空间分布可分为用户态和内核态两部分，用户态：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p><p>参考：</p><p>Linux 段页存储：  <a href="https://blog.csdn.net/jinking01/article/details/107098437">https://blog.csdn.net/jinking01/article/details/107098437</a></p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;段-x2F-页式存储&quot;&gt;&lt;a href=&quot;#段-x2F-页式存储&quot; class=&quot;headerlink&quot; title=&quot;段&amp;#x2F;页式存储&quot;&gt;&lt;/a&gt;段&amp;#x2F;页式存储&lt;/h1&gt;&lt;h3 id=&quot;背景：&quot;&gt;&lt;a href=&quot;#背景：&quot; class=&quot;head</summary>
      
    
    
    
    <category term="操作系统" scheme="http://example.com/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
