<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TurboCome</title>
  
  <subtitle>Wang Hongqiang</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-06-15T13:36:00.048Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>TurboCome</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>研究生科研总结</title>
    <link href="http://example.com/2022/06/15/Z-%E9%9A%8F%E7%AC%94/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%A7%91%E7%A0%94%E6%80%BB%E7%BB%93/"/>
    <id>http://example.com/2022/06/15/Z-%E9%9A%8F%E7%AC%94/%E7%A0%94%E7%A9%B6%E7%94%9F%E7%A7%91%E7%A0%94%E6%80%BB%E7%BB%93/</id>
    <published>2022-06-15T08:28:19.000Z</published>
    <updated>2022-06-15T13:36:00.048Z</updated>
    
    <content type="html"><![CDATA[<h2 id="研究生科研工作总结"><a href="#研究生科研工作总结" class="headerlink" title="研究生科研工作总结"></a>研究生科研工作总结</h2><h3 id="一、-整体经验分享："><a href="#一、-整体经验分享：" class="headerlink" title="一、 整体经验分享："></a>一、 整体经验分享：</h3><p>1.首先要多看论文，多找一些相关性较强的论文，感觉可以有改进，就把文章进行详细的解析，包括公式，模型可以考虑在本子上写下来，一点一点推导研究，在模型中寻找改进的点。</p><p>2.找相关文章时，最好挑选一些高质量的论文，英文的，IEEE、ACM等会议论文，做改进。</p><p>3.在挑选对比算法时，一定要找相关性强的算法，要是你所做方面的。比如：资源分配，要找大背景是卫星网络的，在卫星网络下所做的资源分配。另外，挑选对比算法时尽量找新的算法，最好是近3年的。</p><p>4.大论文：围绕自己的创新点来写，特别是相关研究部分。在介绍相关算法时，明确阐述前人没做好的方面，自己改进的地方，在其他人的基础上的创新，优势有哪些。</p><p>5.提早发小论文，尽量发一些高质量的，这样对自己以后答辩时是有优势的，后边有更多的时间来准备找工作，考公等。</p><p>6.要勤于思考，看论文的时候，不必局限于卫星通信领域，可以考虑针对自己的领域，在整个业内有哪些处理方式。</p><p>比如：我做的基于任务拆分资源分配，传统都是在卫星下研究如何对任务进行拆分的，在找创新点时，可以单独把任务拆分拿出来，调研一下任务拆分都在哪些领域有使用，去找相关论文，再结合卫星网络的背景特点，看看是否有改进的地方，以此寻找创新。</p><h3 id="二、每个时间节点的完成内容："><a href="#二、每个时间节点的完成内容：" class="headerlink" title="二、每个时间节点的完成内容："></a>二、每个时间节点的完成内容：</h3><p>1.研二上学期，尽量多阅读相关论文，调研自己的研究方向，最新的研究进展。</p><p>2.研二下学期，在自己的研究方向上寻找一个创新点，发一篇专利。</p><p>3.研三上学期，根据已发的专利，撰写小论文，争取发一篇高水平的学术论文。如有额外精力，可以根据新的创新点，发第二篇专利。</p><p>4.研三下学期，撰写大论文。</p><h3 id="三、答辩经验："><a href="#三、答辩经验：" class="headerlink" title="三、答辩经验："></a>三、答辩经验：</h3><p>1.对自己所做的研究内容，一定要特别熟悉。包括：背景，解决的问题，相关研究，对比算法等。答辩老师主要是围绕你的工作进行展开，提问的。</p><p>2.不要顶撞老师，如果老师说你哪方面没做好，积极回应，说后续进行改进。</p><p>3.对于盲审意见，包括修改建议、质询问题，都要在答辩PPT上体现，并做详细的解答。这些内容答辩老师会额外关注。</p><p>4.答辩时需要携带各种资料，事前一定要把各种资料填写完整，不要遗漏。</p><p>5.答辩PPT有时间限制，老师们都很反感过长的PPT，事前可以模拟一下，尽量控制在15分钟以内，避免超时。</p><h3 id="四、个人总结："><a href="#四、个人总结：" class="headerlink" title="四、个人总结："></a>四、个人总结：</h3><p>​    时光荏苒，转瞬即逝，转眼之间，三年的硕士生活即将结束。朦胧间，我还清晰的记得，第一天踏进校园，在细雨蒙蒙的苏州独墅湖旁的那一幕。一晃已是三年，有些时候曾后悔自己的选择，但迫于现实的压力也让我不得不做出选择。曾和老师们聊过这些话题，然而他们却把问题看的很淡，他们给我的答复是要把更多的心思放在个人的能力上，而不是出身、曾经。既然你已经选择了，就要勇于去面对，为你的选择负责，更要为你以后的人生负责。你曾经拥有的一切，或许仅能给你提供一个平台，这个平台无论高低也仅此而已，至于以后的一切，能走多高、多远，完全取决于以后的你。我深刻的记得孔老师对我说的那句话：“一个优秀的人，无论做什么都会很优秀！”。这句话让我想了很多，也让我明白了很多。以后的路还很长，很远，很多时候我都在怀疑自己选择的路是对是错，但后来，慢慢的我明白了一个道理，你若是一个优秀的人，无论走哪条路都不会太差！正逢毕业之际，身边的同学各奔东西，有的去了外企，有的去了银行，有的去了公务员。回首间有些羡慕，也有些对自己未来的担忧。这可能是从学校到社会的过度期，那种恐慌吧，但这又能怎么样呢？每个人都要经历的，我也不会例外。生活的齿轮永不停息的向前滚动着，每个人都在时时刻刻的现场直播，如果你不想埋没在茫茫人海中，那请你以一种高傲的态度来看待以后的点点滴滴！</p><p>​    路漫漫其修远兮，吾将上下而求索！未来道路漫长，勿忘初心，做好自己，加油小强！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;研究生科研工作总结&quot;&gt;&lt;a href=&quot;#研究生科研工作总结&quot; class=&quot;headerlink&quot; title=&quot;研究生科研工作总结&quot;&gt;&lt;/a&gt;研究生科研工作总结&lt;/h2&gt;&lt;h3 id=&quot;一、-整体经验分享：&quot;&gt;&lt;a href=&quot;#一、-整体经验分享：&quot; cla</summary>
      
    
    
    
    <category term="随笔" scheme="http://example.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
    <category term="随笔" scheme="http://example.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>DFS版0-1背包问题</title>
    <link href="http://example.com/2022/05/10/Y-LeetCode/M-DFS/4.0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/10/Y-LeetCode/M-DFS/4.0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-10T13:55:19.000Z</published>
    <updated>2022-04-20T11:22:48.670Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://ac.nowcoder.com/acm/problem/207796">https://ac.nowcoder.com/acm/problem/207796</a><br>有 n个物品，每个物品有一个体积  v[i] ，重量  g[i], 选择其中总体积恰好为 V的若干个物品，最大总重量为多少？<br>（如果不存在合法方案，返回-1）</p><p>输入： v &#x3D; [1,2,3]； g &#x3D; [2,3,4]； V &#x3D; 3<br>输出： 5</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Maximumweight</span> <span class="params">(<span class="type">int</span>[] v, <span class="type">int</span>[] g, <span class="type">int</span> V)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> DFS(V, v, g, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> V, <span class="type">int</span>[] v, <span class="type">int</span>[] g, <span class="type">int</span> id, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(V==<span class="number">0</span>) <span class="keyword">return</span> item;</span><br><span class="line">    <span class="keyword">if</span>(V&lt;<span class="number">0</span> || id==v.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> DFS(V,   v, g, id+<span class="number">1</span>, item);     <span class="comment">// id 物品不要</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> DFS(V-v[id],   v, g, id+<span class="number">1</span>, item+g[id]); <span class="comment">// id 物品要</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链接：&lt;a href=&quot;https://ac.nowcoder.com/acm/problem/207796&quot;&gt;https://ac.nowcoder.com/acm/problem/207796&lt;/a&gt;&lt;br&gt;有 n个物品，每个物品有一个体积  v[i] ，重量  g[i</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>全排列_46/47</title>
    <link href="http://example.com/2022/05/09/Y-LeetCode/M-DFS/1.%E5%85%A8%E6%8E%92%E5%88%97_4647/"/>
    <id>http://example.com/2022/05/09/Y-LeetCode/M-DFS/1.%E5%85%A8%E6%8E%92%E5%88%97_4647/</id>
    <published>2022-05-09T13:55:19.000Z</published>
    <updated>2022-04-20T11:11:02.066Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个 **<em>*没有重复 数字*<em>的序列，返回其所有可能的全排列。</em></em></p><p>输入: [1,2,3]<br>输出:</p><p>[[1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1] ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    int l=nums.length;</span><br><span class="line">    if(l==0) return new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;lists=new ArrayList&lt;&gt;();</span><br><span class="line">    for(int v:nums) lists.add(v);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; item=new ArrayList&lt;&gt;();</span><br><span class="line">    DFS(lists, item);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>47</p><p>给定一个 <strong><em>*可包含重复数字的序列 nums*</em> ，按任意顺序 返回所有不重复的全排列。</strong></p><p>输入：nums &#x3D; [1,1,2]<br>输出：<br>[[1,1,2],<br>[1,2,1],<br>[2,1,1]]</p><p>输入：nums &#x3D; [1,2,3]<br>输出：[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] ]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">private Set&lt;List&lt;Integer&gt;&gt; res=new HashSet&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0) return new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt;lists = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int v:nums) lists.add(v);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;item = new ArrayList&lt;&gt;();</span><br><span class="line">    DFS2(lists, item);</span><br><span class="line">    return new ArrayList&lt;&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void DFS2(List&lt;Integer&gt; lists, List&lt;Integer&gt; item) &#123;</span><br><span class="line">    if(lists.size()==0)&#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(item));</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int id=0;id&lt;lists.size();id++)&#123;</span><br><span class="line">        int v=lists.get(id);</span><br><span class="line">        lists.remove(id);</span><br><span class="line">        item.add(v);</span><br><span class="line"></span><br><span class="line">        DFS2(lists, item);</span><br><span class="line"></span><br><span class="line">        lists.add(id,v);</span><br><span class="line">        item.remove(item.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个 **&lt;em&gt;*没有重复 数字*&lt;em&gt;的序列，返回其所有可能的全排列。&lt;/em&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;输入: [1,2,3]&lt;br&gt;输出:&lt;/p&gt;
&lt;p&gt;[[1,2,3],&lt;br&gt; [1,3,2],&lt;br&gt; [2,1,3],&lt;br&gt; [2,3,1],&lt;br&gt; </summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>岛屿数量</title>
    <link href="http://example.com/2022/05/09/Y-LeetCode/M-DFS/2.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/"/>
    <id>http://example.com/2022/05/09/Y-LeetCode/M-DFS/2.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</id>
    <published>2022-05-09T13:55:19.000Z</published>
    <updated>2022-04-20T11:13:24.331Z</updated>
    
    <content type="html"><![CDATA[<p>输入：<br>[[1,1,0,0,0],<br>[0,1,0,1,1],<br>[0,0,0,1,1],<br>[0,0,0,0,0],<br>[0,0,1,1,1] ]</p><p>返回值：3</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length, col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=grid.length || j&lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].length || grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i-<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;输入：&lt;br&gt;[[1,1,0,0,0],&lt;br&gt;[0,1,0,1,1],&lt;br&gt;[0,0,0,1,1],&lt;br&gt;[0,0,0,0,0],&lt;br&gt;[0,0,1,1,1] ]&lt;/p&gt;
&lt;p&gt;返回值：3&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;ta</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>整数二进制拆解-Pow50</title>
    <link href="http://example.com/2022/05/09/Y-LeetCode/M-DFS/3.%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E8%A7%A3-Pow50/"/>
    <id>http://example.com/2022/05/09/Y-LeetCode/M-DFS/3.%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E8%A7%A3-Pow50/</id>
    <published>2022-05-09T13:55:19.000Z</published>
    <updated>2022-04-20T11:15:27.769Z</updated>
    
    <content type="html"><![CDATA[<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p><p>输入: 2.00000, 10<br>输出: 1024.00000</p><p>输入: 2.10000, 3<br>输出: 9.26100</p><p>输入: 2.00000, -2<br>输出: 0.25000</p><p>解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25<br>说明:<br>-100.0 &lt;  x  &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] </p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>把指数 n n 做「二进制分解」，在底数不断自身乘以自身的过程中，将最终结果需要的部分保存下来</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gegtwt4tj20hq05tt91.jpg" alt="FA5A6E3C-3205-45CD-B1F3-01A343C29506"  /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span>? fun2(x,N) : <span class="number">1.</span>/fun2(x,-N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> fun(x*x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x*fun(x*x, n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1.</span>/x;</span><br><span class="line">            m = -m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">1</span>) res *= x;  <span class="comment">//碰到1，res扩展</span></span><br><span class="line">            m = m/<span class="number">2</span>;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;实现 pow(x, n) ，即计算 x 的 n 次幂函数。&lt;/p&gt;
&lt;p&gt;输入: 2.00000, 10&lt;br&gt;输出: 1024.00000&lt;/p&gt;
&lt;p&gt;输入: 2.10000, 3&lt;br&gt;输出: 9.26100&lt;/p&gt;
&lt;p&gt;输入: 2.00000, -2&lt;br&gt;输出:</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="DFS" scheme="http://example.com/categories/LeetCode/DFS/"/>
    
    
    <category term="DFS" scheme="http://example.com/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>字符串相加</title>
    <link href="http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/"/>
    <id>http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</id>
    <published>2022-05-08T13:55:19.000Z</published>
    <updated>2022-04-20T11:02:06.595Z</updated>
    
    <content type="html"><![CDATA[<h4 id="字符串形式实现数字相加"><a href="#字符串形式实现数字相加" class="headerlink" title="字符串形式实现数字相加"></a>字符串形式实现数字相加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;  <span class="comment">//进位</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] chs=s.toCharArray(), cht=t.toCharArray();</span><br><span class="line">    <span class="type">int</span> l1=s.length(), l2=t.length();</span><br><span class="line">    <span class="type">int</span> i=l1-<span class="number">1</span>, j=l2-<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + chs[i]-<span class="string">&#x27;0&#x27;</span> + cht[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + chs[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + cht[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) res.append(carry); <span class="comment">//记录最后进位值</span></span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;字符串形式实现数字相加&quot;&gt;&lt;a href=&quot;#字符串形式实现数字相加&quot; class=&quot;headerlink&quot; title=&quot;字符串形式实现数字相加&quot;&gt;&lt;/a&gt;字符串形式实现数字相加&lt;/h4&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长递增子序列</title>
    <link href="http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-05-08T13:55:19.000Z</published>
    <updated>2022-04-20T11:03:11.954Z</updated>
    
    <content type="html"><![CDATA[<p>寻找一个字符串中的 <strong>最长递增子序列</strong></p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.对 <strong>字符串按字母排序</strong><br>2.排序后的字符串，和 原字符串的 *<strong>*最长公共子*</strong>*序列****，即为所求的 <strong>字符串中最长递增子序列</strong></p><p>In:  bacdgat;  aabcdgt<br>Out:  acdgt</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums_i = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> l=nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp= <span class="keyword">new</span> <span class="title class_">int</span>[l+<span class="number">1</span>][l+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums_i[i-<span class="number">1</span>]==nums[j-<span class="number">1</span>] ) dp[i][j] =dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l][l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;寻找一个字符串中的 &lt;strong&gt;最长递增子序列&lt;/strong&gt;&lt;/p&gt;
&lt;h4 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h4&gt;&lt;p&gt;1.对 &lt;strong&gt;字符串按字母排序&lt;/st</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子串-公共子序列</title>
    <link href="http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-05-08T13:55:19.000Z</published>
    <updated>2022-04-20T11:07:58.338Z</updated>
    
    <content type="html"><![CDATA[<p>最长公共子串：字串要保证连续</p><p>s1[i] ，s2[j] 表示以 s1 以下标 i 结尾， s2 以下标 j 结尾<br>dp(i)(j) 表示分别以s1[i], s2[j] 结尾的 公共子串的长度<br>dp(0)(j)&#x3D;0, dp(i)(0) &#x3D;0;</p><p>1.s1[i-1]!&#x3D;s2[j-1]    dp(i)(j)&#x3D; 0     当前位置不等，子串要连续，则此位置&#x3D;&#x3D;0<br>2.s1[i-1]&#x3D;&#x3D;s2[j-1]   dp(i)(j)&#x3D;dp(i-1)(j-1)+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 2 个字符串中的最长公共子串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonSubstring</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1=s1.length(),l2=s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> max_v=<span class="number">0</span>, start_id=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l2;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(max_v&lt;dp[i][j])&#123;</span><br><span class="line">                    max_v=dp[i][j];</span><br><span class="line">                    start_id=i-max_v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.substring(start_id,start_id+max_v);</span><br></pre></td></tr></table></figure><h4 id="求最长公共子序列：可以不是连续的"><a href="#求最长公共子序列：可以不是连续的" class="headerlink" title="求最长公共子序列：可以不是连续的"></a><strong>求最长公共子序列：可以不是连续的</strong></h4><p>1.s1[i-1]!&#x3D;s2[j-1]  dp(i)(j) &#x3D; Math.max(dp(i-1)(j) , dp(i)(j-1) ) 当前位置不等，依次 -1 看 <strong>其他子序列是否相等，取最大</strong> </p><p>2.s1[i-1]&#x3D;&#x3D;s2[j-1]  dp(i)(j)&#x3D;dp(i-1)(j-1)+1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求 2 个字符串中的最长公共子序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonLxlie</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1=s1.length(), l2=s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_v=<span class="number">0</span>, start_id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l2;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>)) dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]= Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最长公共子串：字串要保证连续&lt;/p&gt;
&lt;p&gt;s1[i] ，s2[j] 表示以 s1 以下标 i 结尾， s2 以下标 j 结尾&lt;br&gt;dp(i)(j) 表示分别以s1[i], s2[j] 结尾的 公共子串的长度&lt;br&gt;dp(0)(j)&amp;#x3D;0, dp(i)(0) &amp;#</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>重复子串_459</title>
    <link href="http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2_459/"/>
    <id>http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2_459/</id>
    <published>2022-05-07T13:55:19.000Z</published>
    <updated>2022-04-20T10:56:03.165Z</updated>
    
    <content type="html"><![CDATA[<p>非空的字符串，判断它是否可以由它的一个 <strong>子串重复多次构成,</strong>  字符串只含小写英文字母，并且长度不超过10000</p><p>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p><p>输入: “aba”<br>输出: False</p><p>输入: “abc abc abc abc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成，(或者子字符串 “abcabc” 重复两次构成。)</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>for (1 ~ len(s)&#x2F;2)  所有 子字符串（从index&#x3D;0开始取）<br>所取 <strong>子字符串 * 切片数  len(s) &#x2F;&#x2F; i ,</strong> 得到的字符串若和 原字符串相等，则返回 True<br>判断 2个str的值相等:   str1.equals(str2)<br>地址相等： str1&#x3D;&#x3D;str2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(String s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.length()/<span class="number">2</span> ; i&gt;<span class="number">0</span>; i—)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> s.length()/i;    <span class="comment">//切片的数量</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp_s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="comment">// 拼接形成 new 字符串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; k; j++) tmp_s.append( s.substring(<span class="number">0</span>,i));</span><br><span class="line">            <span class="keyword">if</span>( String.valueOf(tmp_s).equals(s) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;非空的字符串，判断它是否可以由它的一个 &lt;strong&gt;子串重复多次构成,&lt;/strong&gt;  字符串只含小写英文字母，并且长度不超过10000&lt;/p&gt;
&lt;p&gt;输入: “abab”&lt;br&gt;输出: True&lt;br&gt;解释: 可由子字符串 “ab” 重复两次构成。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>最大回文子串-回文子序列</title>
    <link href="http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/"/>
    <id>http://example.com/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</id>
    <published>2022-05-07T13:55:19.000Z</published>
    <updated>2022-04-20T11:00:29.117Z</updated>
    
    <content type="html"><![CDATA[<p><strong>回文子串： boolean(len)(len) dp  ;   回文序列：  int(len)(len) dp</strong></p><p>回文：</p><p>for(int i&#x3D;len-1; i&gt;&#x3D;0; i–){</p><p>  for(int j&#x3D;i; j&lt;len; j++){</p><p>字符串中最长的回文子串：</p><p>Input: “babad”<br>Output: “bab”&#x2F; “aba” </p><p>Input: “cbbd”<br>Output: “bb”</p><h4 id="思路：（动态规划）"><a href="#思路：（动态规划）" class="headerlink" title="思路：（动态规划）"></a>思路：（动态规划）</h4><p>核心思想就是两个字“延伸”</p><p>在一个 <strong>不是回文字符串的字符串两端添加任何字符，或者在回文串左右分别加不同的字符，得到的一定不是回文串</strong></p><p>dp(i)(j):  表示 <strong>从 i 到 j 是否可以形成回文</strong><br>dp(i)(j)&#x3D; ( s.charAt(i)&#x3D;&#x3D;s.charAt(j) ) &amp;&amp; (j-i&lt;3 || dp(i+1)(j-1) );</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l][l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;l; j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)) dp[i][j] = (j-i&lt;<span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) ;</span><br><span class="line">            <span class="keyword">if</span>( dp[i][j] &amp;&amp; res.length()&lt;j-i+<span class="number">1</span> ) res=s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字符串 s ，找到其中<strong>最长的回文子序列，并返回该序列的长度。</strong></p><p>输入:  “bbbab”<br>输出:  4  ；一个可能的最长回文子序列为 “bbbb”</p><p>输入:  “cbbd”<br>输出:  2  ；一个可能的 最长回文子序列为 “bb”</p><h4 id="思路：DP"><a href="#思路：DP" class="headerlink" title="思路：DP"></a>思路：DP</h4><p>dp(i)(j): i 左 j 右， <strong>从 s[i] – s[j] 此字符串内， 最长的回文子序列</strong></p><p>if s[i] &#x3D;&#x3D; s[j] :  dp(i)(j) &#x3D; dp(i+1)(j-1) + 2;<br>else dp(i)(j) &#x3D; max( dp(i+1)(j), dp(i)(j-1) )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[ len ][ len ];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;len; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从下往上遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="comment">// 那么就说明在原先的基础上又增加了回文子序列的长度</span></span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表明这时 dp[i][j]只需取两者之间的 最大值即可</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;回文子串： boolean(len)(len) dp  ;   回文序列：  int(len)(len) dp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回文：&lt;/p&gt;
&lt;p&gt;for(int i&amp;#x3D;len-1; i&amp;gt;&amp;#x3D;0; i–){&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>不重复的子串_3</title>
    <link href="http://example.com/2022/05/06/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E4%B8%B2_3/"/>
    <id>http://example.com/2022/05/06/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E4%B8%B2_3/</id>
    <published>2022-05-06T13:55:19.000Z</published>
    <updated>2022-04-20T10:52:56.464Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h4><p>Input:  “abc abcbb”<br>Output:  3</p><p>思路：（双指针）<br>fast 前， slow 后, 保证此区间内不重复，用Map（） 走过的记录字符<br>保存临时子串 ： tmp_l，依次判断 s[fast] 是否在 tmp_l 中 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=s.length();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( l&lt;r &amp;&amp; map.containsKey(s.charAt(r)))</span><br><span class="line">            <span class="comment">// aabaab!bb , 在 slow=4, a 时,map.get(b)+1 = 3, 会出现更小的数值，此处可以保证 slow 一直向前走</span></span><br><span class="line">            l= Math.max( l, map.get(s.charAt(r))+<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        map.put(s.charAt(r), r);</span><br><span class="line">        res= Math.max(res, r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最长不重复子串&quot;&gt;&lt;a href=&quot;#最长不重复子串&quot; class=&quot;headerlink&quot; title=&quot;最长不重复子串&quot;&gt;&lt;/a&gt;最长不重复子串&lt;/h4&gt;&lt;p&gt;Input:  “abc abcbb”&lt;br&gt;Output:  3&lt;/p&gt;
&lt;p&gt;思路：（双指针）&lt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="字符串" scheme="http://example.com/categories/LeetCode/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
    <category term="字符串" scheme="http://example.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>3个数的和_15</title>
    <link href="http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/1.3%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C_15/"/>
    <id>http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/1.3%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C_15/</id>
    <published>2022-05-05T13:55:19.000Z</published>
    <updated>2022-04-20T10:42:09.074Z</updated>
    
    <content type="html"><![CDATA[<p><strong>双指针</strong></p><p>一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？<br>找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p><p>nums &#x3D; [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[[-1, 0, 1],<br> [-1, -1, 2]]</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>外循环<strong>先固定一个数</strong>，在此数之后，用双指针左（i+1）右（l-1），向中间聚，依次扫描<br>枚举数组中的两个元素时，如果发现随着<strong>第一个元素的递增，第二个元素是递减的</strong>，那么就可以使用双指针的方法，<br>将枚举的时间复杂度从 O(N^2) 减少至 O(N)这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但它一共会移动的位置数为 O(N)，每次也向左移动一个位置，因此时间复杂度为 O(N)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt; List&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;len-<span class="number">2</span>; id++)&#123;</span><br><span class="line">        <span class="comment">// 固定好 id，一个数</span></span><br><span class="line">        <span class="keyword">if</span>(nums[id]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">0</span> &amp;&amp; nums[id]==nums[id-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l=id+<span class="number">1</span>, r=len-<span class="number">1</span>;  <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">while</span>( l&lt;r )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[id]+ nums[l]+  nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( Arrays.asList(nums[id],nums[l],nums[r])) );</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==nums[++l]);  <span class="comment">// 无论是否相等，保证 l+1 前进</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==nums[--r]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==nums[++l]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==nums[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;双指针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &amp;#x3D; 0 ？&lt;br&gt;找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。&lt;/p</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="指针" scheme="http://example.com/categories/LeetCode/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>3个数的和_15</title>
    <link href="http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/2.%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/2.%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-05T13:55:19.000Z</published>
    <updated>2022-04-20T10:51:38.296Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。<br>具体请参考样例解释<br><strong>示例1</strong><br>Input: <strong>[3,1,2,5,2,4]</strong><br>Output:  5</p><p>思路：</p><p>左右夹击， 左侧记录一个最大值，右侧记录一个最大值；<br>遇到比其lmax, rmax 小的数，+ 差值;<br>遇到比其lmax, rmax 大的数， 替换更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxWater</span> <span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">     <span class="type">int</span> l=<span class="number">0</span>, r=len-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> lmax=arr[l], rmax=arr[r];</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">         lmax = Math.max(lmax, arr[l]);</span><br><span class="line">         rmax = Math.max(rmax, arr[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lmax &lt; rmax)&#123;</span><br><span class="line">           res +=(lmax - arr[l]);</span><br><span class="line">             l++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           res +=(rmax - arr[r]);</span><br><span class="line">             r--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。&lt;br&gt;具体请参考样例解释&lt;br&gt;&lt;strong&gt;示例1&lt;/strong&gt;&lt;br&gt;Input: &lt;strong&gt;[3,1,2,5,2,4]&lt;/strong&gt;&lt;br&gt;Output</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="指针" scheme="http://example.com/categories/LeetCode/%E6%8C%87%E9%92%88/"/>
    
    
    <category term="指针" scheme="http://example.com/tags/%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>二为矩阵顺时针打印</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/3.%E4%BA%8C%E4%B8%BA%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/3.%E4%BA%8C%E4%B8%BA%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:23:42.212Z</updated>
    
    <content type="html"><![CDATA[<p>四步：</p><p>1.从左到右<br>2.从上到下<br>3.从右到左<br>4.从下到上</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>row_s 行 开始， row 行 结束<br>col_s 列 开始，  col 列 结束<br>While(T)  单独判断跳出条件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder( <span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0, len-1;   保持后续 &lt;= , &gt;= 的统一形式</span></span><br><span class="line">    <span class="type">int</span> row_s=<span class="number">0</span>, col_s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length-<span class="number">1</span>, col=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[( row+<span class="number">1</span>)*(col+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 列开始，列结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col_s; i&lt;=col; i++) res[id++] = matrix[ row_s][i];</span><br><span class="line">        row_s++; <span class="comment">// 行开始➕1</span></span><br><span class="line">        <span class="keyword">if</span>(row_s&gt; row) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 行开始，行结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row_s; i&lt;=row; i++) res[id++] = matrix[i][col];</span><br><span class="line">        col—-;  <span class="comment">// 列-1</span></span><br><span class="line">        <span class="keyword">if</span>(col&lt; col_s) <span class="keyword">break</span>; </span><br><span class="line">        <span class="comment">// 下+左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col; i&gt;=col_s; i--) res[id++] = matrix[row][i];</span><br><span class="line">        row--;</span><br><span class="line">        <span class="keyword">if</span>(row&lt; row_s) <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row;i&gt;=row_s; i--) res[id++] = matrix[i][col_s];</span><br><span class="line">        col_s++;</span><br><span class="line">        <span class="keyword">if</span>(col_s&gt; col) <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;四步：&lt;/p&gt;
&lt;p&gt;1.从左到右&lt;br&gt;2.从上到下&lt;br&gt;3.从右到左&lt;br&gt;4.从下到上&lt;/p&gt;
&lt;h4 id=&quot;思路：&quot;&gt;&lt;a href=&quot;#思路：&quot; class=&quot;headerlink&quot; title=&quot;思路：&quot;&gt;&lt;/a&gt;思路：&lt;/h4&gt;&lt;p&gt;row_s 行 开始，</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="数论" scheme="http://example.com/categories/LeetCode/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>最多的盛水容器_11</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/1.%E6%9C%80%E5%A4%9A%E7%9A%84%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8_11/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/1.%E6%9C%80%E5%A4%9A%E7%9A%84%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8_11/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:32:58.714Z</updated>
    
    <content type="html"><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。<br>在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。<br>找出其中的两条线，使得它们与 <strong>x 轴共同构成的容器可以容纳最多的水</strong></p><p>说明：你不能倾斜容器，且 n 的值至少为 2<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (r-l)*Math.min(height[l],height[r]);</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">       <span class="keyword">if</span>(height[l]&gt;height[r]) r—-;</span><br><span class="line">       <span class="keyword">else</span> l++；</span><br><span class="line">       res= Math.max(res, (r-l)*Math.min(height[l],height[r]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。&lt;br&gt;在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。&lt;br&gt;找出其中的两条线，使得它们与 &lt;strong&gt;x 轴共同构成的容器可以容纳最多的</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>找出最大连续子数组和_53</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/3.%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C_53/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/3.%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C_53/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:37:06.435Z</updated>
    
    <content type="html"><![CDATA[<p>一个整数数组 nums ，找到一个&#x2F;有 <strong>最大和的连续子数组</strong>（子数组最少包含一个元素），返回其最大和</p><p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大为 6</p><p><strong>进阶:</strong> 如果你已经实现复杂度为 <strong>O(n) 的解法，尝试使用更为精妙的分治法求解。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_v</span> <span class="operator">=</span> nums[<span class="number">0</span>], res=nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        max_v = Math.max( max_v+nums[i], nums[i]);</span><br><span class="line">        res = Math.max(res, max_v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个整数数组 nums ，找到一个&amp;#x2F;有 &lt;strong&gt;最大和的连续子数组&lt;/strong&gt;（子数组最少包含一个元素），返回其最大和&lt;/p&gt;
&lt;p&gt;输入: [-2,1,-3,4,-1,2,1,-5,4],&lt;br&gt;输出: 6&lt;br&gt;解释: 连续子数组 [4,-1,2</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏_45/55</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/2.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_4555/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/2.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_4555/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:35:48.461Z</updated>
    
    <content type="html"><![CDATA[<h4 id="55"><a href="#55" class="headerlink" title="55."></a>55.</h4><p>给定一个非负整数 数组，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度。<br>判断 <strong>是否能够到达最后一个位置。</strong></p><p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p><p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max_l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;nums.length; id++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_l&gt;=id &amp;&amp; id+nums[id] &gt; max_l ) </span><br><span class="line">            max_l = id+nums[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_l&gt;=nums.length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="45-最少次数跳到最后位置，使用-最少的跳跃次数到达数组的最后一个位置"><a href="#45-最少次数跳到最后位置，使用-最少的跳跃次数到达数组的最后一个位置" class="headerlink" title="45.最少次数跳到最后位置，使用 最少的跳跃次数到达数组的最后一个位置"></a>45.最少次数跳到最后位置，使用 <strong>最少的跳跃次数到达数组的最后一个位置</strong></h4><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdbxjzpdj20jo0dh75g.jpg" alt="6600092D-2F93-4F3E-91BC-C810187EEC89" style="zoom:67%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> step=<span class="number">0</span>, end=<span class="number">0</span>, max_l=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//不用考虑从最后一个位置起跳的情况，所以i &lt; nums.size()-1，而不是i &lt; nums.size()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;nums.length-<span class="number">1</span>; id++)&#123;</span><br><span class="line"></span><br><span class="line">        max_l = Math.max(max_l, id+nums[id]);</span><br><span class="line">        <span class="keyword">if</span>(id==end)&#123;</span><br><span class="line">            end=max_l;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;55&quot;&gt;&lt;a href=&quot;#55&quot; class=&quot;headerlink&quot; title=&quot;55.&quot;&gt;&lt;/a&gt;55.&lt;/h4&gt;&lt;p&gt;给定一个非负整数 数组，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度。&lt;br&gt;判断 &lt;strong&gt;是否能够</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>引爆气球最少箭数_452</title>
    <link href="http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/4.%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%E6%9C%80%E5%B0%91%E7%AE%AD%E6%95%B0_452/"/>
    <id>http://example.com/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/4.%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%E6%9C%80%E5%B0%91%E7%AE%AD%E6%95%B0_452/</id>
    <published>2022-05-04T13:55:19.000Z</published>
    <updated>2022-04-20T10:39:17.040Z</updated>
    
    <content type="html"><![CDATA[<p>在二维空间中有许多球形的气球, 对于每个气球，提供的输入是水平方向上，气球直径的 <strong>开始和结束坐标</strong>。<br>开始坐标总是小于结束坐标，平面内最多存在104个气球。<br>若一个气球直径开始和结束坐标为 xstart，xend，<strong>且满足 xstart ≤ x ≤ xend，则该气球会被引爆。</strong>所需的弓箭的最小数量？   </p><p>输入:[[10,16],  [2,8],  [1,6],  [7,12]]<br>排序后：[1,6] [2,8] [7,12] [10,16]<br>输出:  2<br><strong>解释:</strong>  对于该样例，我们可以在x &#x3D; 6（射爆[2,8],[1,6]两个气球）和 x &#x3D; 11（射爆另外两个气球）。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>类似于集合求相交区间</p><p>排序，小–&gt;大<br>right &lt; array[left], 计数加 1<br>right &#x3D; min(right, array[right])  依次向后更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(points, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rv=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">1</span>;id&lt;points.length;id++)&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = points[id];</span><br><span class="line">        <span class="keyword">if</span>(rv &lt; tmp[<span class="number">0</span>])&#123;</span><br><span class="line">            res++;</span><br><span class="line">            rv = tmp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        rv = Math.min(rv, tmp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在二维空间中有许多球形的气球, 对于每个气球，提供的输入是水平方向上，气球直径的 &lt;strong&gt;开始和结束坐标&lt;/strong&gt;。&lt;br&gt;开始坐标总是小于结束坐标，平面内最多存在104个气球。&lt;br&gt;若一个气球直径开始和结束坐标为 xstart，xend，&lt;strong&gt;</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="贪心" scheme="http://example.com/categories/LeetCode/%E8%B4%AA%E5%BF%83/"/>
    
    
    <category term="贪心" scheme="http://example.com/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>数组中数字出现的次数</title>
    <link href="http://example.com/2022/05/03/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/1.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/"/>
    <id>http://example.com/2022/05/03/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/1.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</id>
    <published>2022-05-03T13:55:19.000Z</published>
    <updated>2022-04-20T10:20:47.771Z</updated>
    
    <content type="html"><![CDATA[<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</a></p><p>一个整型数组 nums 里除 两个数字之外，其他 数字都出现了两次找出 这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)</p><p>输入：nums &#x3D; [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p><p>输入：nums &#x3D; [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>如果可以把所有数字分成两组，使得：<br>1.两个只出现一次的数字在不同的组中<br>2.相同的数字会被分到相同的组中<br>那么对 两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。</p><p>a 和 b  写成二进制的形式：<br>xi &#x3D; ai^bi ， （^ 异或）相异为 1，相同为 0<br>ai 和 bi 的关系 &#x3D;&#x3D;&gt;  xi&#x3D;1 表示 ai 和 bi 不等;  xi &#x3D; 0 —&gt; 表示 ai 和 bi 相等</p><p>假如任选一个不为 0 的 xi ，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组<br>按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件，<br>两个 相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2<br>这个方法在 xi&#x3D;1 的时候 a 和 b 不被分在同一组，因为 xi&#x3D;1 表示 ai 和 bi 不同，根据这个方法的定义「如果该位为 0 就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。</p><p>条件1:</p><p>ai^bi^ai  &#x3D;&#x3D;  0.&#x2F;.1<br>ai^bi^bi  &#x3D;&#x3D; 1&#x2F;.0<br>因为 ai 和 bi 互异，彼此必然有一个为 1，另一个为 0</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: nums)&#123;</span><br><span class="line">        x = x^v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> div=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((div &amp; x)==<span class="number">0</span>) div= div&lt;&lt;<span class="number">1</span>; <span class="comment">// 找到2个数之间差异的那一个位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//此时 div 为 a^b 从右数第一个1 最低位，xi=1 表示 ai和 bi不等</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">        <span class="comment">//验证每个数字的 div位 是1/0， 1为一组； 0为一组</span></span><br><span class="line">        <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123; </span><br><span class="line">            a = a^n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b^n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;a,b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="数组中只出现一次的数（其它数出现k次）"><a href="#数组中只出现一次的数（其它数出现k次）" class="headerlink" title="数组中只出现一次的数（其它数出现k次）"></a><strong>数组中只出现一次的数（其它数出现k次）</strong></h3><p><a href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p><p>给定一个整型数组 arr和一个整数 k(k&gt;1)<br>已知 arr中只有 1 个数出现一次，其他的数都出现 k次, 请返回只出现了 1 次的数。</p><h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong>示例1</strong></h5><p>输入：   [ 5,4,1,1,5,1,5],  3<br>返回值： 4</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foundOnceNumber</span> <span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] binarySum = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;   </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//记录每一位值的求和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : arr)&#123;  </span><br><span class="line">            sum = sum + ((v&gt;&gt;i) &amp; <span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        binarySum[i] = sum; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( binarySum[i]%k != <span class="number">0</span> )&#123;</span><br><span class="line">            res += (<span class="number">1</span>&lt;&lt;i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;链接：&lt;a href=&quot;https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof&quot;&gt;https://leetcode-cn.com/problems/shu-zu-zhong-s</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="数论" scheme="http://example.com/categories/LeetCode/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>N进制转换</title>
    <link href="http://example.com/2022/05/03/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/2.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2_112/"/>
    <id>http://example.com/2022/05/03/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/2.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2_112/</id>
    <published>2022-05-03T13:55:19.000Z</published>
    <updated>2022-04-20T10:22:14.212Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。<br>当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 ‘A’ 表示此位为 10 ， ‘B’ 表示此位为 11 。<br>若 M 为负数，应在结果中保留负号。<br>M是32位整数，2&lt;&#x3D;N&lt;&#x3D;16.</p><p>输入：  7,2<br>返回值：”111”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(<span class="type">int</span> M, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(M&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        sign = -<span class="number">1</span>;</span><br><span class="line">        M = -M;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(M&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> M%N;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=<span class="number">10</span>) res.append( (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+v-<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">else</span> res.append(v);</span><br><span class="line">        M = M/N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> res.reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> sign==<span class="number">1</span>? ans: <span class="string">&#x27;-&#x27;</span>+ ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。&lt;br&gt;当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 ‘A’ 表示此位为 10 ， ‘B’ 表示此位为 11 。&lt;br&gt;若 M 为负数，应在结果中保留负号</summary>
      
    
    
    
    <category term="LeetCode" scheme="http://example.com/categories/LeetCode/"/>
    
    <category term="数论" scheme="http://example.com/categories/LeetCode/%E6%95%B0%E8%AE%BA/"/>
    
    
    <category term="数论" scheme="http://example.com/tags/%E6%95%B0%E8%AE%BA/"/>
    
  </entry>
  
</feed>
