<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>操作系统-基础</title>
    <url>/2022/02/25/D-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="操作系统基本知识点"><a href="#操作系统基本知识点" class="headerlink" title="操作系统基本知识点"></a>操作系统基本知识点</h1><h3 id="进程的五大状态："><a href="#进程的五大状态：" class="headerlink" title="进程的五大状态："></a><strong>进程的五大状态：</strong></h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guqw5a87r6j612m0m2q5l02.jpg" alt="C4503148-288A-4F82-8FC9-348D8A500B94" width="650" height="300" />



<h3 id="Sleep-wait-区别："><a href="#Sleep-wait-区别：" class="headerlink" title="Sleep, wait 区别："></a><strong>Sleep, wait 区别：</strong></h3><p><strong>sleep() 休眠：</strong>让调用线程进入睡眠，让出执行机会给其他线程，等到休眠时间结束，线程进入就绪状态和其他线程一起竞争cpu执行时间。Thread的静态方法，不能改变对象的机锁，当一个synchronized块中调用了sleep() 方法，线程虽然进入休眠，但是对象的锁没有被释放，其他线程依然无法访问这个对象。<br><strong>wait() 挂起：</strong>是Object类的方法，当一个线程执行到wait方法时，它就进入到一个和该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll方法来唤醒等待的线程。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.sleep不释放对象锁，只是让出CPU； wait释放对象锁，也让出CPU<br>2.sleep 是Thread 的静态方法； wait 是Object 类的私有方法<br>3.sleep可以指定休眠时间，无法唤醒；wait 可指定时间，也可通过notify&#x2F;notifyAll唤醒，实现多线程间通信</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guqvcdozn9j60wq0n440c02.jpg" alt="D3CA871F-D18B-4198-B93E-785CB79A032A" width="450" height="300" />

<h3 id="CPU-执行程序的过程"><a href="#CPU-执行程序的过程" class="headerlink" title="CPU 执行程序的过程:"></a>CPU 执行程序的过程:</h3><p>CPU 根据 程序计数器里的内存地址，从内存里面把需要执行的 指令序列读取到 指令寄存器 里面执行，然后根据 指令长度自增，开始顺序读取下一条指令。<br><strong>CPU 的指令周期：</strong> CPU 从程序计数器读取指令、到执行、再到下一条指令，这个过程会不断循环，直到程序执行结束。</p>
<h3 id="操作系统中的死锁："><a href="#操作系统中的死锁：" class="headerlink" title="操作系统中的死锁："></a>操作系统中的死锁：</h3><p>一组进程中，每个进程都 无限等待被该组进程中另一进程所占有的资源，而永远无法得到资源，这种现象称为进程死锁，这一组 进程称为死锁进程。如果死锁发生，会浪费大量系统资源，甚至导致系统崩溃。</p>
<p><strong>产生死锁必要的四个条件：</strong><br>(1)互斥使用 (资源独占)：   一个资源 每次只能给一个进程使用<br>(2)请求和保持(部分分配)：进程在 申请新的资源的同时 保持对原有资源的占有<br>(3)不可抢占 (不可剥夺)：资源申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放<br>(4)循环等待：存在一个进程等待队列 {P1 , P2 , … , Pn}，其中P1等待P2占有的资源，P2等待P3占有的资源，…，Pn等待P1占有的资源，形成一个进程等待环路。</p>
<p><strong>解除死锁：</strong>   资源剥夺法、   进程撤销法、进程回退法、    系统重启法<br><strong>破坏环路等待：</strong>给资源统一编号，进程只能按编号顺序来请求资源。<br><strong>死锁避免：</strong>在程序运行时避免发生死锁</p>
<h3 id="同步-x2F-异步-x2F-阻塞-x2F-非阻塞IO："><a href="#同步-x2F-异步-x2F-阻塞-x2F-非阻塞IO：" class="headerlink" title="同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞IO："></a>同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞IO：</h3><p><strong>等待过程：</strong> 数据从网络 到 网卡, 再到 内核空间<br><strong>读写(copy)过程：</strong> 内核空间，和 用户空间 相互拷贝<br>IO： 读入&#x2F;写出 数据的过程，和等待 读入&#x2F;写出数据的过程<br><strong>同步&#x2F;异步：</strong>  是否 等待数据到 内核空间（网络—&gt;网卡—&gt;内核）<br><strong>阻塞&#x2F;非阻塞：</strong>  是否 等待 copy数据 （ 内核—&gt; 用户）</p>
<p><strong>阻塞IO：</strong>用户线程被阻塞在等待数据上和拷贝数据上。<br>应用程序都运行在 用户空间，能操作的 数据也都在用户空间；如果此时用户线程已经参与，那它一定 会被阻塞在IO上，这就是常说的阻塞IO，用户线程被阻塞在等待数据，拷贝数据。<br><strong>非阻塞IO：</strong>数据已经拷贝到用户空间后，才去通知用户线程，一上来就可以直接操作数据，用户线程没有因为IO的事情出现阻塞。</p>
<h3 id="同步IO-x2F-同步阻塞IO："><a href="#同步IO-x2F-同步阻塞IO：" class="headerlink" title="同步IO&#x2F;同步阻塞IO："></a>同步IO&#x2F;同步阻塞IO：</h3><p><strong>同步IO:</strong> 发起 IO请求后，必须拿到 IO数据才继续执行，在 等待和拷贝数据过程中，线程都在阻塞，因为后续操作依赖IO数据<br><strong>非阻塞IO：</strong>发起IO请求后，可以继续往下执行，后续执行不依赖于IO数据，所以它肯定不是同步的。<br>同步IO 一定是 阻塞IO，也就是同步阻塞IO。</p>
<p><strong>异步：</strong> 等待数据继续执行，  阻塞：copy 数据时阻塞<br><strong>异步IO：</strong>IO请求后，不用拿到IO的数据就可继续执行，用户线程继续执行，和操作系统准备IO数据的过程是同时进行。<br><strong>异步阻塞 IO：</strong> 在等待数据过程中，用户线程继续执行，在拷贝数据过程中，用户线程在阻塞；用户线程没有参与数据等待的过程，所以是异步的。但用户线程参与数据拷贝的过程，所以是阻塞的,合起来异步阻塞IO。<br><strong>异步非阻塞IO：</strong> 等待数据， copy 数据时 用户线程都在继续执行；在 等待数据的过程中，和拷贝数据的过程中，用户线程都在继续执行；用户线程 没有参与等待过程也没有参与拷贝过程，当接到通知时数据已经准备好了，没有因为IO数据而阻塞，是非阻塞的。</p>
<h3 id="I-x2F-O多路复用"><a href="#I-x2F-O多路复用" class="headerlink" title="I&#x2F;O多路复用"></a>I&#x2F;O多路复用</h3><p>通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（读就绪或写就绪），能通知程序进行相应的读写操作<br>select，poll，epoll 本质上都是 同步I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O的实现会负责把数据从  内核拷贝到用户空间。</p>
<h4 id="Select-原理："><a href="#Select-原理：" class="headerlink" title="Select 原理："></a>Select 原理：</h4><p>1.从 用户空间 拷贝 fd_set 到 内核空间，fds 文件描述符（ 3类，分别是writefds，readfds，和exceptfds ）<br>2.注册回调函数 __pollwait ，然后将 current（当前进程）挂到 设备的等待队列中，不同的设备有不同的等待队列。（有数据 可读、可写、或超时timeout等待时间）<br>3.有描述符 就绪后，通过回调函数进行通知，select 会对 fd_set 进行遍历，来找到就绪的描述符。<br>遍历完 所有的 fd，还没有返回一个 可读写的 mask掩码，调用 schedule_timeout 是 调用select的进程（current）进入睡眠<br>缺点：<br>1）支持的文件描述符数量太小，默认是 1024<br>2）每次 调用 select，需要把 fds 集合从 用户态拷贝 到内核态，在 fds 很大时, 开销较大<br>3）每次调用 select 需要在 内核遍历传递进来的 所有 fds，找到处于 就绪的描述符，开销较大</p>
<h4 id="poll-："><a href="#poll-：" class="headerlink" title="poll ："></a>poll ：</h4><p>实现和 select 相似，只是 描述 fd集合 不同，poll使用 poll fd结构而不是select的fd_set结构，链表存储的。<br>优：没有最大连接数的限制，原因：基于链表来存储的<br>缺：<br>1.poll, select  大量的 fds 的数组被整体 复制于 用户态和内核地址空间之间<br>2.select, poll 都要通过 遍历文件描述符来获取已经就绪的socket，如果同时连接大量客户端，但只有很少的处于就绪状态，这会导致随着监视的 描述符数量的增长，效率下降。</p>
<h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll:"></a>epoll:</h4><p>提供三个函数：epoll_create创建一个epoll句柄； epoll_ctl 注册要监听的事件类型； epoll_wait 是等待事件的产生 。</p>
<p>1.解决反复 copy fds 问题：epoll更加灵活，没有描述符限制。epoll 使用一个 文件描述符管理多个描述符， 将 用户关系的文件描述符的事件 存放到 内核的一个事件表 中，这样在 用户空间和内核空间的 copy只需一次。<br>2.epoll 使用 “事件”就绪通知方式，通过 epoll_ctl时把 current 遍历一遍，并 为每个 fd 指定一个回调函数，当设备就绪，唤醒 等待队列上的等待者时，会调用这个回调函数，而这个 回调函数会把就绪的 fd 加入一个就绪链表；epoll_wait 工作实际上就是在这个 就绪链表中查看有没有就绪的fd 。</p>
<p><strong>总结：</strong>select，poll 每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把 current往设备等待队列中挂一次，而 epoll只要一次拷贝，而且把 current 往等待队列上挂也只挂一次。<br>只有活跃可用的 FD才会调用 callback函数；即 epoll最大的优点就在于它只管你“活跃”的连接，而跟连接总数无关，因此在实际的网络环境中，epoll的效率就会远远高于select和poll。</p>
<p><strong>内存拷贝：</strong>利用 mmap()文件 映射内存加速 与 内核空间的消息传递；即 epoll使用mmap减少复制开销<br>参考：<a href="https://blog.csdn.net/weixin_34067102/article/details/91532307?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-10.essearch_pc_relevant">https://blog.csdn.net/weixin_34067102/article/details/91532307?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-10.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-10.essearch_pc_relevant</a>   </p>
<h3 id="用户态-lt-—-gt-内核态："><a href="#用户态-lt-—-gt-内核态：" class="headerlink" title="用户态 &lt;—&gt; 内核态："></a>用户态 &lt;—&gt; 内核态：</h3><p>所有程序都在 用户空间运行（用户态），但很多操作 可能涉及内核运行，就需要进入内核态</p>
<ol>
<li>用户态把一些 数据放到寄存器，或创建对应的堆栈，表明需要操作系统提供的服务</li>
<li>用户态 执行 系统调用（系统调用是操作系统的最小功能单位）</li>
<li>CPU 切换到内核态，跳到对应的内存指定的位置执行指令</li>
<li>系统调用 处理器 去读取先前放到 内存的数据参数，执行程序的请求 </li>
<li>调用完成，操作系统重置 CPU为用户态返回结果，并执行下个指令</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guqvemj5ggj60ka0leq3w02.jpg" alt="0BCDE869-93F4-4F5A-9A33-090FFB41FDF0" width="350" height="350" />



<p>内核 &lt;—&gt;用户</p>
<p>1.系统调用：本身就是中断，但是软件中断，跟硬中断不同</p>
<p>2.异常：如果当前进程运行在用户态，如果此时发生异常事件，就会触发切换， 例如：缺页异常</p>
<p>3.外设中断：当外设完成用户的请求时，会向CPU发送中断信号<br>用户态进程通过 系统调用申请使用 操作系统提供的服务程序完成工作，比如 fork() 实际上就是执行了一个 创建新进程的系统调用；CPU 在执行 用户态下的程序时，发生不可知的异常，这时会触发当前运行进程切换到处理此异常的内核相关程序中，转到内核态，比如缺页异常。<br>用户态: 上层应用程序的活动空间，应用程序的执行必须依托于 内核提供的资源，包括CPU资源、存储资源、I&#x2F;O资源等。为了使上层应用能够访问到这些资源，内核 必须为上层应用提供访问的接口：即系统调用。</p>
<p>系统调用：操作系统的最小功能单位<br>Shell (命令行)  是一个特殊的应用程序，下通系统调用，上通各种应用，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。同时 Shell是可编程的，可以执行符合 Shell语法的文本(Shell脚本)。为方便用户和系统交互，一个Shell对应一个终端，可以通过终端窗口输入或输出文本，这个文本直接传递给shell 进行分析解释，然后执行。</p>
<h3 id="进程、线程区别："><a href="#进程、线程区别：" class="headerlink" title="进程、线程区别："></a>进程、线程区别：</h3><p>进程： 操作系统 资源分配的基本单位<br>线程： 任务调度、执行的基本单位， cpu调度和分派的基本单位。</p>
<h4 id="开销："><a href="#开销：" class="headerlink" title="开销："></a>开销：</h4><p>每个进程都有独立的 代码 和 数据 空间（程序上下文），程序之间的切换会有较大的开销；<br>线程就像轻量级的进程，同一类 线程 共享代码和数据空间，每个线程都有自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小</p>
<h4 id="环境："><a href="#环境：" class="headerlink" title="环境："></a>环境：</h4><p>操作系统中能 同时运行多个进程（程序）；<br>在同一个进程（程序）中有多个线程同时执行（通过CPU调度，在每个时间片中只有一个线程执行）</p>
<h4 id="内存分配："><a href="#内存分配：" class="headerlink" title="内存分配："></a>内存分配：</h4><p>系统在运行的时候会为 每个进程分配不同的内存空间<br>对线程而言，除了CPU外，系统不会为线程分配内存， 线程所使用的资源来自其所属进程的资源，线程组之间只能共享资源</p>
<h3 id="进程间通信方式："><a href="#进程间通信方式：" class="headerlink" title="进程间通信方式："></a>进程间通信方式：</h3><h4 id="1-P、V信号量（Semaphore）："><a href="#1-P、V信号量（Semaphore）：" class="headerlink" title="1.P、V信号量（Semaphore）："></a>1.P、V信号量（Semaphore）：</h4><p>操作系统提供一种进程间的通信方式，主要用来协调并发程序对共享资源的访问，操作系统可以保证对信号量操作的原子性<br>信号量（semaphore）与已经介绍过的 IPC 结构不同，它是一个计数器。信号量用于实现进程间的互斥与同步，而不是用于存储进程间通信数据。<br>特点</p>
<ol>
<li>信号量用于进程间同步，若要在进程间传递数据需要结合共享内存。</li>
<li>信号量基于操作系统的 PV 操作，程序对信号量的操作都是原子操作。</li>
</ol>
<h4 id="2-管程："><a href="#2-管程：" class="headerlink" title="2.管程："></a>2.管程：</h4><p>原理：所有进程对某一种临界资源的同步操作都集中起来，构成一个秘书进程。凡要访问该临界资源的进程，都需要先报告秘书进程，由秘书来实现进程对同一临界资源的互斥使用。</p>
<p>管程可以理解为一个对象监视器，任何线程想要访问共享资源，需要排队进入监控范围，接受检查，不符合条件，则要等待直到被通知，然后再进入监视器.</p>
<ol>
<li>它是 半双工的（即数据只能在一个方向上流动），具有固定的读端和写端。</li>
<li>它只能用于具有亲缘关系的进程之间的通信（也是父子进程或者兄弟进程之间）。<br>注意：信号量和管程两者是等价的，信号量可以实现管程，管程也可以实现信号量，两者的表现形式不同，管程对开发者更加友好。</li>
</ol>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guqvgjnc0gj611w0j4mzh02.jpg" alt="1F787016-667F-4A87-BEFF-61790414A89F" width="650" height="320" />




<p>管程为了解决信号量在临界区的 PV 操作上的配对的麻烦，把配对的 PV 操作集中在一起，并且加入了条件变量的概念，使得在多条件下线程间的同步实现变得更加简单。</p>
<h4 id="3-消息队列："><a href="#3-消息队列：" class="headerlink" title="3.消息队列："></a>3.消息队列：</h4><p>容量受系统限制<br>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。<br><strong>特点：</strong></p>
<ol>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li>
</ol>
<h4 id="4-共享内存："><a href="#4-共享内存：" class="headerlink" title="4.共享内存："></a>4.共享内存：</h4><p>速度快，各个进程间共享同一个内存区域，实现共享变量的访问<br>共享内存（Shared Memory），指两个或多个进程共享一个给定的存储区。<br>特点</p>
<ol>
<li>共享内存是 最快的一种 IPC，因为进程是直接对内存进行存取。</li>
<li>因为 多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量+共享内存:  通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
<h4 id="5-套接字"><a href="#5-套接字" class="headerlink" title="5.套接字"></a>5.套接字</h4><p>用于不同设备间的进程通信</p>
<h3 id="线程间通信方式："><a href="#线程间通信方式：" class="headerlink" title="线程间通信方式："></a>线程间通信方式：</h3><p>1.互斥锁：   以排他的方式防止数据结构并发修改<br>2.条件变量：阻塞进程，知道某个条件满足<br>3.读写锁：   多线程同时读，互斥写<br>4.信号量：   类似进程间信号量通信，主同步</p>
<h3 id="进程调度算法；"><a href="#进程调度算法；" class="headerlink" title="进程调度算法；"></a>进程调度算法；</h3><p>1.先来先服务<br>2.最短作业优先<br>3.响应比最高者优先<br>4.优先级调度算法<br>5.时间片轮转调度算法</p>
<p>参考：<strong>文件系统</strong>：<a href="https://mp.weixin.qq.com/s/UT2JrfpkA5OUC9fJJ_MirQ">https://mp.weixin.qq.com/s/UT2JrfpkA5OUC9fJJ_MirQ</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>段/页式存储</title>
    <url>/2022/02/27/D-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/2.%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="段-x2F-页式存储"><a href="#段-x2F-页式存储" class="headerlink" title="段&#x2F;页式存储"></a>段&#x2F;页式存储</h1><h3 id="背景："><a href="#背景：" class="headerlink" title="背景："></a>背景：</h3><p>​    在多进程环境下，为使进程之间的内存地址不受影响，相互隔离，操作系统为 每个进程独立分配一套 虚拟地址空间，每个程序只关心自己的虚拟地址，多进程通过 虚拟地址 映射到不同的物理地址内存。</p>
<p>​    作为程序，也不用关心物理地址的事情。每个进程都有自己的虚拟空间，而物理内存只有一个；当启用大量的进程，物理内存必然会很紧张，于是操作系统会通过 内存交换技术，把不常使用的内存暂时存放到硬盘 （换出），在需要时再装载回物理内存（换入）。</p>
<p>​    有了虚拟地址空间，必然要把 虚拟地址「映射」到 物理地址，这个事情通常由操作系统来维护，对于虚拟地址与物理地址的映射关系，可以有 分段，分页，段页的方式。访问虚拟地址时，由操作系统转换成不同的 物理地址，这样不同进程运行的时候，写入不同的物理地址，就不会冲突。</p>
<p>程序所使用的内存地址： <strong>虚拟内存地址</strong><br>实际存硬件里面的空间地址：<strong>物理内存地址</strong></p>
<h3 id="内存分段（Segmentation）"><a href="#内存分段（Segmentation）" class="headerlink" title="内存分段（Segmentation）"></a>内存分段（Segmentation）</h3><p>​    程序由若干个逻辑分段组成： 代码分段、数据分段、栈段、堆段；不同段 有不同的属性，用分段形式把这些段分离出来。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0omkxpj612e0rwjt702.jpg" alt="F3F67004-8E73-43E9-9085-55FD89A5D40D" width="750" height="500"/>

<h3 id="内存分段-寻址方式"><a href="#内存分段-寻址方式" class="headerlink" title="内存分段-寻址方式"></a>内存分段-寻址方式</h3><p><strong>段选择因子：</strong>保存在段寄存器里；</p>
<p><strong>段号：</strong>段表的索引，段表里面保存 段的基地址、段的界限和 特权等级等；</p>
<p><strong>段内偏移量：</strong>位于（0~段界限）；  </p>
<p>物理内存地址 &#x3D; 段基地址 + 段内偏移量； 虚拟地址：通过 段表与 物理地址映射，分段机制把程序的虚拟地址分成 4 个段，每个段在 段表中有一个项，在这一项找到段的基地址，再加上偏移量，就能找到物理内存中的地址。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0m9lzqj60tb0i376302.jpg" alt="255BA9F7-C651-478C-AC47-73750F6D3619" width="600" height="350" />



<h3 id="段式存储问题：-1-内存碎片；2-内存交换的效率低"><a href="#段式存储问题：-1-内存碎片；2-内存交换的效率低" class="headerlink" title="段式存储问题： 1.内存碎片；2.内存交换的效率低"></a><strong>段式存储问题：</strong> 1.内存碎片；2.内存交换的效率低</h3><h4 id="1-内存锁片："><a href="#1-内存锁片：" class="headerlink" title="1.内存锁片："></a>1.内存锁片：</h4><p><strong>外部内存碎片：</strong>在物理内存中产生多个 不连续的小物理内存，导致 新的程序无法被装载；<br><strong>内部内存碎片：</strong>程序所有的内存都被装载到物理内存，但程序 有部分的内存 可能并不是很常使用，这也会导致内存的浪费；</p>
<p><strong>内存交换：</strong>解决–外部内存碎片问题<br>        把一个程序占用的 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回时，不装载回原来位置，而是紧紧跟在已经被占用的 512MB 内存后面。这样就 就使得空间利用连续，避免内存碎片产生。</p>
<h4 id="2-内存交换的效率低："><a href="#2-内存交换的效率低：" class="headerlink" title="2.内存交换的效率低："></a>2.内存交换的效率低：</h4><p>​        内存交换空间在 Linux 系统里就是 Swap 空间，这块 空间是从硬盘划分出来，用于内存与硬盘的空间交换<br>对于多进程系统，内存碎片很容易产生，需要经常进行 内存交换操作，但Swap空间是硬盘，有性能瓶颈；硬盘访问速度比内存慢很多，每次内存交换都需要把 一大段连续的内存数据写到硬盘上。如果内存交换时，交换占内存空间很大的程序，整个机器都会卡顿。</p>
<h3 id="内存分页："><a href="#内存分页：" class="headerlink" title="内存分页："></a><strong>内存分页：</strong></h3><p>解决 内存碎片，内存交换效率低；把整个 虚拟，物理内存空间切成一段段 固定尺寸的大小-页（Page）：一个连续并尺寸固定的内存空间，Linux 一页大小 4KB。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0jfow0j60tn0m575h02.jpg" alt="5724EB13-9A0A-4AA4-9C44-043EA8D0D3D0" width="600" height="450" />

<p>虚拟地址分为： 页号，页内偏移<br><strong>页号：</strong> 页表的索引，页表包含 物理页每页所在 物理内存的基地址，物理内存地址 &#x3D;  基地址 与 页内偏移的组合<br>内存分页寻址过程：<br>1.把虚拟内存地址，切分成 页号，偏移量<br>2.根据页号，从 页表里查询对应的物理页号<br>3.直接拿 物理页号 + 偏移量，得到 物理内存地址</p>
<p>**内存空间： **预先划分好，不像分段那样产生 间隙非常小的内存，这正是分段会产生内存碎片的原因。释放的内存都是以页为单位释放的，也不会产生无法给进程使用的小内存。<br>**页表： **存储在 CPU 内存管理单元 （MMU） 中；  CPU 可以直接 通过 MMU 找出实际要访问的 物理内存地址。<br>当 进程访问的虚拟地址在页表中查不到时，系统会产生：缺页异常<br><strong>解决：</strong> 进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0h4ljqj61320nt76302.jpg" alt="C547F405-C521-41CA-AA71-DD30DC86D94F" width="650" height="350" />

<p>​    如果内存空间不够，操作系统会把 其他正在运行的进程中的「最近没被使用LRU」的 内存页面换出（Swap Out）， 暂时写在硬盘上；需要时再加载进来，称为换入（Swap In）。一次性写入磁盘只有少数一个页或几个页，不会花太多时间，内存交换效率相对比较高。<br>​    分页方式在加载程序时，不需要一次性把程序加载到物理内存中。在虚拟内存 和物理内存的页映射之后，并不真的把页加载到物理内存里，而 只有在 程序运行中，需要用到对应虚拟内存页里面的 指令和数据时，再加载到 物理内存里面去。</p>
<h3 id="页式存储空间上的缺陷："><a href="#页式存储空间上的缺陷：" class="headerlink" title="页式存储空间上的缺陷："></a>页式存储空间上的缺陷：</h3><p>操作系统可以同时运行非常多的进程，意味着页表会非常的庞大。在 32 位的环境下，虚拟地址空间共有 4GB，一个页大小 4KB，就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，整个 4GB 空间的映射就需要有 4MB 内存来存储页表。每个进程都是有自己的虚拟地址空间，如果有 100 个进程的话，就需要 400MB 内存来存储页表，这是非常大的内存，而 64 位环境则会更大。</p>
<p><strong>多级页表  解决：</strong>多进程页表占用空间过大问题<br>使用 二级分页，一级页表 就可以覆盖整个 4GB 虚拟地址空间，但如果某个一级页表的页表项没有被用到，也就不需要创建这个页表项对应的二级页表，即可以在需要时才创建二级页表。例如：假设只有 20% 一级页表项被用到，那么页表占用内存空间就只有  4KB（一级页表）+  20% * 4 MB（二级页表）&#x3D; 0.804MB</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>​    每个进程有 4GB 虚拟地址空间，对于大多数程序来说，其使用的空间远未达到4GB，因为会有部分对应的页表项都是空的，没有分配，对于已分配的页表项，如果是最近一段时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，不会占用物理内存。</p>
<h4 id="程序的局部性"><a href="#程序的局部性" class="headerlink" title="程序的局部性"></a><strong>程序的局部性</strong></h4><p>​    把常访问的 几个页表项存储到访问速度更快的硬件，在 CPU 芯片中加入一个专门存放 程序最常访问的 页表项的 Cache，这个 Cache 就是 TLB（Translation Lookaside Buffer） ，通常称为：页表缓存、转址旁路缓存、快表等。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0ern33j60s00e53zb02.jpg" alt="F2665293-6C21-4F33-8C0D-16EA3F0A15E9" width="600" height="300" />

<h4 id="地址转换："><a href="#地址转换：" class="headerlink" title="地址转换："></a>地址转换：</h4><p>在 CPU 芯片里封装了 内存管理单元（Memory Management Unit）芯片，它用来完成 地址转换和 TLB 的访问与交互。CPU 在寻址时，会先查 TLB，如果没找到，才继续查常规的页表。TLB 命中率其实是很高的，因为程序最常访问的页就那几个 。</p>
<h4 id="段页式内存管理"><a href="#段页式内存管理" class="headerlink" title="段页式内存管理"></a>段页式内存管理</h4><p>内存分段和内存分页并不是对立的，它们可以组合起来在同一个系统中使用，组合后称为：段页式内存管理<br><strong>段页式内存管理：</strong><br>1.先将程序划分为 多个有逻辑意义的段<br>2.再把 每个段划分为 多个页，对分段划分出来的连续空间，再划分 固定大小的页<br>这样地址结构就由 段号、段内页号，页内位移 三部分组成。用于 段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址 是 页表的起始地址，而 页表中的地址是 某页的物理页号 </p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurk0blh3cj614c0jfac602.jpg" alt="431DF29B-F743-4129-B9C7-377E6C0D1DE8" width="600" height="300" />

<h3 id="段页式地址–-gt-物理地址过程："><a href="#段页式地址–-gt-物理地址过程：" class="headerlink" title="段页式地址–&gt;物理地址过程："></a><strong>段页式地址–&gt;物理地址过程：</strong></h3><p>1.访问段表，得到页表起始地址<br>2.访问页表，得到物理页号<br>3.将物理页号 + 页内位移 组合，得到物理地址</p>
<p>Linux 虚拟地址和物理地址映射方式：<br>Linux 系统中，每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位），所有段的起始地址都是一样的。Linux 系统中的代码，包括操作系统本身的代码和 应用程序代码，所面对的 地址空间都是线性地址空间（虚拟地址），相当于屏蔽处理器中的 逻辑地址概念，段只被用于 访问控制和内存保护。<br>Linux 本身采用的实际是段式和页式都有，但不叫段页式； linux的段和页式顺序的两个过程，只不过 段式相当于啥也不干，目的是为了保证兼容性，所以 Linux内存管理的方式实际上相当于 只有页式管理，但查询过程 经过一层段式查询。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p><strong>内存分段：</strong><br>根据程序逻辑角度，分成 栈段、堆段、数据段、代码段 等，分离出不同属性的段，同时是一块连续的空间。<br>每个段的 大小都不是统一的，这会导致 内存碎片，内存交换效率低 的问题。<br>于是出现：内存分页<br>把 虚拟空间和 物理空间分成 大小固定的页，在 Linux 系统中每一页大小为 4KB。<br>1.分页后就不会 产生细小的内存碎片。<br>2.在内存交换时，写入硬盘是 一个页或几个页，提高内存交换的效率。<br>多级页表：为解决 简单分页产生页表过大 问题，但会导致 CPU 在寻址过程中，需要 有很多层表参与，加大时间上的开销。<br>根据程序局部性原理，在 CPU 芯片中加入了 Cache 就是TLB（Translation Lookaside Buffer），负责 缓存最近常被访问的页表项，来提高 地址的转换速度。<br>Linux 系统主要采用 分页管理，但由于 Intel 处理器的发展史，Linux 系统无法避免 分段管理。于是 Linux 把所有 段的基地址设为 0，所有程序的地址空间都是 线性地址空间（虚拟地址），相当于屏蔽了 CPU 逻辑地址的概念，所以段只被用于访问控制和内存保护。<br>另外，Linxu 系统中 虚拟空间分布可分为用户态和内核态两部分，用户态：代码段、全局变量、BSS、函数栈、堆内存、映射区。</p>
<p>参考：</p>
<p>Linux 段页存储：  <a href="https://blog.csdn.net/jinking01/article/details/107098437">https://blog.csdn.net/jinking01/article/details/107098437</a></p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/UDP/Http</title>
    <url>/2022/04/10/E-%E7%BD%91%E7%BB%9C/1.TCP-UDP-Http%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="TCP-x2F-UDP-x2F-Http"><a href="#TCP-x2F-UDP-x2F-Http" class="headerlink" title="TCP&#x2F;UDP&#x2F;Http"></a>TCP&#x2F;UDP&#x2F;Http</h1><h3 id="http-中的长，短链接："><a href="#http-中的长，短链接：" class="headerlink" title="http 中的长，短链接："></a>http 中的长，短链接：</h3><p>​    在 HTTP&#x2F;1.0中 默认短连接，客户端和 服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就 中断连接。当客户端浏览器访问某个Web页中包含有其他的 Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p>
<p>​    从HTTP&#x2F;1.1起，默认长连接，用以 保持连接特性。使用长连接的 HTTP协议，会在 响应头加入这行代码：Connection:keep-alive；<br>使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间 用于传输 HTTP数据的 TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，有一个保持时间，可以设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p>
<p>HTTP 协议的长，短连接，实质上是 TCP协议的长，短连接。<br><strong>http 长连接：</strong>设置 connection 为 keep-alive ；在 header 中有个超时时间，超过此时间就断开长连接<br>长连接： 多个 http 请求复用同一个 TCP ； 频繁通信<br>短链接： 一个 http 用一个 TCP；  长时间不通信，创建，关闭都会浪费时间</p>
<p>长优点： 省去较多的 TCP建立和关闭操作，减少浪费，节约时间，对于 频繁请求资源的客户端较适合<br>短优点： 管理起来简单，存在的连接都是有用的连接，不需要额外的控制手段 </p>
<p>像 Web 网站的 http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像 web网站有大量的客户端连接 用 短连接会省一些资源，如果用长连接，同时有成千上万的用户，每个 用户都占用一个连接的话，并发量很大，资源消耗很大； 而且每个用户无需频繁操作。</p>
<h3 id="浏览器中输入一个网址-url，执行过程："><a href="#浏览器中输入一个网址-url，执行过程：" class="headerlink" title="浏览器中输入一个网址 url，执行过程："></a>浏览器中输入一个网址 url，执行过程：</h3><p>1.应用层：浏览器看是否有缓存（浏览器，本地）; 没有则通过 DNS 解析，将 域名 转成其所对应的 服务器 ip地址，确定从浏览器到服务器的一条路径<br>2.传输层：将 http 会话通过 TCP 协议封装成数据包，在 源，目的端添加 对应的端口号, 来保证端到端的可靠传输<br>3.网络层：通过 IP 协议，查找 路由表，确定如何路由线路，到达服务器<br>4.数据链路层： 通过 邻居发现协议 ND， 查找到 给定 IP 地址的 mac 地址，发送 ARP 请求查找目的地址<br>5.物理层：将 ip 数据包转换成比特流，在物理链路上传输</p>
<h3 id="Web-页面请求过程："><a href="#Web-页面请求过程：" class="headerlink" title="Web 页面请求过程："></a>Web 页面请求过程：</h3><p>1.浏览器进行DNS域名解析，得到对应的IP地址<br>2.根据这个IP，找到对应的服务器，建立连接（三次握手）<br>3.建立TCP连接后发起 HTTP请求（一个完整的 http请求报文）<br>4.服务器响应HTTP请求，浏览器得到 html代码（服务器如何响应）<br>5.浏览器解析 html代码，并请求 html代码中的资源（如js，css，图片等）<br>6.浏览器对页面进行渲染呈现给用户<br>7.服务器关闭 TCP连接（四次挥手）</p>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>1.首先会搜索浏览器自身的 DNS缓存（缓存时间比较短，大概只有1分钟，且只能容纳1000条缓存）</p>
<p>2.如果浏览器自身的缓存里面没有找到，那么浏览器会搜索系统自身的DNS缓存</p>
<p>3.如果还没有找到，那么尝试从 hosts文件里面去找</p>
<p>4.在前面三个过程都没获取到的情况下，浏览器会发起一个DNS的系统调用，向本地配置的首选DNS服务器（一般是电信运营商提供）发起域名解析请求（通过 UDP协议向 DNS的 53端口发起请求，这个请求是递归的，就是要求运营商的DNS服务器必须提供给我们该域名的IP地址）<br>DNS优化两个方面： DNS缓存, DNS负载均衡</p>
<h3 id="TCP-与-UDP-区别："><a href="#TCP-与-UDP-区别：" class="headerlink" title="TCP 与 UDP 区别："></a>TCP 与 UDP 区别：</h3><p>1.基于 TCP有连接； UDP 无连接；<br>2.TCP数据正确性，可靠传输，无差错，不丢失，不重复，且按序到达；<br>   UDP可能丢包，不可靠传输，UDP 尽最大努力交付，即不保   证可靠交付<br>   UDP没有拥塞控制，因此网络出现 拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）<br>3.UDP 程序结构较简单，速度快，适合传输大数据； TCP 速度慢，适合小数据传输<br>4.TCP面向字节流;  UDP是面向报文的<br>5.每一条 TCP连接只能是点到点的;  UDP支持一对一，一对多，多对一和多对多的交互通信<br>6.TCP首部开销 20字节;  UDP的首部开销 8个字节<br>7.TCP通信 信道是 全双工的可靠信道，UDP则是 不可靠信道</p>
<h3 id="流量控制："><a href="#流量控制：" class="headerlink" title="流量控制："></a>流量控制：</h3><p><strong>点对点  让发送速率不要过快</strong>，使接收方来得及接收;  利用 滑动窗口机制就可以实施流量控制<br><strong>原理：</strong>运用 TCP报文段中的 窗口大小字段来控制，发送方的发送窗口不能  &gt; 接收方发回的窗口大小<br>滑动窗口协议是传输层进行流控的一种措施，接收方告知发送方自己可以接受缓冲区大小（此字段越大–网络吞吐量越高），从而控制发送方的发送速度，如果接收端缓冲区面临数据溢出，窗口大小值会被设置一个更小的值通知给发送端，从而控制数据发送量（发送端根据接收端指示，进行流量控制）</p>
<p><strong>拥塞控制：</strong>整个网络解决 过多的 数据注入到网络,  导致网络崩溃,  超过负荷, 拥塞控制包含四个策略<br>防止过多的数据注入到网络中，导致网络中的 路由器或链路过载；发送方控制 拥塞窗口的原则是：只要网络 没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去； 但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p>
<h3 id="拥塞控制四个策略："><a href="#拥塞控制四个策略：" class="headerlink" title="拥塞控制四个策略："></a><strong>拥塞控制四个策略：</strong></h3><p><strong>1.慢开始：</strong>发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2,4,8 …； 慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，慢开始结束。</p>
<p><strong>2.拥塞避免：</strong>慢开始结束后 是 拥塞避免, 此时拥塞窗口 每个传输轮次 + 1,  直到 触发网络拥塞；如果出现超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始。</p>
<p><strong>3.快重传：</strong>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 快重传要求接收方在 收到一个失序的报文段后 ，立即发出重复确认，而  不是等到自己发送数据时 捎带确认；发送方只要一连收到三个重复确认ACK， 就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。<br><strong>4.快恢复：配合快重传使用</strong>，在收到三个重复确认ACK后，这种情况下只是丢失个别报文段，不是网络拥塞。因此执行快恢复，设ssthresh &#x3D; cwnd&#x2F;2 ，cwnd &#x3D; ssthresh，注意到此时直接进入 拥塞避免。 </p>
<p>注意：在采用快恢复算法时，慢开始算法只是在 TCP连接建立时和网络出现超时时才使用</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guru93o6d9j612w0gimzi02.jpg" alt="0043A64C-1752-4B59-805F-250ED799F749" width="700" height="300"  />

<h3 id="流量控制与拥塞控制-区别："><a href="#流量控制与拥塞控制-区别：" class="headerlink" title="流量控制与拥塞控制 区别："></a>流量控制与拥塞控制 区别：</h3><p><strong>相同点：</strong> 都会丢包；实现机制都是让发送方发的 慢一点，发的少一点； 提高网络性能<br><strong>不同点：</strong><br>1.丢包位置不同，流量控制丢包位置是在接收端上；  拥塞控制丢包：在路由器上<br>2.作用对象不同：流量控制对象是 接收方，防止发送方发的太快，来不及接受； 拥塞控制对象是 网络，防止发送方发的太快，造成网络拥塞，超过网络负荷。<br>3.联系：拥塞控制是一个全局性的过程，涉及网络中的所有主机，所有路由器，考虑网络负荷；流量控制是局部的，发生在端和端之间，是点到点的控制。</p>
<h3 id="TCP三次握手："><a href="#TCP三次握手：" class="headerlink" title="TCP三次握手："></a>TCP三次握手：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru9fuobcj60nr0fddh202.jpg" alt="Image" width="650" height="400" />

<p>客户端和 服务器建立的是可靠的   全双工连接：<br>客户端：确定，服务器是可以接受，发送数据<br>服务器：确定，客户端是可以接受，发送数据</p>
<p><strong>第一次握手：</strong>建立连接时，客户端发送 syn包 (syn&#x3D;j)到服务器，并进入 SYN_SEND状态，等待服务器确认；此时对于服务器而言，服务器知道自己的 “接收”能力正常，客户端的 “发送”能力正常。<br><strong>第二次握手：</strong>服务器收到 syn包，确认客户 SYN（ack&#x3D;j+1），同时自己也发送一个SYN包(syn&#x3D;k)，即SYN+ACK包 ，此时服务器进入 SYN_RECV状态；<br>此时对于客户端而言，客户端知道自己的“发送”能力正常；客户端的“接收”能力正常； 知道服务器的“发送”、“接收”能力正常<br>此时对于服务器而言，服务器知道客户端“发送”能力正常，但客户端“接收”能力不确定，同时，服务器知道自己“接收”能力正常，但“发送”能力不确定 。<br><strong>第三次握手：</strong>客户端收到服务器SYN＋ACK包，向服务器发送确认包ACK(ack&#x3D;k+1)，发送完毕后客户端和服务器进入 ESTABLISHED状态，完成三次握手。<br>此时对于服务器而言，服务器就能确定自己的“发送”能力正常，客户端的“接收”能力正常。<br>通过这样的三次握手，双方都能确定自己和对方的收，发能力正常，客户端与 服务端建立起 可靠的双工的连接，开始传送数据。</p>
<p>TCP 协议为实现可靠传输， 通信双方需要判断自己已经发送的数据包是否都被接收方收到， 如果没收到， 就需要 重传。 为了实现这个需求，就涉及到 序号（sequence number） 和 确认号（acknowledgement number） 这2个概念 。<br><strong>序列号 seq：</strong>TCP 连接中传送的数据流中每一个字节都编上一个序号，序号字段的值是 本报文段所发送的数据的第一个字节的序号。<br><strong>确认号 ack：</strong>期望收到对方下一个报文段数据的第一个字节的序号。</p>
<h3 id="四次挥手："><a href="#四次挥手：" class="headerlink" title="四次挥手："></a>四次挥手：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru9mrx5dj60ft0ap3za02.jpg" alt="C04AF208-878B-4928-A90D-ABB44B58C24C" width="650" height="400"  />

<p><strong>第一次：</strong>A 应用进程先向其 TCP发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN-WAIT-1（终止等待1）状态，等待B的确认。<br><strong>第二次：</strong>B 收到连接释放报文段后即发出确认报文段，（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），B进入CLOSE-WAIT（关闭等待）状态，此时的TCP处于半关闭状态，A到B的连接释放。<br>A 收到B的确认后，进入FIN-WAIT-2（终止等待2）状态，等待B发出的连接释放报文段。<br>此时客户端不再向服务器发送数据，服务器不再接受数据； 但服务器还会将没发送完的数据发给客户端，客户端可以继续接受服务器发来的数据。<br><strong>第三次：</strong>当B没有要发的数据时，释放报文段(FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1)，B进入LAST-ACK最后确认状态，等待A确认。<br><strong>第四次：</strong>A收到B的连接释放报文段后，对此发出确认报文段(ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1)，A进入 TIME-WAIT（时间等待）状态。此时 TCP未释放掉，需要 经过时间 等待计时器设置的时间 2MSL后，A才进入CLOSED状态。</p>
<h4 id="为什么-A-在-TIME-WAIT状态等待-2MSL的时间？"><a href="#为什么-A-在-TIME-WAIT状态等待-2MSL的时间？" class="headerlink" title="为什么 A 在 TIME-WAIT状态等待 2MSL的时间？"></a>为什么 A 在 TIME-WAIT状态等待 2MSL的时间？</h4><p>MSL 最长报文段寿命 Maximum Segment Lifetime，MSL&#x3D;2<br><strong>1.避免B 服务端无法 closed 关闭；</strong>确保有足够时间让 服务器 收到 对方的 ACK 包，一来一去就是2MSL； TCP 可靠的，服务器在 2MSL 时间后没收到ACK 会超时重传 ；ACK 报文段可能丢失，使得处于LAST-ACK状态的B 收不到对已发送的 FIN+ACK报文段的确认，B 超时重传FIN+ACK报文段，而 A 能在 2MSL时间内收到这个重传的 FIN+ACK报文段，接着 A重传一次确认，重新启动 2MSL计时器，最后A和B都进入到CLOSED状态；若A在TIME-WAIT状态不等待一段时间，而是 发送完 ACK报文段后立即释放连接，则 无法收到 B重传的FIN+ACK报文段，所以不会再发送一次确认报文段，则 B无法正常进入到CLOSED状态。</p>
<p><strong>2.避免 新旧连接混: 即 不会跟后面的 新连接混淆；</strong>  防止“ 已失效的连接请求 报文段”出现在本连接中；A 在发送完最后一个 ACK报文段后，再经过 2MSL，可以使 本连接持续时间内所产生的所有报文段 都从网络中消失，使下一个新的连接中不会出现这种旧的连接请求报文段。等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。</p>
<h4 id="为什么连接时三次握手，关闭时四次握手？"><a href="#为什么连接时三次握手，关闭时四次握手？" class="headerlink" title="为什么连接时三次握手，关闭时四次握手？"></a>为什么连接时三次握手，关闭时四次握手？</h4><p>当 Server 端收到 Client 端的 SYN连接请求报文后，可以直接 <strong>发送SYN+ACK报文</strong>。其中 ACK报文是用来应答的，SYN报文是用来同步的<br>但是关闭连接时，当 Server端收到FIN报文时，可能不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉 Client端，你发的FIN报文我收到。只有等到我 Server端所有的报文都发送完，我才能发送FIN报文，因此不能一起发送,  故需要四步握手。</p>
<h4 id="SYN泛洪（SYN-flood）攻击："><a href="#SYN泛洪（SYN-flood）攻击：" class="headerlink" title="SYN泛洪（SYN flood）攻击："></a>SYN泛洪（SYN flood）攻击：</h4><p>​    如果大量的握手请求涌向TCP服务端，而它们只发出SYN报文而不以ACK响应结束握手，服务端就要为这每一个请求都维持约一分多钟的连接去等待ACK，也就形成所谓的“半连接”。维护这些半连接是需要消耗很多服务器的网络连接资源的。如果短时间内这些资源几乎都被半连接占满，那么正常的业务请求在这期间就得不到服务，处于等待状态。如果这些半连接的握手请求是恶意程序发出，并且持续不断，那么就会导致服务端较长时间内丧失服务功能——这就形成了DoS（Denial of Service拒绝服务）攻击。</p>
<h3 id="Http的方法："><a href="#Http的方法：" class="headerlink" title="Http的方法："></a>Http的方法：</h3><p>Get, post 是客户端和服务器端进行请求-响应的常用方法<br><strong>GET 请求： 获取资源</strong><br>1.可被 缓存<br>2.保留在 浏览器历史记录中<br>3.有长度限制；URL 的最大长度是 2048 个字符<br>4.可被 收藏为书签<br>5.数据在 URL 中对所有人都是可见的<br>6.传输的表单在 url中</p>
<p><strong>POST 请求： 传输实体主体</strong><br>1.不会被缓存<br>2.不会保留在浏览器历史记录中<br>3.没有对数据长度的限制<br>4.不能 被收藏为书签<br>5.数据不会显示在 URL 中<br>6.传输的表单在request请求的 body中</p>
<p><strong>HEAD： 获取报文首部</strong></p>
<p>和GET方法类似，但服务器在响应中 只返回首部，不返回实体的主体部分；允许客户端在未获取实际资源情况下，对资源首部进行检查<br>优点：<br>1.在 不获取资源的情况下 了解资源（比如：判断其类型）；<br>2.通过查看 响应的状态码，看看某个对象是否存在；<br>3.通过查看首部，测试资源是否被修改  </p>
<p><strong>PUT： 上传文件</strong><br>由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法</p>
<h3 id="HTTP-和-HTTPs-区别："><a href="#HTTP-和-HTTPs-区别：" class="headerlink" title="HTTP 和 HTTPs 区别："></a>HTTP 和 HTTPs 区别：</h3><p>HTTP 的请求过程：<br>1.TCP 建立连接后，客户端会发送报文给服务端；<br>2.服务端接收报文并作出响应；<br>3.客户端收到响应后解析给用户；<br>HTTP协议 不适合传输一些敏感信息，比如：各种账号、密码等信息，使用http协议传输隐私信,非常不安全</p>
<p>HTTPS 在 HTTP 的基础上加入 SSL 层，HTTPS 的安全基础是 SSL，HTTPS 存在 不同于 HTTP 的默认端口和 一个加密&#x2F;身份验证层(在HTTP与 TCP之间）这个系统提供了 身份验证与加密通讯方法;  它被广泛用于万维网上安全敏感的通讯，例如交易支付等方面。</p>
<h3 id="HTTPS的请求过程："><a href="#HTTPS的请求过程：" class="headerlink" title="HTTPS的请求过程："></a>HTTPS的请求过程：</h3><p>1.客户端 发送请求到 服务端；<br>2.服务器返回 数字证书（公钥，明文数据，签名，服务器域名）<br>3.客户端 根据数字证书来验证服务器是不是自己要访问的（有效性），有效则随机生成对称加密的密钥X，并使用公钥加密密钥X，然后发送到服务端；<br>4.服务端使用 私钥解密，得到 对称密钥X ； 后续使用密钥 X 对报文加密传输</p>
<p><strong>数字证书：</strong>验证访问的 服务器网站是有效的，合法的<br><strong>签名：</strong> 验证 数字证书是有效的<br>CA 机构对数字证书中的 明文数据，做 hash ，然后使用 私钥加密得到 签名 S<br>浏览器收到 数字证书后，通过 公钥对签名 S 解密得到 T， 然后对 明文数据进行 hash 得到 T’ ；通过验证T&#x3D;&#x3D;T’ 来保证数字证书没有被篡改<br>Hash 作用：证书信息一般较长，而 hash后得到固定长度的信息(比如用 md5算法hash后得到固定的 128位的值),这样加密，解密会快很多<br><strong>数字证书公钥：</strong> 操作系统，浏览器本身会预装一些它们信任的根证书，其中会有 CA机构的根证书，这样就可以拿到它对应的 可信公钥，不是每次请求都经历一次密钥传输过程：服务器 会为每个浏览器维护一个 session ID，浏览器生成好 密钥X传给服务器，服务器把该 密钥X存到相应的 session ID，之后 浏览器每次请求都会携带 session ID，服务器根据 session ID 找到相应的密钥进行解密，加密操作。<br>        服务器端有个session ID 表，客户端第一次带着账户信息请求时，服务端查库，并产生一个 sessionID 返回给客户端，客户端之后请求时，会把 sessionID 放到cookie 中，携带cookie 请求，服务端通过校验sessionID，如果在sessionID表中，直接通过避免查库。</p>
<h4 id="HTTPS-缺点："><a href="#HTTPS-缺点：" class="headerlink" title="HTTPS 缺点："></a>HTTPS 缺点：</h4><p>1.https协议是 多次握手，导致页面 加载时间延长近50%;<br>2.https 连接 缓存不如HTTP高效，会 增加数据开销和功耗;<br>3.申请SSL 证书需要钱，功能越强大的证书费用越高;<br>4.SSL涉及到的安全算法会 消耗 CPU 资源，对服务器资源消耗较大</p>
<h4 id="http-和-https-区别："><a href="#http-和-https-区别：" class="headerlink" title="http 和 https 区别："></a>http 和 https 区别：</h4><p>1.https 是 http 协议的安全版本<br>2.http 协议的 数据传输是明文的，是不安全的;   https使用 SSL&#x2F;TLS 非对称加密协议进行加密处理， 是安全的<br>3.http 和https 使用连接方式不同，默认端口不一样，http是80，https是443<br>4.https协议对传输的数据进行加密，内容传输上使用对称加密，证书验证上使用非对称加密</p>
<h3 id="Https整体过程分为证书验证和数据传输阶段："><a href="#Https整体过程分为证书验证和数据传输阶段：" class="headerlink" title="Https整体过程分为证书验证和数据传输阶段："></a>Https整体过程分为证书验证和数据传输阶段：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guruaqnpc6j60y40u0tcd02.jpg" alt="2BD4ED6C-0A4F-49AE-AD91-A0675CDBC23C" width="700" height="500"  />

<p>​    非对称加密的 <strong>加解密效率</strong>是 非常低的，而 http 应用场景中通常 端与端之间存在大量的交互，非对称加密的效率是无法接受的。<br>在 https场景中只有 服务端保存私钥，一对公钥，私钥只能实现单向的加密和解密，所以https 中内容传输加密是 对称加密，证书验证是非对称加密。</p>
<h3 id="常见的状态码："><a href="#常见的状态码：" class="headerlink" title="常见的状态码："></a>常见的状态码：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurvv95xvsj61a60q0q8102.jpg" alt="image-20210924172152459" width="750" height="400"  />

<p>301 永久重定向；  302 暂时重定向；  网站调整； 网页移到新地址； 扩展名改变</p>
<h3 id="Cookie："><a href="#Cookie：" class="headerlink" title="Cookie："></a>Cookie：</h3><p>HTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。<br>Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。<br>Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或 IndexedDB。</p>
<h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h4><ul>
<li>会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息）</li>
<li>个性化设置（如用户自定义设置、主题等）</li>
<li>浏览器行为跟踪（如跟踪分析用户行为等）</li>
</ul>
<h3 id="Session："><a href="#Session：" class="headerlink" title="Session："></a>Session：</h3><p>​    除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。<br>Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。<br>使用 Session 维护用户登录状态的过程如下：</p>
<ul>
<li>用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中；</li>
<li>服务器验证该用户名和密码，如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID；</li>
<li>服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中；</li>
<li>客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。<br>应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。</li>
</ul>
<h3 id="Cookie-与-Session-选择"><a href="#Cookie-与-Session-选择" class="headerlink" title="Cookie 与 Session 选择"></a>Cookie 与 Session 选择</h3><ul>
<li>Cookie 只能存储 ASCII 码字符串，而 Session 则可以存储任何类型的数据，因此在考虑数据复杂性时首选 Session；</li>
<li>Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密；</li>
<li>对于大型网站，如果用户所有信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有用户信息都存储到 Session 中。#</li>
</ul>
<h3 id="RPC-与http-区别："><a href="#RPC-与http-区别：" class="headerlink" title="RPC 与http 区别："></a>RPC 与http 区别：</h3><p>RPC ： 远程调用其他计算机服务，底层使用 TCP 传输协议； 指定数据传输格式，序列化方式<br>相同点： 底层都是基于 socket 编程，使用 TCP 协议，实现远程调用，服务调用 服务<br>不同：<br>RPC ： 提供方，消费方 都使用 统一的RPC 框架（ dubbo）, 跨操作系统，同一编程语言内使用；  调用快，处理快，实现复杂<br>HTTP： 跨操作系统，跨编程语言； 通用性强， 实现简单</p>
<h3 id="区分-MSS-与-MTU："><a href="#区分-MSS-与-MTU：" class="headerlink" title="区分 MSS 与 MTU："></a><strong>区分 MSS 与 MTU：</strong></h3><p>最大传输单元（Maximum Transmission Unit, MTU）， 最大报文段长度（Maximum Segment Size ，MSS）协议用来定义最大长度的<br>MTU 应用于 数据链接层，并无具体针对的协议。 MTU限制数据链接层上可以传输的数据包的大小，也因此限制了上层（网络层）的数据包大小。例如，如果已知 某局域网的 MTU为1500字节，则在网络层的因特网协议（ IP）里最大数据包大小为 1500字节（包含IP协议头）。<br>MSS 应用于 传输层的TCP协议，因为 MSS应用的协议在数据链接层的上层，MSS会受到MTU的限制</p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/161560683">https://zhuanlan.zhihu.com/p/161560683</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>请求代理服务器--加密</title>
    <url>/2022/04/09/E-%E7%BD%91%E7%BB%9C/2.%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8-%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="请求代理服务器–加密"><a href="#请求代理服务器–加密" class="headerlink" title="请求代理服务器–加密"></a>请求代理服务器–加密</h1><p><strong>代理服务器：</strong> 提供代理服务的电脑系统或其它类型的网络终端,代替网络用户去取得网络信息。</p>
<p>使用代理的<strong>主要目的：</strong></p>
<ul>
<li><p>缓存：提高访问速度，由于目标主机返回的数据会存放在代理服务器的硬盘中，因此下一次客户再访问相同的站点数据时，会直接从代理服务器的硬盘中读取，起到缓存的作用，尤其对于热门网站能明显提高访问速度。</p>
</li>
<li><p>网络访问控制：防火墙作用，由于所有的客户机请求都必须通过代理服务器访问远程站点，因此可以在代理服务器上设限，过滤掉某些不安全信息。同时正向代理中上网者可以隐藏自己的IP,免受攻击。</p>
</li>
<li><p>突破访问限制：互联网上有许多开发的代理服务器，客户机在访问受限时，可通过不受限的代理服务器访问目标站点，通俗说，我们使用的翻墙浏览器就是利用了代理服务器，可以直接访问外网。</p>
</li>
<li><p>负载均衡，通过配置后台各个服务器的权重参数，实现多机负载</p>
</li>
</ul>
<h4 id="正向代理的应用"><a href="#正向代理的应用" class="headerlink" title="正向代理的应用"></a><strong>正向代理的应用</strong></h4><ol>
<li><p>访问原来无法访问的资源</p>
</li>
<li><p>用作缓存，加速访问速度</p>
</li>
<li><p>对客户端访问授权，上网进行认证</p>
</li>
<li><p>代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息</p>
</li>
</ol>
<h4 id="反向代理的应用"><a href="#反向代理的应用" class="headerlink" title="反向代理的应用"></a><strong>反向代理的应用</strong></h4><ol>
<li>保护内网安全</li>
<li>负载均衡</li>
<li>缓存，减少服务器的压力</li>
</ol>
<p><strong>正向代理：</strong>一个位于客户端和原始服务器之间的服务器，为了从 <strong>原始服务器取得内容</strong>，客户端向代理发送一个请求并制定目标（原始服务器），然后 <strong>代理向原始服务器转发请求</strong>并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2sm4zxj60i907mwem02.jpg" alt="img" width="450" height="200"  />

<p><strong>反向代理：</strong>以 <strong>代理服务器来接受internet上的连接请求</strong>，然后 将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2psrynj60ec076mx702.jpg" alt="img" width="450" height="200"  />

<h3 id="正向-x2F-反向区别："><a href="#正向-x2F-反向区别：" class="headerlink" title="正向&#x2F;反向区别："></a>正向&#x2F;反向区别：</h3><p><strong>1.位置不同</strong></p>
<ul>
<li><p>正向代理，架设在客户机和目标主机之间；</p>
</li>
<li><p>反向代理，架设在服务器端；</p>
</li>
</ul>
<p><strong>2.代理对象不同</strong></p>
<ul>
<li><p>正向代理，代理客户端，服务端不知道实际发起请求的客户端；</p>
</li>
<li><p>反向代理，代理服务端，客户端不知道实际提供服务的服务端；</p>
</li>
</ul>
<p><strong>3.安全性不同</strong></p>
<ul>
<li>正向代理允许客户端通过它访问任意网站并且隐藏客户端自身，因此必须采取安全措施以确保仅为授权的客户端提供服务；</li>
<li>反向代理都对外都是透明的，访问者并不知道自己访问的是哪一个代理。</li>
</ul>
<h3 id="加密技术"><a href="#加密技术" class="headerlink" title="加密技术:"></a>加密技术:</h3><p>是对信息进行编码和解码的技术，编码是把原来可读信息（明文）译成代码形式（密文），其逆过程就是解码（解密），加密技术要点是加密算法，加密算法可分为三类：</p>
<h4 id="对称加密，如AES："><a href="#对称加密，如AES：" class="headerlink" title="对称加密，如AES："></a>对称加密，如AES：</h4><p>​    基本原理：将明文分成N个组，然后使用密钥对各个组进行加密，形成各自的密文，最后把所有的分组密文进行合并，形成最终的密文。<br>​    优势：算法公开、计算量小、加密速度快、加密效率高<br>​    缺陷：双方都使用 同样密钥，安全性得不到保证</p>
<h4 id="非对称加密，如RSA："><a href="#非对称加密，如RSA：" class="headerlink" title="非对称加密，如RSA："></a>非对称加密，如RSA：</h4><p>​    基本原理：同时生成两把密钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端<br>​    私钥加密，持有 私钥、公钥才可以解密<br>​    公钥加密，持有 私钥才可解密<br>​    优点：安全，难以破解<br>​    缺点：算法比较耗时</p>
<h4 id="不可逆加密，如MD5，SHA："><a href="#不可逆加密，如MD5，SHA：" class="headerlink" title="不可逆加密，如MD5，SHA："></a>不可逆加密，如MD5，SHA：</h4><p>​    基本原理：加密过程中不需要使用密钥，输入明文后由系统直接经过加密算法处理成密文，这种加密后的数据是无法被解密的，无法根据密文推算出明文。</p>
<h4 id="1-在没有RSA加密时："><a href="#1-在没有RSA加密时：" class="headerlink" title="1.在没有RSA加密时："></a>1.在没有RSA加密时：</h4><p>在微服务架构中，可以把服务的鉴权操作放到网关中，将未通过鉴权的请求直接拦截，如图：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guru1r5iujj60mi0fc75902.jpg" alt="1527312464328" width="650" height="400"  />

<p>1.用户请求登录<br>2.Zuul将请求转发到授权中心，请求授权<br>3.授权中心校验完成，颁发JWT凭证<br>4.客户端请求其它功能，携带JWT<br>5.Zuul将jwt交给授权中心校验，通过后放行<br>6.用户请求到达微服务<br>7.微服务将jwt交给鉴权中心，鉴权同时解析用户信息<br>8.鉴权中心返回用户数据给微服务<br>9.微服务处理请求，返回响应<br>问题： 每次鉴权都需要访问鉴权中心，系统间的网络请求频率过高，效率略差，鉴权中心的压力较大。</p>
<h4 id="2-在结合RSA的鉴权："><a href="#2-在结合RSA的鉴权：" class="headerlink" title="2.在结合RSA的鉴权："></a>2.在结合RSA的鉴权：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guru2cq63ej60ma0ezt9t02.jpg" alt="1527313765010" width="650" height="400"  />

<p>1.利用RSA生成公钥和私钥，私钥保存在授权中心，公钥保存在Zuul和各个信任的微服务<br>2.用户请求登录<br>3.授权中心校验，通过后用私钥对JWT进行签名加密<br>4.返回jwt给用户<br>5.用户携带JWT访问<br>6.Zuul直接通过 公钥解密 JWT，进行验证，验证通过则放行<br>7.请求到达微服务，微服务直接用公钥解析JWT，获取用户信息，无需访问授权中心</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>防止怠慢，经常自勉</title>
    <url>/2022/04/19/Z-%E9%9A%8F%E7%AC%94/%E8%87%AA%E5%8B%89/</url>
    <content><![CDATA[<h1 id="防止怠慢，经常自勉"><a href="#防止怠慢，经常自勉" class="headerlink" title="防止怠慢，经常自勉"></a>防止怠慢，经常自勉</h1><ol>
<li><h4 id="不受些挫，永远不知道自己有多差劲！"><a href="#不受些挫，永远不知道自己有多差劲！" class="headerlink" title="不受些挫，永远不知道自己有多差劲！"></a>不受些挫，永远不知道自己有多差劲！</h4></li>
<li><h4 id="你已不再年轻，请别把自己当作一个孩子了！"><a href="#你已不再年轻，请别把自己当作一个孩子了！" class="headerlink" title="你已不再年轻，请别把自己当作一个孩子了！"></a>你已不再年轻，请别把自己当作一个孩子了！</h4></li>
<li><h4 id="做什么事情，请用心去做，不是什么事都那么随便就可以成功的！"><a href="#做什么事情，请用心去做，不是什么事都那么随便就可以成功的！" class="headerlink" title="做什么事情，请用心去做，不是什么事都那么随便就可以成功的！"></a>做什么事情，请用心去做，不是什么事都那么随便就可以成功的！</h4></li>
<li><h4 id="以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！"><a href="#以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！" class="headerlink" title="以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！"></a>以后的路还很长，你需要走的路还很远，我不希望看到一个这样的你！</h4></li>
<li><h4 id="这一路走来容易么？你经历了什么？你得到了什么？你想要什么？"><a href="#这一路走来容易么？你经历了什么？你得到了什么？你想要什么？" class="headerlink" title="这一路走来容易么？你经历了什么？你得到了什么？你想要什么？"></a>这一路走来容易么？你经历了什么？你得到了什么？你想要什么？</h4></li>
<li><h4 id="不要那么鲁莽，生活终究会为你的粗心而付出代价！"><a href="#不要那么鲁莽，生活终究会为你的粗心而付出代价！" class="headerlink" title="不要那么鲁莽，生活终究会为你的粗心而付出代价！"></a>不要那么鲁莽，生活终究会为你的粗心而付出代价！</h4></li>
<li><h4 id="有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！"><a href="#有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！" class="headerlink" title="有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！"></a>有些时候，原谅自己就是在纵容自己，有些错误，不值得原谅！</h4></li>
<li><h4 id="平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？"><a href="#平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？" class="headerlink" title="平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？"></a>平平淡淡是一生，风风雨雨是一生，常问一下自己，这是你想要的生活吗？这是你想要的人生吗？</h4></li>
<li><h4 id="要有自己的梦想，你的潜力不止于此！"><a href="#要有自己的梦想，你的潜力不止于此！" class="headerlink" title="要有自己的梦想，你的潜力不止于此！"></a>要有自己的梦想，你的潜力不止于此！</h4></li>
<li><h4 id="抱怨没有任何意义，那是曾经！我要的是未来！"><a href="#抱怨没有任何意义，那是曾经！我要的是未来！" class="headerlink" title="抱怨没有任何意义，那是曾经！我要的是未来！"></a>抱怨没有任何意义，那是曾经！我要的是未来！</h4></li>
<li><h4 id="经常总结经验，失败并不可怕，但一定要有所成长！"><a href="#经常总结经验，失败并不可怕，但一定要有所成长！" class="headerlink" title="经常总结经验，失败并不可怕，但一定要有所成长！"></a>经常总结经验，失败并不可怕，但一定要有所成长！</h4></li>
<li><h4 id="今天的怠慢在以后一定会让你加倍偿还！"><a href="#今天的怠慢在以后一定会让你加倍偿还！" class="headerlink" title="今天的怠慢在以后一定会让你加倍偿还！"></a>今天的怠慢在以后一定会让你加倍偿还！</h4></li>
</ol>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-基础</title>
    <url>/2021/06/05/A-Java%E8%AF%AD%E8%A8%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/1.%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="多线程编程-基础"><a href="#多线程编程-基础" class="headerlink" title="多线程编程-基础"></a>多线程编程-基础</h1><h4 id="Java-中创建线程方式主要有三种："><a href="#Java-中创建线程方式主要有三种：" class="headerlink" title="Java 中创建线程方式主要有三种："></a>Java 中创建线程方式主要有三种：</h4><p>1.继承 Thread 类，重写run() 方法，在run() 方法里实现内部逻辑<br>2.实现 Runnable 接口， 重写 Runnable 接口中的 run 方法，在 thread 类中传入 Runnable对象<br>3.实现 Callable 接口，重写 call() 方法，和 Future 来创建线程</p>
<h4 id="Callable-和-Runnable-接口区别："><a href="#Callable-和-Runnable-接口区别：" class="headerlink" title="Callable 和 Runnable 接口区别："></a>Callable 和 Runnable 接口区别：</h4><p>1.Runnable 不会产生任何返回值, Callable 有返回值<br>2.Callable重写 call 方法，而 Runnable 重写 run 方法。<br>3.使用 Callable 中的 call方法可以抛出异常，而 Runnable 方法不能抛出异常</p>
<p><strong>使用：</strong><br>执行 Callable方式，需要 FutureTask 实现类的支持，用于接收运算结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ThreadDemo</span> <span class="variable">td</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadDemo</span>();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(td);</span><br><span class="line"><span class="type">Integer</span> <span class="variable">sum</span> <span class="operator">=</span> result.get();</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadDemo</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;Integer&gt; &#123;..其中实现call() 方法..&#125;</span><br></pre></td></tr></table></figure>



<h3 id="可重入锁："><a href="#可重入锁：" class="headerlink" title="可重入锁："></a>可重入锁：</h3><ol>
<li>同一个线程可以反复获得同一把锁，但申请和释放锁的次数必须一致。</li>
<li>重入锁是非公平的，公平的重入锁性能差</li>
<li>重入锁内部基于CAS实现的</li>
<li>对于重入锁，可以使用 Condition类提供的await()，singal()功能，实现线程间通信<br>可重入锁优势：可以避免一些死锁的情况，更好的封装<br>可重入性：Synchronized 锁对象时，对象头关联的monitor中有个计数器，会记录下线程获取锁的次数，获得锁+1，释放锁-1，当计数器清零时就释放锁。</li>
</ol>
<p><strong>不可中断性：</strong>一个线程获取锁后，另一个线程处于阻塞或等待状态，前一个不释放，后一个则会一直阻塞或等待，不可以被中断。</p>
<h3 id="对象在-JVM-的内存中分为三块区域："><a href="#对象在-JVM-的内存中分为三块区域：" class="headerlink" title="对象在 JVM 的内存中分为三块区域："></a>对象在 JVM 的内存中分为三块区域：</h3><p><strong>1.对象头</strong><br>    * Mark Word（标记字段）：锁标志位信息…随着锁标志位的变化而变化。<br>        * Klass Point（类型指针）：指向它的类元数据的指针，虚拟机通过这个指针来确定对象是哪个类的实例。<br>    <strong>2.实例数据：</strong>存放类的数据信息，父类的信息。<br>    <strong>3.对其填充：</strong>虚拟机要求对象起始地址必须是 8字节的整数倍，为了字节对齐。<br>    问题：一个空对象占多少个字节？  8个字节，因为对齐填充的关系，不到8个字节对其填充会自动补齐。<br>    对象头关联一个monitor对象，当进入一个方法的时候，会获取当前对象的所有权，monitor进入数 +1，当前线程拥有 monitor的所有权。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurmhszvufj60ys0f8dhk02.jpg" alt="3ECABF01-27BC-4FA1-8040-EB893F1B8E08" width="550" height="250" />



<h3 id="Synchronized锁："><a href="#Synchronized锁：" class="headerlink" title="Synchronized锁："></a>Synchronized锁：</h3><p>​    在 JDK1.6之前，Synchronized 属于重量级锁，效率低。 JDK1.6之后，Synchronized 锁升级的过程：无锁、偏向锁、轻量级锁、重量级锁。随着竞争的激烈而逐渐升级，注意：锁可以升级不可降级，为了提高获得锁和释放锁的效率。<br>从无锁状态，首先进入的线程获得偏向锁，当前释放后，此时如果同一个线程再次获得锁，锁不升级，偏向于同一线程；此时如果其他线程获得锁，并产生锁的竞争，则将锁升级为轻量级锁。<br><strong>偏向锁:</strong> 采用CAS操作，每次同一线程进入，虚拟机就不进行任何同步操作，对标志位+1，不同线程过来，CAS操作失败。<br><strong>CAS操作：</strong>jvm会存储 锁对象Mark Word 拷贝，然后利用 CAS比较当前的Mark Word和保存的Mark Word，相同就说明加锁成功，改变锁标志位<br><strong>轻量级锁（自旋锁）</strong>：升级到轻量级锁后，同样也使用CAS操作判断。如果同一线程，CAS成功修改monitor中计算器+1。如果CAS操作失败，则自旋，一旦可以获取资源，就直接尝试成功，直到超出自旋阈值（10）。则自旋失败，升级为重量级锁，像1.5一样，等待唤醒。轻量级锁通过不断自旋，来防止线程被挂起；线程等待唤醒 是 用户态和内核态 的切换，此过程很耗资源，可通过自旋减少这种消耗(短时间)</p>
<h4 id="synchronized三种使用方式："><a href="#synchronized三种使用方式：" class="headerlink" title="synchronized三种使用方式："></a>synchronized三种使用方式：</h4><p>1.修饰实例方法:  在当前对象实例上加锁，进入同步代码前要获得当前对象实例的锁<br>2.修饰静态方法:  给当前类加锁，会作用于类的所有对象实例。<br>3.修饰代码块: 指定加锁对象，对给定的对象进行加锁，进入同步代码库前，先要获得 给定对象的锁。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>synchronized关键字加到 static 静态方法和 synchronized(class) 代码块上都是给 Class 类上锁<br>synchronized 关键字加到 实例方法上是给 对象实例上锁<br>尽量不要 synchronized(String a) ，因为JVM中字符串常量池具有缓存功能！</p>
<h4 id="synchronized和-ReentrantLock-的区别-（都是可重入锁）："><a href="#synchronized和-ReentrantLock-的区别-（都是可重入锁）：" class="headerlink" title="synchronized和 ReentrantLock 的区别 （都是可重入锁）："></a>synchronized和 ReentrantLock 的区别 （都是可重入锁）：</h4><p><strong>1.层次：</strong>synchronized是 JVM层面，ReentrantLock是 API层面。synchronized由jvm负责加锁，释放锁等操作，不需要我们维护；RentrantLock 是需要 lock() 和 unlock() 方法配合 try&#x2F;finally 语句块来完成<br><strong>2.中断:</strong>  synchronized是不可中断的，ReentrantLock 是可中断的，通过 lock.lockInterruptibly() 实现，可以使正在等待的线程选择放弃等待<br><strong>3.指定公平锁，非公平锁：</strong>synchronized只有非公平锁；ReentrantLock 可以通过参数设置公平，非公平锁。<br><strong>4.选择性通知（锁可以绑定多个条件）：</strong>synchronized关键字与 wait()和 notify()&#x2F;notifyAll()方法相结合可以实现 等待&#x2F;通知机制，但被通知的线程是由 JVM 选择无法控制，如果执行 notifyAll()方法会通知所有处于等待状态的线程； 用 ReentrantLock类结合 Condition实例可以实现“选择性通知” ，Condition 可以为不同线程 注册不同的 Condition实例，执行 Condition实例的 signalAll()方法时 只会唤醒注册在该Condition实例中的所有等待线程。</p>
<p><strong>Synchronized 不可逆问题：</strong><br>例：我现在是滴滴，早上有打车高峰，代码使用了大量的synchronized，锁升级过程是不可逆的，过了高峰我们还是重量级的锁，那效率降低。根据具体场景进行选择</p>
<h3 id="Volatile-可见性、有序性"><a href="#Volatile-可见性、有序性" class="headerlink" title="Volatile : 可见性、有序性"></a>Volatile : 可见性、有序性</h3><p>​    所有共享变量都存储于主内存，线程对变量的操作(读，取)是在 工作内存中完成的，而不是直接读写主内存中的变量。不同线程之间不能直接访问对方工作内存中的变量，线程间变量值的传递需要通过主内存中转来完成。 工作内存和主内存的关系：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurmicl077j60ys0l6myk02.jpg" alt="C9F41EFB-5F43-4386-80D2-396863EAC7D4" width="550" height="260"/>


<p>​    多个处理器运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那同步回到主内存时以谁的缓存数据为准呢？为解决一致性问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI等。</p>
<p><strong>MESI（缓存一致性协议）：</strong>当 CPU写数据时，如果发现操作的变量是共享变量，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，就会从内存重新读取。<br><strong>加锁可以解决可见性问题：</strong>某一个线程进入 synchronized代码块，线程获得锁，会清空工作内存，从主内存拷贝共享变量最新的值到工作内存成为副本，执行代码后，将修改后的 副本值刷新回主内存中，线程释放锁。而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。</p>
<p><strong>Volatile修饰的共享变量：</strong>volatile使用缓存一致性协议，当一个线程修改了volatile修饰的变量，立即修改写回主内存，同时发信号通知其他线程将该变量的 缓存行置为无效状态，当其他线程需要读取这个变量时，发现自己缓存中该变量的缓存行是无效的，就会从内存重新读取，得到最新数据。</p>
<p><strong>怎么发现数据是否失效呢？</strong></p>
<p>嗅探： 每个处理器通过 嗅探在总线上传播的数据来检查自己缓存的值是不是过期，当处理器发现自己缓存行对应的内存地址被修改，就会将当前自己的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。</p>
<h5 id="总线风暴：由于Volatile的-MESI缓存一致性协议，需要不断的从主内存嗅探和-cas-不断循环，无效交互会导致总线带宽达到峰值。-所以不要大量使用Volatile。"><a href="#总线风暴：由于Volatile的-MESI缓存一致性协议，需要不断的从主内存嗅探和-cas-不断循环，无效交互会导致总线带宽达到峰值。-所以不要大量使用Volatile。" class="headerlink" title="总线风暴：由于Volatile的 MESI缓存一致性协议，需要不断的从主内存嗅探和 cas 不断循环，无效交互会导致总线带宽达到峰值。 所以不要大量使用Volatile。"></a>总线风暴：由于Volatile的 MESI缓存一致性协议，需要不断的从主内存嗅探和 cas 不断循环，无效交互会导致总线带宽达到峰值。 所以不要大量使用Volatile。</h5><h3 id="有序性：禁止指令重排序"><a href="#有序性：禁止指令重排序" class="headerlink" title="有序性：禁止指令重排序"></a>有序性：禁止指令重排序</h3><p>什么是重排序?  为了提高处理速度，JVM会对代码进行编译优化，也就是指令重排序优化，并发编程下指令重排序会带来一些安全隐患：如 指令重排序导致的多个线程操作之间的不可见性</p>
<p>如何保证不会被重排序呢？<strong>内存屏障</strong></p>
<p>Volatile借助Java编译器，在 生成指令系列时的适当位置插入 内存屏障 指令，来 禁止特定类型的处理器重排序。<br>Volatile 写：在前面和后面分别插入内存屏障； 而volatile读：在后面插入两个内存屏障。 </p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurmjarwfnj60na0iw3zq02.jpg" alt="68623192-B95E-4B38-BC96-08E01C1252D1" width="550" height="350" />

<p><strong>Volatile 无法保证原子性</strong><br>要实现原子性操作，可以考虑加锁、原子类，比如 AtomicInteger；</p>
<h4 id="volatile与synchronized的区别"><a href="#volatile与synchronized的区别" class="headerlink" title="volatile与synchronized的区别:"></a>volatile与synchronized的区别:</h4><p>1.volatile只能修饰 变量（实例变量、类变量），而 synchronized可以修饰 方法，以及代码块。<br>2.volatile保证数据的可见性，但不保证原子性(多线程同时进行写操作，不保证线程安全);  synchronized 两者都能保证。<br>3.volatile 主要解决变量在多个线程之间的可见性，而 synchronized主要解决多线程之间访问资源的同步性。<br>4.多线程访问 volatile不会发生阻塞，而synchronized 可能会发生阻塞。</p>
<p>volatile可以看做是轻量版的synchronized，volatile不保证原子性。<br>如果一个共享变量进行多个线程的赋值，没有其他操作，那可以用volatile来代替synchronized，因为赋值本身是原子性的，而volatile又保证可见性，所以可以保证线程安全。</p>
<h3 id="使用场景："><a href="#使用场景：" class="headerlink" title="使用场景："></a>使用场景：</h3><ol>
<li>某个属性被多个线程共享，其中一个线程修改后，其 他线程可以立即得到修改后的值</li>
<li>volatile提供可见性，任何一个线程对其的修改将立马对其他线程可见，volatile属性不会被线程缓存，始终从主存中读取。</li>
<li>volatile可以使得 long和double的赋值是原子的。</li>
<li>Volatile可以在 单例双重检查中实现可见性和 禁止指令重排序，从而保证安全性。</li>
</ol>
<p>Volatile 禁止指令重排序好处:  创建对象需要几个步骤：</p>
<p>1.分配内存空间;   2.调用构造器，初始化实例 ;  3.返回地址给引用</p>
<p>​        在执行时可能发生指令重排序，有可能 构造函数在对象初始化完成前就赋值完成，在内存里开辟一片存储区域后直接返回内存的引用，这个时候还没真正的初始化完对象。但是别的线程去判断 instance!&#x3D;null，直接拿去用了，其实这个对象是个半成品，那就有空指针异常了。</p>
<h3 id="常见的线程池种类："><a href="#常见的线程池种类：" class="headerlink" title="常见的线程池种类："></a>常见的线程池种类：</h3><p><strong>SingleThreadPool 单个线程：</strong>若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。<br><strong>FixedThreadPool 固定线程数量：</strong>线程数量始终不变。当一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，新任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。<br><strong>CachedThreadPool 动态分配线程数量：</strong>根据具体的任务数量来调整线程数量的线程池，若有空闲线程可以复用，会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</p>
<h4 id="线程池的构建方法："><a href="#线程池的构建方法：" class="headerlink" title="线程池的构建方法："></a>线程池的构建方法：</h4><p>1.构造方法实现： ThreadPoolExecutor(6个参数)<br>2.使用 Executor 框架的工具类 Executors来实现</p>
<h4 id="线程池的参数，ThreadPoolExecutor-构造函数重要参数："><a href="#线程池的参数，ThreadPoolExecutor-构造函数重要参数：" class="headerlink" title="线程池的参数，ThreadPoolExecutor 构造函数重要参数："></a>线程池的参数，ThreadPoolExecutor 构造函数重要参数：</h4><p><strong>1.corePoolSize :</strong>  核心线程数，定义最小可以同时运行的线程数量。核心线程数，默认情况下，核心线程会一直存活，但是当将allowCoreThreadTimeout 设置为true时，核心线程也会超时回收。<br><strong>2.maximumPoolSize :</strong>  当队列中存放的任务达到队列容量的时候，可以同时运行的线程数量变为最大线程数。<br><strong>3.workQueue:</strong>  缓存队列当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务会被存放在队列中。<br><strong>4.keepAliveTime:</strong> 当线程池中的线程数量大于 corePoolSize 时，此时如果没有新任务提交，核心线程外的线程 不会立即销毁，而是等待直到时间超过 keepAliveTime才会被回收销毁；<br><strong>5.unit :</strong>  keepAliveTime 参数的时间单位。<br><strong>6.handler :</strong> 饱和策略；当线程数量达到maximumPoolSize，并且workQueue中任务满时，执行饱和操作。</p>
<h4 id="ThreadPoolExecutor-饱和策略："><a href="#ThreadPoolExecutor-饱和策略：" class="headerlink" title="ThreadPoolExecutor 饱和策略："></a>ThreadPoolExecutor 饱和策略：</h4><p>1.ThreadPoolExecutor.DiscardPolicy： 不处理新任务，直接丢弃掉。<br>2.ThreadPoolExecutor.DiscardOldestPolicy： 此策略将 丢弃最早的未处理的任务请求。<br>3.ThreadPoolExecutor.AbortPolicy：抛出 RejectedExecutionException 异常，拒绝新任务的处理。<br>4.ThreadPoolExecutor.CallerRunsPolicy：增加队列容量，调用执行自己的线程运行任务。如果应用程序可以承受此延迟并且不允许丢弃任何一个任务请求，可以选择。这种策略会降低对于新任务提交速度，影响程序的整体性能。</p>
<h4 id="阻塞队列："><a href="#阻塞队列：" class="headerlink" title="阻塞队列："></a>阻塞队列：</h4><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。<br>1）支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。<br>2）支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。<br>        阻塞队列常用于生产者和消费者的场景，生产者是向队列里添加元素的线程，消费者是从队列里取元素的线程。阻塞队列就是生产者用来存放元素、消费者用来获取元素的容器。<br><strong>非阻塞队列：</strong>入队和出队操作均利用CAS（compare and set）更新，这样允许多个线程并发执行，并且不会因为加锁而阻塞线程，使得并发性能更好。<br>2.LinkedBlockingQueue可以高效的处理并发数据，这是因为生产者和消费者端分别采用了独立的锁来控制数据同步，所以在高并发的情况下生产者和消费者可以并行地操作队列中的数据，从而提高整个队列的并发性能。</p>
<p>3.如果没有给 LinkedBlockingQueue 指定其容量大小，则默认为 Integer.MAX_VALUE，这样的话，如果生产者的速度大于消费者的速度，则可能还没等到队列阻塞，系统内存就被消耗完了，从而导致内存溢出</p>
<h3 id="线程池中线程数量的设置："><a href="#线程池中线程数量的设置：" class="headerlink" title="线程池中线程数量的设置："></a>线程池中线程数量的设置：</h3><p>CPU密集型的任务：较小线程数<br>IO密集型的任务：较多线程数<br>由于 IO操作不占用CPU，不能让CPU闲。但如果线程数目太多，线程切换所带来的开销也会对系统的响应时间带来影响。</p>
<p>线程等待时间所占比例越高，需要越多线程。线程CPU时间 所占比例越高，需要越少线程。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU 的使用率 50% （ 线程CPU时间/(线程等待时间+线程CPU时间）），那么这段时间可以运行 2 个IO任务</span><br><span class="line"></span><br><span class="line">最佳线程数目  = （（ 线程等待时间+线程CPU时间）/ 线程CPU时间 ）* CPU数目</span><br></pre></td></tr></table></figure>



<p><strong>Atomic 原子类 （一个操作是不可中断的）：</strong><br>AtomicInteger 类主要利用 CAS + volatile 来保证原子操作，避免 synchronized 的高开销，提升执行效率。</p>
<p>JUC 包中的4种 原子类：基本类型：AtomicInteger：整形原子类 等；数组类型：AtomicIntegerArray：整形数组原子类； 引用类型：AtomicReference：引用类型原子类；</p>
<h4 id="线程中常用的方法："><a href="#线程中常用的方法：" class="headerlink" title="线程中常用的方法："></a>线程中常用的方法：</h4><p> .join() 方法（类似中断）： 导致当前运行的线程停止执行，直到它加入的线程完成其任务，调用 join 时带上一个超时参数，来设置到期时间，时间到期 join方法自动返回。类似于中断，先执行其他线程，再返回来执行原来这个。</p>
<h4 id="execute-和-submit-的区别："><a href="#execute-和-submit-的区别：" class="headerlink" title="execute() 和 submit() 的区别："></a>execute() 和 submit() 的区别：</h4><ol>
<li>execute() 无返回值，无法判断任务 是否被线程池执行成功。</li>
<li>submit() 有返回值， 线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以 判断任务是否执行成功，并且通过 Future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成。</li>
</ol>
<h4 id="start-run-区别："><a href="#start-run-区别：" class="headerlink" title="start(),  run() 区别："></a>start(),  run() 区别：</h4><p>1.调用 Thread.start( ) 方法启动一个线程，此线程是处于 就绪状态，并没有运行<br>2.然后通过此 Thread类来调用 run() 方法，完成其运行操作，run() 称为线程体，它包含这个线程要执行的内容，run()方法运行结束，此线程终止，之后CPU再运行其它线程。run()方法当作普通方法的方式调用，程序还是要顺序执行，还是要等待run方法体执行完毕后才可继续执行后续代码。<br>如果直接用Run方法，这只是调用一个方法而已，程序中依然只有主线程–这一个线程，其程序执行路径还是只有一条，这样就没有达到多线程目的。<br>run() 只是在当前线程中执行任务，而 start才是 真正生成thread，并放在cpu中调度。</p>
<p>参考：<a href="https://blog.csdn.net/xyy1028/article/details/107801358">https://blog.csdn.net/xyy1028/article/details/107801358</a></p>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>Java语言</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-高级</title>
    <url>/2021/06/06/A-Java%E8%AF%AD%E8%A8%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="多线程-高级"><a href="#多线程-高级" class="headerlink" title="多线程-高级"></a>多线程-高级</h1><p><strong>CAS（Compare And Swap 比较并且替换）</strong>是乐观锁的一种实现方式，线程在读取数据时不进行加锁，<br>先保存原值，在实际修改数据的瞬间，比较此时的值，是否和原值相等。若相等则回写；若不相等，则重新执行读取流程。</p>
<h3 id="CAS产生的问题："><a href="#CAS产生的问题：" class="headerlink" title="CAS产生的问题："></a>CAS产生的问题：</h3><p><strong>一、CAS可能有 ABA问题：</strong> （破坏了事务的原子性）</p>
<ol>
<li>线程1 读取数据A</li>
<li>线程2 读取数据A，把数据A改成数据B</li>
<li>线程3 读取数据B，把数据 B 又改回数据A</li>
<li>线程1 通过CAS比较，发现数据还是 A没变，就写成了自己要改的值</li>
</ol>
<p>解决：加标志位（类似版本号），设置 自增字段，操作一次自增+1；或搞个时间戳，比较时间戳的值；<br>每次修改： 数据+版本号；版本号递增，校验时同时校验： 数据 + 版本号<br>例如：操作数据库，根据CAS原则本来只要查询原本的值，现在需要一同查出他的标志位版本字段 vision</p>
<p><strong>二、长时间循环等待：</strong>CAS 长时间不成功的话，会导致一直自旋（死循环），CPU开销较大。<br><strong>三、只保证 一个共享变量的原子操作：</strong><br>CAS操作单个共享变量赋值时 可以保证原子操作，但多个变量就不行；</p>
<h3 id="Atomic-相关类："><a href="#Atomic-相关类：" class="headerlink" title="Atomic 相关类："></a>Atomic 相关类：</h3><p>AtomicInteger，AtomicBoolean 等 java.util.concurrent包下面的类，只能并发修改一个属性<br>AtomicInteger 类利用 CAS + volatile 和 native 方法 来保证原子操作，避免 synchronized 的高开销，执行效率大为提升。<br>内部使用 UnSafe 类 objectFieldOffset() 一个本地方法，可以得到 “原来的值”的内存地址，返回值 valueOffset； value 是一个volatile变量，在内存中可见，JVM 可以保证 任何时刻，任何线程 总能拿到该变量的最新值。</p>
<p>AtomicReference：<br>AtomicReference 可以保证 对象操作的原子性；不单单仅限于 Integer, Boolean, Long等类型<br>和 AtomicInteger 类似，AtomicInteger是 对整数的封装，而 AtomicReference 则是对普通对象的引用，它可以保证在修改对象引用时的线程安全性。 AtomicReference原子性的作用是对  ”对象”进行原子操作；提供一种 读 和 写都是原子性的对象引用变量。</p>
<p>原理： 通过 “volatile” 和 “Unsafe 提供的 CAS函数实现”原子操作</p>
<ol>
<li>value是 volatile类型，保证当某个线程修改 value值时，其他线程看到的 value值都是最新的，即修改之后的volatile的值</li>
<li>通过 CAS设置value，保证当某个线程池通过CAS函数(如compareAndSet)设置value时，操作是原子的，即线程在操作value时不会被中断<br>需要借用Unsafe类的原子操作<br>使用场景：当涉及到 比较，设置等，多于一个操作时，使用AtomicReference ；</li>
</ol>
<p>升级： AtomicStampedReference类通过引入 时间戳作为数据的版本号，来解决ABA 问题。</p>
<p><strong>悲观锁：</strong>访问共享资源前，先要上锁，认为多线程同时修改共享资源的概率高，容易出现冲突<br><strong>互斥锁：</strong>一个线程获得锁，其他线程无法再次获得，挂起等待锁的释放；加锁失败时，会做「线程切换」，当加锁失败的线程再次加锁成功，这一过程会有两次线程上下文切换的成本，性能损耗大。<br><strong>自旋锁：</strong>加锁失败时不会主动产生线程切换，忙等待直到获得锁；如果被锁代码执行时间短，那忙等待的时间相对应也短。</p>
<p><strong>读写锁：</strong><br>原理：当「写锁」没有被线程持有时，多个线程能够并发的持有读锁，提高共享资源访问效率；因为「读锁」是用于读取共享资源，多个线程同时持有读锁不会破坏共享资源。一旦「写锁」被线程持有，读线程获取读锁的操作会被阻塞，其他写线程获取写锁的操作也会被阻塞。写锁是独占锁，因为任何时刻只能有一个线程持有写锁，类似互斥锁和自旋锁；读锁是共享锁，因为读锁可以被多个线程同时持有。<br>应用场景：<strong>在读多写少</strong></p>
<p>读写锁可以分为「读优先锁」和「写优先锁」<br><strong>读优先锁 ：</strong>期望读锁能被更多的线程持有，提高读线程的并发性。方式：当读线程A 持有读锁，写线程B 在获取写锁时会被阻塞，在阻塞过程中，后续来的读线程C 仍可以成功获取读锁，直到读线程A 和C 释放读锁后，写线程B 才可以成功获取读锁。<br><strong>写优先锁：</strong>优先服务写线程；方式：读线程A 先持有读锁，写线程B 在获取写锁时会被阻塞，阻塞过程中，后续读线程C 获取读锁时会失败，被阻塞在获取读锁的操作上，这样只要读线程A 释放读锁，写线程B 就可以成功获取读锁。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>读优先锁：对于读线程并发性更好，但可能出现 写线程「饥饿」的现象。<br>写优先锁：保证写线程不会饿死，但如果一直有写线程获取写锁，读线程也会被「饿死」。<br>解决：公平读写锁，用队列把获取锁的线程排队，读，写线程都按照先进先出原则加锁，这样就不会出现「饥饿」现象。</p>
<h4 id="乐观锁："><a href="#乐观锁：" class="headerlink" title="乐观锁："></a>乐观锁：</h4><p>乐观锁：假定冲突的概率很低，先修改共享资源，再验证这段时间 内有没有发生冲突。没有其他线程修改，则操作成功；发现有其他线程修改，则放弃本次操作。<br>使用场景：<strong>在冲突概率低，加锁成本高</strong><br>冲突概率上升，不适合乐观锁，因为解决冲突的重试成本非常高。<br>注意：加锁代码的范围尽可能的小，加锁的粒度要小，这样执行速度会比较快。</p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal :"></a>ThreadLocal :</h3><p>数据隔离，填充的数据只属于当前线程，变量数据对别的线程而言是相对隔离的，多线程环境下，防止自己的变量被其它线程修改。</p>
<h3 id="存储结构："><a href="#存储结构：" class="headerlink" title="存储结构："></a>存储结构：</h3><p>​    value 实际上存储在ThreadLocalMap中，ThreadLocalMap 是ThreadLocal的一个 静态内部类，它的 key是 ThreadLocal实例对象，value是任意Object对象。每个线程实例都对应一个 TheadLocalMap实例，在同一个线程里实例化很多 ThreadLocal来存储很多种类型的值，这些ThreadLocal实例分别作为key，对应各自的value，存储在 Entry table 数组中。<br>set获取当前线程的ThreadLocalMap，然后往map里添加 KV，K是当前ThreadLocal实例，V是我们传入的value<br>get获取当前线程对应的私有变量，是之前set或通过 initialValue的值</p>
<p>​    ThreadLocal 能做到线程间的数据隔离，别的线程使用get() 方法没办法拿到其他线程的值. 每个线程 Thread 都维护自己的threadLocals变量，在每个线程创建 ThreadLocal 时，实际上数据是存在 线程Thread的 threadLocals中的 ThreadLocalMap 里，别人没办法拿到，从而实现隔离。</p>
<h4 id="ThreadLocal内存模型原理："><a href="#ThreadLocal内存模型原理：" class="headerlink" title="ThreadLocal内存模型原理："></a><strong>ThreadLocal内存模型原理：</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurotiajlqj60mg0bc3yz02.jpg" alt="37DE7955-FB83-46CD-BC0C-8B432E31AA15" width="550" height="250"/>

<p>线程的一些局部变量和引用：Stack（栈）区；  普通对象：Heap（堆）区<br>1.线程运行时，定义的 TheadLocal对象被初始化，存储在Heap，同时线程运行的栈区保存指向该实例的引用，也就是图中的ThreadLocalRef。<br>2.当 ThreadLocal的 set &#x2F; get 被调用时，虚拟机会根据当前线程引用，查看对应的TheadLocalMap实例是否被创建，如果没有则创建并初始化<br>3.虚线，表示 key对应的 ThreadLocal实例的引用是个弱引用。</p>
<p><strong>建议：</strong><br>1.需要 存储 线程私有变量的时<br>2.需要实现 线程安全的变量时<br>3.需要 减少线程资源竞争的时</p>
<h4 id="ThreadLocalMap底层使用数组，如何解决Hash冲突？"><a href="#ThreadLocalMap底层使用数组，如何解决Hash冲突？" class="headerlink" title="ThreadLocalMap底层使用数组，如何解决Hash冲突？"></a>ThreadLocalMap底层使用数组，如何解决Hash冲突？</h4><p>一个线程可以有多个 TreadLocal 来存放不同类型的对象，他们都放到当前线程的 ThreadLocalMap里，一个线程一个数组来存。ThreadLocalMap存储时，给每一个ThreadLocal对象一个 threadLocalHashCode，插入过程中根据 ThreadLocal对象的hash值，定位到 table中的位置id ，然后判断当前位置 是否为空，为空就初始化一个Entry对象放在位置id上；</p>
<p>如果位置id 不空，这个Entry对象的 key &#x3D; 计算出来的hash值，则更新 Entry中的value；<br>如果位置id 不空，且 Entry 对象的 key !&#x3D;计算出来的hash值， 则找下一个空位置。<br>set和get如果冲突严重的话，效率会降低。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurou020ddj611g0l6ac102.jpg" alt="440644C2-998F-49CA-80DA-BA894E6BD00D" width="600" height="280" />

<p><strong>ThreadLocal 实例及其值存放在哪？</strong> ThreadLocal实例实际上被其创建的类持有，而ThreadLocal的值是被线程实例持有，位于堆上，只是通过一些技巧将 可见性修改成了线程可见。</p>
<p>如何共享 一个线程的ThreadLocal数据？ 使用 Inheritable ThreadLocal可以实现多个线程访问ThreadLocal的值。例：在主线程中创建一个InheritableThreadLocal实例，在 子线程中得到这个Inheritable ThreadLocal实例设置的值。</p>
<h3 id="ThreadLocal-内存泄漏："><a href="#ThreadLocal-内存泄漏：" class="headerlink" title="ThreadLocal 内存泄漏："></a>ThreadLocal 内存泄漏：</h3><p>ThreadLocalMap 使用的 key 为 ThreadLocal 的弱引用, 而 value 是强引用。如果ThreadLocal 没有被外部强引用，在垃圾回收时 key 会被清理掉，而 value 不会被清理掉。这样 ThreadLocalMap 中会出现 key为null的Entry。假如不做任何措施，value 永远无法被GC 回收，导致内存泄露。<br>解决：每次使用完 ThreadLocal，调用 remove()方法，清除数据。</p>
<p>ThreadLocalMap的key 为什么设计成弱引用？</p>
<p>如果 key不设置成 弱引用，会造成 entry中 value一样内存泄漏的场景。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guroufjdoej611a0diwfp02.jpg" alt="A3923F60-AE72-4D55-B680-B9BC54CEDD23" width="550" height="250" />



<h4 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch:"></a>CountDownLatch:</h4><p>允许一个或 多个线程一直等待，直到 count&#x3D;0，唤醒所有线程。<br>一个线程调用await() 时，阻塞当前线程。有线程调用一次 countDown() 时，计数 -1。当 count &#x3D; 0 时，被阻塞线程全部唤醒。</p>
<h4 id="CyclicBarrier-barrier-障碍-cyclic-循环）"><a href="#CyclicBarrier-barrier-障碍-cyclic-循环）" class="headerlink" title="CyclicBarrier  (barrier 障碍, cyclic 循环）"></a>CyclicBarrier  (barrier 障碍, cyclic 循环）</h4><p>一组线程互相等待，直到所有线程都到达一个同步点。<br>例：一组运动员比赛 100米，当所有人都准备完成之后，才可以一起开跑。</p>
<p><strong>CountDownLatch 和CyclicBarrier 区别：</strong></p>
<p>1.CountDownLatch 是一个线程等待其他线程， CyclicBarrier 多个线程互相等待。<br>2.CountDownLatch  计数 -1 直到 0，CyclicBarrier 计算 +1，直到指定值。<br>3.CountDownLatch 是一次性的， CyclicBarrier  可以循环利用。</p>
<h4 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h4><p>ReentrantLock、ReentrantReadWriteLock、CountDownLatch 都是基于AQS实现的</p>
<p><strong>AQS实现原理：</strong>AQS中维护一个 volatile int state（共享资源）和 一个 FIFO线程等待队列（多线程争用资源被阻塞时会进入此队列）。<br>state 初始化 0，多线程条件下线程要执行 临界区的代码，首先获取 state。 某个线程获取成功后， state +1，其他线程再获取的话，由于共享资源已被占用，将阻塞线程放到 FIFO 等待队列 中，等占有 state 的线程执行完，释放资源( state -1)后，会唤醒 FIFO 中下一个等待线程去获取 state。</p>
<p> state 由于是多线程共享变量，所以定义成 volatile，保证 state 可见性, 并通过 CAS 来保证其并发修改的安全性。FIFO 等待队列是一个双向链表，head 结点代表当前占用的线程，其他节点由于暂时获取不到锁，依次 排队等待锁的释放</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurouysglyj61100fgwff02.jpg" alt="5A584450-F81D-4DEC-8C2A-8BBEE7DD5371" width="600" height="280" />



<p>AQS定义两种资源共享方式<br>1.Exclusive（独占）：只有一个线程执行； 如ReentrantLock，可分为公平锁和非公平锁：</p>
<p>**公平锁：按照线程在队列中的排队顺序，先到者先得锁</p>
<p>**非公平锁：获取锁时，无视队列顺序直接抢锁，谁抢到是谁的</p>
<p>2.Share（共享）：多线程同时执行，如CountDownLatch</p>
<p>​    获取独占式锁过程对做个总结: AQS的模板方法acquire通过调用子类自定义实现的tryAcquire获取同步状态失败后-&gt;将线程构造成Node节点(addWaiter)-&gt;将Node节点添加到同步队列对尾(addWaiter)-&gt;节点以自旋的方法获取同步状态(acquirQueued)。在节点自旋获取同步状态时，只有其前驱节点是头节点的时候才会尝试获取同步状态，如果该节点的前驱不是头节点或者该节点的前驱节点是头节点单获取同步状态失败，则判断当前线程需要阻塞，如果需要阻塞则需要被唤醒过后才返回。</p>
<p>AQS 内部维护一个线程的队列。队列由内部的节点组成。<br>队列的节点为Node,节点分为SHARED和EXCLUSIVE分别时共享模式的节点和独占模式的节点。<br>节点的等待状态为waitStatus</p>
<ul>
<li><p>CANCELLED(1):取消状态，当线程不再希望获取锁时，设置为取消状态</p>
</li>
<li><p>SIGNAL(-1):当前节点的后继者处于等待状态，当前节点的线程如果释放或取消了同步状态，通知后继节点</p>
</li>
<li><p>CONDITION(-2):等待队列的等待状态，当调用signal()时，进入同步队列</p>
</li>
<li><p>PROPAGATE(-3): 共享模式，同步状态的获取的可传播状态</p>
</li>
<li><p>0：初始状态</p>
<p>AQS共享模式和 独占模式的实现上最大的差别就在于共享模式获取锁后的传播。其他的区别主要还是表现在实现类实现的区别上。通过ReentrantLock和ReentrantReadWriteLock可以了解AQS的独占模式和共享模式，但是要注意将AQS和锁的实现剥离开，弄明白哪些逻辑是AQS实现的，哪些逻辑是锁实现的，同时也思考怎么使用AQS实现其他的特定的线程同步问题。</p>
</li>
</ul>
<h3 id="公平锁和非公平锁："><a href="#公平锁和非公平锁：" class="headerlink" title="公平锁和非公平锁："></a>公平锁和非公平锁：</h3><p>非公平锁和公平锁的区别：非公平锁性能高于公平锁性能。非公平锁可以减少 CPU唤醒线程的开销，整体的吞吐效率会高点，CPU不必 唤醒所有线程，减少唤起线程的数量<br><strong>问题：</strong>非公平锁存在线程饥饿的情况，可能某个线程一直获取不到锁.</p>
<h3 id="AQS-组件："><a href="#AQS-组件：" class="headerlink" title="AQS 组件："></a>AQS 组件：</h3><p>1.Semaphore(信号量)-允许多线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源<br>2.CountDownLatch ： 一个同步工具类，协调多线程之间的同步。用来控制线程等待，让某一个线程等待直到倒计时结束，再开始执行。<br>3.CyclicBarrier ： CyclicBarrier 和 CountDownLatch 类似，可以实现线程间的等待，但功能比 CountDownLatch 更复杂和强大。<br>主要应用场景和 CountDownLatch 类似，CyclicBarrier 可以让 一组线程到达一个屏障（同步点）时被阻塞，直到 最后一个线程到达屏障时，屏障才会打开，所有被屏障拦截的线程才会继续执行。<br>CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，参数表示 屏障拦截的线程数量，每个线程调用await()方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p>
<p>排他锁：只有一个线程可以访问共享变量；<br>共享锁：允许多个线程同时访问<br>重入锁是排他的；信号量是共享的</p>
<p><strong>AQS内部结构：</strong>AQS中有一个同步等待队列，保存等待在这个锁上的线程。<br>为了维护等待在 条件变量上的等待线程，AQS维护一个条件变量等待队列，就是由 Condition.await() 引起阻塞的线程。一个重入锁可以生成 多个条件变量对象，因此一个重入锁 可能有多个条件变量等待队列。每个条件变量对象内部都维护一个等待列表。</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurowjlkbcj610o0pctbc02.jpg" alt="D087E893-6647-40B7-8FE2-31AC3634D7A5" width="300" height="230" />     <img src="https://tva1.sinaimg.cn/large/008i3skNly1gurovk1mmcj60sk0p4jsr02.jpg" alt="926080CA-1FDD-480D-9FF1-E91DE7EF8034" width="300" height="220" /></p>
<p>同步等待队列，条件变量等待队列，都使用 同一个 Node类作为链表的节点<br>Node 中包括链表的上一个元素 prev，下一个元素next 和线程对象thread，对于条件变量等待队列，还使用nextWaiter表示下一个等待在条件变量队列中的节点。</p>
<h3 id="Condition-："><a href="#Condition-：" class="headerlink" title="Condition ："></a>Condition ：</h3><p>Condition是用来替代Object的 wait()，notify() 方法的，使用Condition中await()，signal()可以更加安全，高效的实现线程间协作。</p>
<h4 id="Condition-和-wait-x2F-notify-比较："><a href="#Condition-和-wait-x2F-notify-比较：" class="headerlink" title="Condition 和 wait&#x2F;notify 比较："></a>Condition 和 wait&#x2F;notify 比较：</h4><p>1.Condition 可以精准的 对多个不同条件进行控制，wait&#x2F;notify 只能和 synchronized关键字一起使用，只能唤醒一个或全部的等待队列；<br>2.Condition 使用 Lock进行控制，使用后要 unlock()，Condition 有类似于 await 的机制，不会因为加锁而产生死锁问题，底层实现park&#x2F; unpark 机制，不会产生死锁，但wait&#x2F;notify 可能会产生先唤醒再挂起的死锁。</p>
<ol>
<li>对系统资源占用不同：虽然都释放了CPU，但阻塞的进程仍处于内存中，而挂起的进程通过“对换”技术被换出到外存（磁盘）中。 </li>
<li>发生时机不同：阻塞一般在进程等待资源（IO资源、信号量等）时发生；而挂起是由于用户和系统的需要，例如，终端用户需要暂停程序研究其执行情况或对其进行修改、OS为了提高内存利用率需要将暂时不能运行的进程（处于就绪或阻塞队列的进程）调出到磁盘 </li>
<li>恢复时机不同：阻塞要在等待的资源得到满足（例如获得了锁）后，才会进入就绪状态，等待被调度而执行；被挂起的进程由将其挂起的对象（如用户、系统）在时机符合时（调试结束、被调度进程选中需要重新执行）将其主动激活</li>
</ol>
<p>一般线程中的阻塞：</p>
<p>A、线程执行了Thread.sleep(int millsecond);方法，当前线程放弃CPU，睡眠一段时间，然后再恢复执行<br>B、线程执行一段同步代码，但是尚且无法获得相关的同步锁，只能进入阻塞状态，等到获取了同步锁，才能回复执行。<br>C、线程执行了一个对象的wait()方法，直接进入阻塞状态，等待其他线程执行notify()或者notifyAll()方法。<br>D、线程执行某些IO操作，因为等待相关的资源而进入了阻塞状态。比如说监听system.in，但是尚且没有收到键盘的输入，则进入阻塞状态。</p>
<h4 id="非公平锁和公平锁的区别："><a href="#非公平锁和公平锁的区别：" class="headerlink" title="非公平锁和公平锁的区别："></a><strong>非公平锁和公平锁的区别：</strong></h4><p>非公平锁性能高于公平锁性能。非公平锁可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量<br>非公平锁性能虽然优于公平锁，但是会存在导致线程饥饿的情况。在最坏的情况下，可能存在某个线程一直获取不到锁。不过相比性能而言，饥饿问题可以暂时忽略，这可能就是ReentrantLock默认创建非公平锁的原因之一了</p>
<p>多线程编程详解： <a href="https://blog.csdn.net/mu_wind/article/details/113806680">https://blog.csdn.net/mu_wind/article/details/113806680</a></p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-详解知识点</title>
    <url>/2021/06/08/A-Java%E8%AF%AD%E8%A8%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/4.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E8%AF%A6%E8%A7%A3%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="多线程-详解知识点"><a href="#多线程-详解知识点" class="headerlink" title="多线程-详解知识点"></a>多线程-详解知识点</h1><h4 id="1-线程"><a href="#1-线程" class="headerlink" title="1. 线程:"></a><strong>1. 线程:</strong></h4><p>是 CPU 进行 运算调度的最⼩基本单位，包含在进程之中，没有 独立的资源，共享其进程中的资源，每个线程都有 自己独立的 运行栈和程序计数器（PC），线程之间切换的开销小，系统不会为线程分配内存.</p>
<h4 id="2-线程安全和线程不安全？"><a href="#2-线程安全和线程不安全？" class="headerlink" title="2.  线程安全和线程不安全？"></a><strong>2.  线程安全和线程不安全？</strong></h4><p><strong>线程安全:</strong> 多线程访问时，采用加锁机制，当一个线程访问 该类的某个数据时，进行保护，其他线程不能进⾏访问，直到该线程读取完，其他线程才可使用, 不会出现数据不一致问题。</p>
<p><strong>线程不安全：</strong>不提供数据访问保护，有可能出现 <strong>多个线程先后更改数据</strong> 造成所得到的数据是脏数据； </p>
<p>线程安全问题 都是由 全局变量，静态变量引起的，若有多个线程同时执行写操作，一般需要考虑线程同步，否则可能影响线程安全。</p>
<p><strong>多线程：</strong>是指从 软件或硬件上实现多个线程的并发技术。</p>
<h4 id="多线程的好处："><a href="#多线程的好处：" class="headerlink" title="多线程的好处："></a>多线程的好处：</h4><p>i. 使用 多线程可以把程序中占据时间长的任务放到后台去处理，如图片、视屏的下载</p>
<p>ii. 发挥 多核处理器的优势，并发执行让系统运行的更快、更流畅，用户体验更好</p>
<h4 id="多线程的缺点："><a href="#多线程的缺点：" class="headerlink" title="多线程的缺点："></a>多线程的缺点：</h4><p>1.大量的 线程降低代码的可读性；</p>
<p>2.更多的 线程需要更多的内存空间</p>
<p>3.当 多个线程对同一个资源出现争夺时候要注意 线程安全的问题。</p>
<h4 id="3-⾃旋锁"><a href="#3-⾃旋锁" class="headerlink" title="3. ⾃旋锁"></a>3. ⾃旋锁</h4><p>1.当线程 A 想要获取一把自旋锁⽽该锁又被其它线程锁持有时，线程 A会在⼀个循环中自旋以检测锁是不是已经可用。</p>
<p><strong>2.自旋锁需要注意：</strong></p>
<ul>
<li>由于 自旋时不释放CPU，持有自旋锁的线程应该尽快释放自旋锁，否则等待该自旋锁的线程会一直自旋，浪费CPU时间。</li>
<li>持有自旋锁的线程在 sleep 之前应该释放自旋锁，以便其它线程可以获得自旋锁。</li>
</ul>
<p>3.目前的 JVM实现自旋会 消耗CPU，如果⻓时间不调用 doNotify方法，doWait方法会一直自旋，CPU会消耗太大</p>
<p>4.自旋锁比较适用于 锁使用者 ，保持锁时间比较短 的情况，这种情况自旋锁的效率比较高</p>
<p>5.自旋锁是一种对 多处理器相当有效的机制，⽽在单处理器非抢占式的系统中基本上没有作⽤</p>
<h4 id="4-乐观锁和悲观锁"><a href="#4-乐观锁和悲观锁" class="headerlink" title="4. 乐观锁和悲观锁"></a>4. 乐观锁和悲观锁</h4><p><strong>悲观锁：</strong> 每次都加重锁，认为其他线程会访问共享变量</p>
<p><strong>乐观锁：</strong> 轻量级的锁，认为其他线程不会访问共享变量，修改时进行判断，通过 cas 乐观锁技术 保证数据⼀致性。</p>
<h4 id="5-原⼦操作"><a href="#5-原⼦操作" class="headerlink" title="5. 原⼦操作"></a><strong>5. 原⼦操作</strong></h4><p>在 Java Concurrency API中有些原⼦类(atomic classes)</p>
<p>原子操作：一个不受其他操作影响的操作任务单元。原子操作是在多线程环境下避免数据不一致必须的⼿段。</p>
<p>int++： 并不不是一个原子操作，所以当⼀个线程读取它的值并加1时，另外一个线程有可能会读到之前的值，这就会引发错误。</p>
<p>解决问题：<strong>java.util.concurrent. atomic</strong> 包提供了int和long类型，它们可以自动的保证操作是原子的并且不需要使用同步。</p>
<h4 id="6-Executors框架"><a href="#6-Executors框架" class="headerlink" title="6. Executors框架"></a><strong>6.</strong> Executors框架</h4><p>Java通过 Executors 提供四种线程池，分别为：</p>
<p>1.newSingleThreadExecutor 创建一个单线程线程池，只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p>
<p>2.newFixedThreadPool 创建一个固定数量线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p>
<p>3.newCachedThreadPool 创建一个可缓存线程池，如果 线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p>
<p>4.newScheduledThreadPool 创建一个定⻓线程池，支持 定时及周期性任务执行。</p>
<h4 id="7-阻塞队列"><a href="#7-阻塞队列" class="headerlink" title="7. 阻塞队列"></a><strong>7. 阻塞队列</strong></h4><p> JDK7 提供了 7个阻塞队列（也属于并发容器）</p>
<ol>
<li>ArrayBlockingQueue ：一个由 数组结构组成的 有界阻塞队列</li>
<li>LinkedBlockingQueue ：一个由 链表结构组成的 有界阻塞队列</li>
<li>PriorityBlockingQueue ：一个 支持优先级排序的 无界阻塞队列。</li>
<li>DelayQueue：一个使用 优先级队列实现的 无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的 阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的 无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的 双向阻塞队列。</li>
</ol>
<p><strong>概念：</strong> 阻塞队列 是一个在队列基础上又支持 两个附加操作的队列。</p>
<p>附加操作：</p>
<p>支持阻塞的 插入方法：队列满时，队列会阻塞插入元素的线程，直到队列不满。</p>
<p>支持阻塞的 移除方法：队列空时，获取元素的线程会等待队列变为非空。</p>
<h4 id="8-Callable和Future"><a href="#8-Callable和Future" class="headerlink" title="8. Callable和Future"></a><strong>8. Callable和Future</strong></h4><p>获取线程的执行结果时使用，Callable 用于产生结果，Future用于获取结果；</p>
<p>Callable 接口使用 泛型去定义它的返回类型，Executors 类提供一些有用的方法在线程池中执⾏Callable内的任务。由于Callable任务是并行的，必须等待它返回的结果。java.util.concurrent.Future对象解决了这个问题。</p>
<p>在线程池提交Callable任务后返回一个Future对象，使用它可以知道 Callable任务的状态和得到Callable返回的执⾏结果。Future提供了get()方法，等待Callable结束并获取它的执行结果。</p>
<h4 id="9-FutureTask"><a href="#9-FutureTask" class="headerlink" title="9. FutureTask"></a><strong>9. FutureTask</strong></h4><p>FutureTask 可用于 异步获取执行结果或取消执行任务的场景。</p>
<p>通过传入Runnable或 Callable的任务给 FutureTask，直接调用其 run方法或放入线程池执行，之后可以在外部通过 FutureTask的 get方法异步获取执行结果，因此 FutureTask 非常适合⽤于耗时的计算，主线程可以在完成⾃己的任务后，再去获取结果。另外，FutureTask还可以确保 即使调用多次 run方法，它都只会执行一次 Runnable或 Callable任务，或通过 cancel 取消 FutureTask的执行等。</p>
<p>FutureTask 可用于执行 多任务、以 避免高并发情况下多次创建数据锁的出现。</p>
<h4 id="10-同步容器-和-并发容器"><a href="#10-同步容器-和-并发容器" class="headerlink" title="10. 同步容器 和 并发容器"></a><strong>10. 同步容器 和 并发容器</strong></h4><p>同步容器：</p>
<ul>
<li>主要代表有 Vector和 Hashtable，以及 Collections.synchronizedXxx等；</li>
<li>锁的 粒度为当前对象整体；</li>
<li>迭代器是及时失败的，即在迭代的过程中发现被修改，就会抛ConcurrentModificationException。</li>
</ul>
<p>并发容器：  </p>
<ul>
<li><p>主要代表有 ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentSkipListMap、ConcurrentSkipListSet。</p>
</li>
<li><p>锁的粒度是分散的、细粒度的，即读和写是使⽤不同的锁。</p>
</li>
<li><p>迭代器具有弱一致性，即可以容忍并发修改，不会抛出ConcurrentModificationException。</p>
</li>
</ul>
<h4 id="11-多线程的上下文切换"><a href="#11-多线程的上下文切换" class="headerlink" title="11. 多线程的上下文切换"></a><strong>11. 多线程的上下文切换</strong></h4><p>CPU 通过 时间片分配算法来循环执行任务，当前一个任务执行一个时间片后，会切换到下一个任务。但在切换前会保存上一个任务的状态，以便下次 切换回这个任务时，可以再次加载这个任务的状态。</p>
<h4 id="12-ThreadLocal的作用"><a href="#12-ThreadLocal的作用" class="headerlink" title="12.ThreadLocal的作用"></a><strong>12.ThreadLocal的作用</strong></h4><p>​        ThreadLocal 类允许 创建 只能被同一个线程读写的变量。因此，如果⼀段代码含有一个 ThreadLocal变量的引用，即使 两个线程同时执行这段代码，它们也 无法访问到对方的ThreadLocal变量量。</p>
<p><strong>线程局部变量:</strong>  在并发编程的时候，成员变量如果不做任何处理, 线程是不安全的，各个线程都在操作同⼀个变量，显然是不行的，volatile这个关键字也是不能保证线程安全的。那么在有一种情况之下，需要满足这样⼀个条件：变量是同一个，但每个线程都使用同一个初始值，也就是使用同一个变量的一个新的副本。这种情况之下 ThreadLocal就⾮常适用，比如说 DAO的数据库连接，DAO是单例的，它的属性 Connection 就不是一个线程安全的变量。每个线程都需要使用他，并且各自使用各自的。这种情况，ThreadLocal 就比较好的解决了这个问题。</p>
<p>​        每个线程都维护了一个map，而这个map的 key就是 threadLocal，而值就是我们set的那个值，每次线程在 get的时候，都从⾃己的变量中取值，既然从⾃己的变量中取值，那肯定就不存在线程安全问题。ThreadLocal这个变量的状态根本没有发生变化，他仅是充当一个 key的⻆色，另外提供给每一个线程一个初始值。</p>
<h4 id="13-ThreadPool（线程池）用法与优势"><a href="#13-ThreadPool（线程池）用法与优势" class="headerlink" title="13. ThreadPool（线程池）用法与优势"></a><strong>13. ThreadPool（线程池）用法与优势</strong></h4><p>优点：</p>
<p>1.减少 创建和销毁线程的次数，每个工作线程都可以被重复利用，可执⾏多个任务</p>
<p>2.可以根据系统的承受能力，调整 线程池中工作线程的数目，防⽌因为消耗过多的内存，而把服务器累趴下</p>
<p>(每个线程需要⼤约 1MB内存，线程开的越多，消耗的内存也就越大，最后死机)；减少在 创建和销毁线程上所花的时间以及系统资源的开销</p>
<p>如不使⽤用线程池，有可能造成系统创建⼤量线程⽽导致消耗完系统内存</p>
<p>Java⾥⾯线程池的顶级接口： Executor，但严格意义上讲 Executor并不是⼀个线程池，⽽只是⼀个执⾏线程的⼯具，真正的线程池接⼜是 ExecutorService。</p>
<ul>
<li>当线程数 &lt; corePoolSize时，创建线程执⾏行行任务。</li>
<li>当线程数 &gt;&#x3D; corePoolSize并且 workQueue没有满时，放入workQueue中</li>
<li>线程数  &gt;&#x3D;corePoolSize并且 workQueue满时，新任务<strong>新建线程运行</strong>，线程总数要 &lt; maximumPoolSize</li>
<li>当线程总数 &#x3D;maximumPoolSize并且 workQueue满了的时候，执行 handler的rejectedExecution 拒绝策略</li>
</ul>
<h4 id="14-CAS-产生的ABA-问题"><a href="#14-CAS-产生的ABA-问题" class="headerlink" title="14.CAS 产生的ABA 问题"></a><strong>14.CAS 产生的ABA 问题</strong></h4><p>原节点 A ，改变头节点 2次， 先改为 B， 改变B 指针的指向（插入链表的表头，成为新头节点），最后再改回节点 A ，对于节点，其实际的 值没有改变，但此时 指针的指向 已经发生了改变</p>
<p>解决：</p>
<p>加入版本号，在内部维护一个状态戳（时间戳），每次修改对象值的同时，也改变状态戳，</p>
<p>在校验 CAS 时，同时校验  对象值+ 状态戳 的期望值（类似于MVCC 中记录数据的版本号操作）</p>
<h4 id="15-volatile关键字作用"><a href="#15-volatile关键字作用" class="headerlink" title="15. volatile关键字作用"></a><strong>15. volatile关键字作用</strong></h4><p>*从主内存中加载 最新的数据</p>
<p>*对共享变量修改后，立刻重写回主内存，即时刷新重写</p>
<p>*为了获取更好的性能 JVM可能会对指令进行重排序，volatile则会对 禁⽌语义重排序</p>
<hr>
<h4 id="1-如何获取-线程-dump-堆栈-⽂件"><a href="#1-如何获取-线程-dump-堆栈-⽂件" class="headerlink" title="1. 如何获取 线程 dump(堆栈)⽂件"></a><strong>1. 如何获取 线程 dump(堆栈)⽂件</strong></h4><p>线程 dump 堆栈； 死循环、死锁、阻塞、⻚面 打开慢等问题，查看线程 dump是最好的解决问题的途径。</p>
<p>获取到线程堆栈有两步：</p>
<p>1.获取到线程的 pid，通过 ps命令， ps -ef | grep java</p>
<p>2.打印线程堆栈，通过 jstack pid 命令，在 Linux环境下还可以使⽤用 kill -3 pid</p>
<p>3.Thread类提供了一个 getStackTrace()方法， 可以获取线程堆栈。此方法和具体线程实例绑定，每次获取到的是某个线程当前运行的堆栈。</p>
<h4 id="2-创建-线程的方式"><a href="#2-创建-线程的方式" class="headerlink" title="2. 创建 线程的方式"></a><strong>2. 创建 线程的方式</strong></h4><ul>
<li>继承 Thread类，重写 run方法</li>
<li>实现 Runnable接口并重写 run方法，实现Runnable接口实现类的实例对象，作为Thread构造函数的target</li>
<li>实现 Callable接口，通过 FutureTask包装器来创建Thread线程</li>
<li>通过 线程池创建线程</li>
</ul>
<h4 id="3-多线程线程数量设置"><a href="#3-多线程线程数量设置" class="headerlink" title="3.多线程线程数量设置"></a><strong>3.多线程线程数量设置</strong></h4><p>A. 高并发、任务执行时间短的业务： 线程池线程数可以设置为 CPU核数+1，减少线程上下⽂的切换。</p>
<p>B. 并发不高、任务执行时间长的业务：</p>
<p>*假如是业务时间长集中在 IO操作上，也就是 IO密集型的任务，因为IO操作并不占⽤用CPU，所以不要让所有的CPU 闲下来，可以加⼤线程池中的线程数目，让CPU处理更多的业务</p>
<p>*假如是业务时间长集中在计算操作上，也就是 计算密集型任务，这个就没办法了，和 (1)一样，线程池中的 线程数设置得少一些，减少线程上下文的切换</p>
<p>C. 并发高、业务执行时间长：解决这种类型任务的关键不在于线程池⽽在于整体架构的设计，</p>
<p>第一步：看这些业务⾥面 某些数据是否能做缓存</p>
<p>第二步：增加服务器 </p>
<p>第三步：使用 中间件 对任务进行 拆分和解耦</p>
<h4 id="4-锁的等级：方法锁、对象锁、类锁"><a href="#4-锁的等级：方法锁、对象锁、类锁" class="headerlink" title="4. 锁的等级：方法锁、对象锁、类锁"></a><strong>4. 锁的等级：方法锁、对象锁、类锁</strong></h4><p>1.方法锁，synchronized修饰方法时</p>
<p>a. 通过在 <strong>方法声明中加入 synchronized 关键字</strong>来声明 synchronized 方法。</p>
<p>b. synchronized 方法控制对 类成员变量的访问：</p>
<p>c. 每个 类实例对应一把锁，每个 synchronized 方法都必须获得 调用该方法的 类实例的锁 方能执行，否则所属线程阻塞，⽅法一旦执行，就独占该锁，直到 从该方法返回时才将锁释放，此后被 阻塞的线程方能获得该锁，重新进⼊可执行状态。</p>
<p>这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从⽽有效避免了类成员变量的访问冲突。</p>
<p>2.对象锁，synchronized修饰方法或代码块</p>
<p>a. 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，必须先获得对象锁。如果对象锁已被其他调用者占用，则需要等待此锁被释放。（⽅法锁也是对象锁）</p>
<p>b. java的所有对象都含有 1个互斥锁，这个锁由 JVM自动获取和释放。线程进入 synchronized⽅法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会⾃动释放对象锁。这里也体现了用 synchronized来加锁的1个好处，⽅法抛异常的时候，锁仍然可以由JVM来自动释放。</p>
<p>3.类锁(synchronized 修饰静态的方法或代码块)</p>
<p>a. 由于一个class不论被实例化多少次，其中的静态⽅法和静态变量在内存中都只有一份。所以，一旦一个静态的⽅法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为 类锁。</p>
<p>4.对象锁 是用来控制实例方法之间的同步，类锁 是用来 控制静态方法（或静态变量互斥体）之间的同步</p>
<p>总结：</p>
<ol>
<li><p>在某个对象的所有synchronized方法中,在某个时刻只能有一个唯一的一个线程去访问这些synchronized方法</p>
</li>
<li><p>如果一个方法是synchronized方法,那么该synchronized关键字表示给当前对象上锁(即this)相当于</p>
</li>
</ol>
<p>synchronized(this){}</p>
<ol start="3">
<li>如果⼀个synchronized方法是static的,那么该synchronized表示给当前对象所对应的class对象上锁(每个类不管生成多少对象,其对应的class对象只有⼀个)</li>
</ol>
<h4 id="5-并行、并发的区别"><a href="#5-并行、并发的区别" class="headerlink" title="5.并行、并发的区别"></a><strong>5.并行、并发的区别</strong></h4><ol>
<li><p>并行指两个或多个事件在同一时刻发生； 并发指两个或多个事件在 同一时间间隔发生。</p>
</li>
<li><p>并行 是在不同实体上的多个事件，并发是在 同一实体上的多个事件。</p>
</li>
<li><p>并行是在多台处理器上同时处理多个任务；并发是在一台处理器上“同时”处理多个任务。</p>
</li>
</ol>
<p>并发编程的⽬标是充分的利⽤处理器的每⼀个核，以达到最⾼的处理性能</p>
<h4 id="6-唤醒一个阻塞的线程"><a href="#6-唤醒一个阻塞的线程" class="headerlink" title="6.唤醒一个阻塞的线程"></a><strong>6.唤醒一个阻塞的线程</strong></h4><p>wait与notify：wait与notify 配合synchronized使用，调用之前持有锁，wait会立即释放锁，notify同步块执行完才释放。</p>
<p>await与singal：Condition类提供，由 new ReentLock().newCondition() 获得Condition对象，与 wait和 notify相同，因为在使用 Lock锁后无法使用wait方法。</p>
<p>park与 unpark：LockSupport 是一个线程阻塞工具，可以在 线程任意位置让线程阻塞。和 Thread.suspenf()相比，它弥补了由于 resume() 在前发生，导致线程⽆法继续执行的情况。和Object.wait()相⽐，它 不需要先获得某个对象的锁，也不会抛出 IException异常。可以唤醒指定线程。</p>
<h4 id="7-如何检测死锁，预防死锁"><a href="#7-如何检测死锁，预防死锁" class="headerlink" title="7. 如何检测死锁，预防死锁"></a><strong>7. 如何检测死锁，预防死锁</strong></h4><p>死锁：两个或两个以上的进程在执行过程中，因 争夺资源而造成一种互相等待 的现象，若无外力作用，它们都将⽆法推进下去。</p>
<p>产生死锁必要条件：</p>
<ol>
<li><p>互斥条件：进程对所 分配到的资源 不允许其他进程进行访问，若其他进程访问该资源，只能等待，直至释放该资源</p>
</li>
<li><p>请求和保持：进程获得资源后，对其他资源发请求，但该资源可能被其他进程占有，此时请求阻塞，但它对已获得资源保持不放</p>
</li>
<li><p>不可剥夺：进程 已获得的资源，在未完成使用之前，不可被剥夺，只能在使用完后自己释放</p>
</li>
<li><p>循环等待：进程发⽣ 死锁后，若干进程之间形成⼀种 头尾相接的 循环等待资源关系</p>
</li>
</ol>
<p><strong>死锁产生原因：</strong></p>
<p>1.竞争资源发⽣死锁：多个进程共享的资源数目不足以满⾜全部进程的需要，引起对资源的竞争</p>
<p>2.进程 推进顺序不当发⽣死锁</p>
<h4 id="8-守护线程"><a href="#8-守护线程" class="headerlink" title="8. 守护线程"></a><strong>8. 守护线程</strong></h4><p>守护线程（daemon thread），是个服务线程，用于服务其他的线程</p>
<p>Java中线程分2种：</p>
<p>1.守护线程，⽐如 垃圾回收线程，最典型的守护线程</p>
<p>2.用户线程，应用程序里的自定义线程</p>
<h4 id="9-synchronized和ReentrantLock-区别"><a href="#9-synchronized和ReentrantLock-区别" class="headerlink" title="9. synchronized和ReentrantLock 区别"></a><strong>9. synchronized和ReentrantLock 区别</strong></h4><p><strong>可重入锁：</strong>同一个线程可以多次获取同一把锁，ReentrantLock和synchronized都是可重入锁。</p>
<p><strong>可中断锁：</strong>线程尝试获取锁的过程中，是否可以响应中断。synchronized 不可中断，ReentrantLock可中断</p>
<p><strong>公平锁：</strong>  多个线程 同时尝试获取同一把锁时，获取锁的顺序按照线程达到的顺序，</p>
<p><strong>非公****平锁：</strong>允许线程“插队”, synchronized：非公平锁，  ReentrantLock的默认：非公平锁，但可以设置为公平锁</p>
<p>Synchronized</p>
<p>Synchronized是  java内置的关键字，它提供了一种独占的加锁方式；Synchronized 的获取和释放锁由JVM实现，用户不需要显示的释放锁，非常方便。</p>
<p>局限性：</p>
<ol>
<li><p>当线程尝试获取锁的时候，如果 获取不到锁会一直阻塞。</p>
</li>
<li><p>如果 获取锁的线程进入休眠或者阻塞，除非当前线程异常，否则其他线程尝试获取锁必须一直等待。</p>
</li>
</ol>
<p>ReentrantLock:</p>
<ol>
<li><p>ReentrantLock它是JDK 1.5之后提供的 API层面的互斥锁，需要 lock() 和 unlock()方法配合 try&#x2F;finally语句块来完成。</p>
</li>
<li><p>等待可中断避免，出现死锁的情况</p>
</li>
</ol>
<p>（如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回 true，如果等待超时，返回false）</p>
<ol start="3">
<li><p>公平锁与非公平锁 多个线程等待同一个锁时，必须按照 申请锁的时间顺序获得锁，Synchronized锁非公平锁，ReentrantLock 默认的构造函数是创建的非公平锁，可以通过参数true设为公平锁</p>
</li>
<li><p>选择性通知： Synchronized只能通过notify, notifyAll 随机唤醒一个或多个等待的线程； ReentrantLock可以和Contition实例配合，指定的线程注册到指定的Contition实例中，实现选择性唤醒。</p>
</li>
</ol>
<h4 id="10-Lock接⼝-Lock-interface"><a href="#10-Lock接⼝-Lock-interface" class="headerlink" title="10. Lock接⼝(Lock interface)"></a><strong>10. Lock接⼝(Lock interface)</strong></h4><p>Lock 接⼝比同步方法和同步块提供更具扩展性的锁操作，他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持 多个相关类的条件对象。</p>
<p>优势：</p>
<p>可以使 锁更公平</p>
<p>可以使 线程在等待锁的时候响应中断</p>
<p>可以让 线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间</p>
<p>可以在 不同的范围，以不同的顺序获取和释放锁</p>
<h4 id="11-ConcurrentHashMap-并发度"><a href="#11-ConcurrentHashMap-并发度" class="headerlink" title="11. ConcurrentHashMap 并发度"></a><strong>11. ConcurrentHashMap 并发度</strong></h4><p>1、工作机制（分片思想）：它引入了一个 “分段锁”的概念，具体可以理解为把一个大的Map拆分成N个小的segment，</p>
<p>根据 key.hashCode()来决定把 key放到哪个HashTable中。可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。</p>
<p>2、应用：当读 &gt; 写时使用，适合做缓存，在程序启动时初始化，之后可以被多个线程访问；</p>
<p>hash冲突：HashMap中调用 hashCode()方法计算hashCode。由于在Java中两个不同的对象可能有一样的</p>
<p>hashCode,  所以不同的键可能有一样hashCode，从而导致冲突的产生。</p>
<p>hash冲突解决：使用平衡树来代替链表，当同一hash中的元素数量超过 8 时会由链表切换到平衡树</p>
<p>无锁读：ConcurrentHashMap 有较好的并发性，因为 ConcurrentHashMap是 无锁读和加锁写，并且利用分段锁（不是在所有的entry上加锁，而是在一部分entry上加锁）；</p>
<p>ConcurrentHashMap的并发度就是 segment的⼤小，默认为16，这意味着最多同时可以有16条线程操作</p>
<p>ConcurrentHashMap，这也是 ConcurrentHashMap对Hashtable的最⼤优势。 JDK 1.7 后，ConcurrentHashMap 升级为 数组首节点加锁</p>
<h4 id="12-CyclicBarrier-和-CountDownLatch-区别"><a href="#12-CyclicBarrier-和-CountDownLatch-区别" class="headerlink" title="12. CyclicBarrier 和 CountDownLatch 区别"></a><strong>12. CyclicBarrier 和 CountDownLatch 区别</strong></h4><p>CyclicBarrier  和  CountDownLatch 都位于  java.util.concurrent 这个包下</p>
<p>CountDownLatch:  减计数； 计算&#x3D;0时释放所有等待线程； 计数为0后无法重置，不可重复利用； 调用countDown() 方法计数-1，调用await() 方法只进行阻塞，对技术没有任何影响。</p>
<p>CyclicBarrier:  加计数； 计数&#x3D;指定值时，释放所有等待线程； 计数&#x3D;指定值，计数置为0重新开始，可重复利用； 调用await() 方法计数+1， +1后&lt; 指定值时，线程阻塞；</p>
<h4 id="13-Fork-x2F-Join作用"><a href="#13-Fork-x2F-Join作用" class="headerlink" title="13. Fork&#x2F;Join作用"></a><strong>13. Fork&#x2F;Join作用</strong></h4><p>1.Fork ： 把一个 大任务切分为若⼲子任务并行的执行。</p>
<p>2.Join ： 合并这些子任务的执行结果，最后得到这个⼤任务的结果。</p>
<h4 id="14-wait-和sleep-区别"><a href="#14-wait-和sleep-区别" class="headerlink" title="14. wait()和sleep() 区别"></a><strong>14. wait()和sleep() 区别</strong></h4><p>sleep()方法：  线程类（Thread）的静态方法，让调用 线程进入睡眠状态，让出执行机会给其他线程，等到休眠时间结束后，线程进入 就绪状态和 其他线程一起竞争cpu的执⾏时间。</p>
<p>因为 sleep() 是 static静态的方法，它不能改变对象的锁，当一个 synchronized 块中调⽤ sleep()方法，线程虽然进入休眠，但是对象的锁没有被释放，其他线程依然无法访问这个对象。</p>
<p>wait()方法：  Object类的方法，当一个线程执行到 wait方法时，它就进入到一个和 该对象相关的等待池，同时释放对象的锁，使得其他线程能够访问，可以通过notify，notifyAll⽅法来唤醒等待的线程</p>
<h4 id="15-线程的五个状态（创建、就绪、运⾏、阻塞、死亡）"><a href="#15-线程的五个状态（创建、就绪、运⾏、阻塞、死亡）" class="headerlink" title="15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）"></a><strong>15. 线程的五个状态（创建、就绪、运⾏、阻塞、死亡）</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gursjuuz12j60ha08yjsg02.jpg" alt="A810BC90-DA3F-4760-9FC7-7AD666F47AC6" width="650" height="300" />

<ol>
<li><p>创建状态：生成线程对象，并 没有调用该对象的 start方法，这是线程处于创建状态。</p>
</li>
<li><p>就绪状态：调用线程对象的 start方法之后，进入就绪状态，没有获得时间片则不会执行，从等待或睡眠中醒来，也会处于就绪状态</p>
</li>
<li><p>运行状态： 线程调度程序将 就绪线程设置为当前线程，此时进入运行状态，开始运行 run()函数当中的代码。</p>
</li>
<li><p>阻塞状态： 线程正在运行时被暂停，为等待某个事件的发生(资源就绪)之后再继续运行，sleep, suspend,wait等方法可以导致线程阻塞。</p>
</li>
<li><p>死亡状态： 一个线程 run()方法执行结束或调用stop()方法后，该线程就会死亡，对于死亡的线程，无法再使用 start⽅法使其进入就绪。</p>
</li>
</ol>
<h4 id="16-start-和-run-方法区别"><a href="#16-start-和-run-方法区别" class="headerlink" title="16. start()和 run()方法区别"></a><strong>16. start()和 run()方法区别</strong></h4><p>1.start()方法来 启动一个线程，真正实现多线程运行。</p>
<p>2.如果直接调用 run(), 其实就相当于是调用一个普通函数而已，直接调用 run()方法必须等待run()方法执行完毕才能执行下面的代码，所以执行路径还是只有一条，根本没有线程的特征，所以在多线程执行时要使用 start()方法而不是run()方法。</p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-编程实战</title>
    <url>/2021/06/07/A-Java%E8%AF%AD%E8%A8%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/3.%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="多线程-编程实战"><a href="#多线程-编程实战" class="headerlink" title="多线程-编程实战"></a>多线程-编程实战</h1><h4 id="奇偶数循环打印，交替执行实例："><a href="#奇偶数循环打印，交替执行实例：" class="headerlink" title="奇偶数循环打印，交替执行实例："></a>奇偶数循环打印，交替执行实例：</h4><p>ReantrantLock() 使用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Lock</span> <span class="variable">mylock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RunnableA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; )&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123; </span><br><span class="line">                mylock.lock();</span><br><span class="line">                <span class="keyword">if</span>(state % <span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread A: &quot;</span> + String.valueOf(i));</span><br><span class="line">                    state++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                mylock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RunnableB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; )&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123; </span><br><span class="line">                mylock.lock();</span><br><span class="line">                <span class="keyword">if</span>(state % <span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread B: &quot;</span> + String.valueOf(i));</span><br><span class="line">                    state++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                mylock.unlock();;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="使用-Synchronized："><a href="#使用-Synchronized：" class="headerlink" title="使用 Synchronized："></a>使用 Synchronized：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RunnableA</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; )&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(state % <span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread A: &quot;</span> + String.valueOf(i));</span><br><span class="line">                    state++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">RunnableB</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; )&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(<span class="built_in">this</span>)&#123;</span><br><span class="line">                <span class="keyword">if</span>(state % <span class="number">2</span>==<span class="number">1</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread B: &quot;</span> + String.valueOf(i));</span><br><span class="line">                    state++;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableA</span>());</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">RunnableB</span>());</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java语言</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程-AQS详解</title>
    <url>/2021/06/09/A-Java%E8%AF%AD%E8%A8%80/%E5%A4%9A%E7%BA%BF%E7%A8%8B/5.AQS%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="AQS-详解"><a href="#AQS-详解" class="headerlink" title="AQS 详解"></a>AQS 详解</h1><h4 id="三个线程-线程1，2，3-同时来加锁-x2F-释放锁："><a href="#三个线程-线程1，2，3-同时来加锁-x2F-释放锁：" class="headerlink" title="三个线程(线程1，2，3)同时来加锁&#x2F;释放锁："></a>三个线程(线程1，2，3)同时来加锁&#x2F;释放锁：</h4><h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><p>1.线程一加锁成功时 AQS内部实现<br>2.线程二&#x2F;三加锁失败时 AQS中等待队列的数据模型<br>3.线程一释放锁，及线程二获取锁实现原理<br>4.通过线程场景来讲解Condition中await()和signal()实现原理</p>
<h4 id="1-线程一加锁成功："><a href="#1-线程一加锁成功：" class="headerlink" title="1.线程一加锁成功："></a>1.线程一加锁成功：</h4><p>如果同时有三个线程并发抢占锁，此时线程一抢占锁成功，线程二和线程三抢占锁失败，具体执行流程如下：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursn4dvwij60xm0i8mz302.jpg" alt="1E28D15C-7C36-4A72-9F39-B8EA197A02FB" width="600" height="300" />

<p>此时AQS内部数据为：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursnhf7xnj60zc09u0tq02.jpg" alt="933E683E-0920-41D0-A601-25C5C8898215" width="600" height="200" />



<h4 id="2-线程二、线程三加锁失败："><a href="#2-线程二、线程三加锁失败：" class="headerlink" title="2.线程二、线程三加锁失败："></a>2.线程二、线程三加锁失败：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gursodunv4j615m0dqjtl02.jpg" alt="DA3FB080-3481-408D-B49B-E83AB742E490" width="600" height="250"/>

<p>有图可以看出，等待队列中的节点Node是一个 双向链表<br>线程二抢占锁失败,按照真实场景来分析，线程一抢占锁成功后，state变为1，线程二通过 CAS修改state变量必然会失败，此时AQS中FIFO队列中数据如图:</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursosc28ej61460deq4q02.jpg" alt="05B538CD-F5AD-4E3C-B3A8-8000D55BC3E1" width="600" height="250" />

<p>线程一将state修改为1，所以线程二通过 CAS修改state的值不会成功，加锁失败。线程二执行 tryAcquire()后会返回false，接着执行addWaiter(Node.EXCLUSIVE)逻辑，将自己加入到一个FIFO等待队列中。</p>
<h4 id="3-线程一释放锁"><a href="#3-线程一释放锁" class="headerlink" title="3.线程一释放锁"></a>3.线程一释放锁</h4><p>线程一释放锁，释放锁后会 唤醒head节点的后置节点，就是线程二。线程二设置为head节点，然后空置之前的head节点数据，被空置的节点数据等着被垃圾回收。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursq4l5p7j60yo0jgdi902.jpg" alt="73FBFF18-A055-4AC6-AB79-2AE515C0B494" width="600" height="350" />



<p>线程二 释放锁 &#x2F; 线程三加锁：当线程二释放锁时，会唤醒被挂起的线程三，流程和上面大致相同，被唤醒的线程三会再次尝试加锁</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursr1qi48j60zo0d40ug02.jpg" alt="9E6853B0-BEB4-4D12-B09D-CC43AD0DF73F" width="600" height="250"/>



<h4 id="4-Contition实现原理："><a href="#4-Contition实现原理：" class="headerlink" title="4.Contition实现原理："></a>4.Contition实现原理：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gursr8lel9j618s0maadf02.jpg" alt="0A1A1211-CA16-4C20-B028-C49F8390B9E4" width="600" height="250" />

<p>await()方法中首先调用 addConditionWaiter()将当前线程加入到Condition队列中，执行完可以看到 Condition队列中的数据：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursrociquj618s0c2dhh02.jpg" alt="7AEDFCE0-0186-4AC5-B6B6-4C1A38F85CAC" width="600" height="220"/>

<p>​        这里会用当前线程创建一个 Node节点，waitStatus为CONDITION。 接着会释放该节点的锁，调用之前解析过的release()方法，释放锁之后，会唤醒被挂起的线程二，线程二会继续尝试获取锁。接着调用 isOnSyncQueue()方法判断当前节点是否为 Condition队列中的头部节点，如果是则调用LockSupport.park(this)挂起 Condition中当前线程。此时线程一被挂起，线程二获取锁成功。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurss3nurgj617u0m6jum02.jpg" alt="CCD0588F-1A68-4699-B803-35B5797B18A9" width="600" height="350" />

<p>​        线程二执行 signal()方法：首先我们考虑下线程二已经获取到锁，此时AQS等待队列中已经没有数据。<br>这里先从transferForSignal()方法来看，Condition队列中只有线程一创建的一个Node节点，且waitStatue为CONDITION，先通过CAS修改当前节点waitStatus为0，然后执行enq()方法将当前线程加入到等待队列中，并返回当前线程的前置节点。加入等待队列的代码在上面也已经分析过，此时等待队列中数据如下图：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gursshoev3j61880go76702.jpg" alt="75794B2C-981A-45AB-9F7A-AC4410FE3E79" width="600" height="250" />

<p>接着开始通过CAS修改当前节点的前置节点waitStatus为SIGNAL，并且唤醒当前线程。等线程二释放锁后，线程一会继续重试获取锁，结束。</p>
<p>参考：<a href="https://mp.weixin.qq.com/s/trsjgUFRrz40Simq2VKxTA">https://mp.weixin.qq.com/s/trsjgUFRrz40Simq2VKxTA</a></p>
<p>​     <a href="https://mp.weixin.qq.com/s/iNz6sTen2CSOdLE0j7qu9A">https://mp.weixin.qq.com/s/iNz6sTen2CSOdLE0j7qu9A</a></p>
]]></content>
      <categories>
        <category>Java语言</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据结构</title>
    <url>/2021/07/06/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/A1-Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="Redis基本数据结构"><a href="#Redis基本数据结构" class="headerlink" title="Redis基本数据结构"></a>Redis基本数据结构</h1><h4 id="基本数据结构：-String、List、Hash、Set、SortedSet、-bitMap，HyperLogLog"><a href="#基本数据结构：-String、List、Hash、Set、SortedSet、-bitMap，HyperLogLog" class="headerlink" title="基本数据结构： String、List、Hash、Set、SortedSet、 bitMap，HyperLogLog"></a>基本数据结构： String、List、Hash、Set、SortedSet、 bitMap，HyperLogLog</h4><h3 id="String"><a href="#String" class="headerlink" title="String :"></a>String :</h3><p>动态字符串，类似于 Java 中的 ArrayList，一个字符数组；     应用：缓存;  使用 SDS 结构</p>
<h4 id="SDS-与-C-字符串的区别："><a href="#SDS-与-C-字符串的区别：" class="headerlink" title="SDS 与 C 字符串的区别："></a>SDS 与 C 字符串的区别：</h4><p> C 语言使用一个长度 N+1 的字符数组来表示长度为 N 的字符串，字符数组最后一个元素是 ‘\0’</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwjznf9x3j60nx055jrm02.jpg" alt="image-20210928191147121" width="650" height="150"/>         



<p><strong>1.计数方式不同：</strong>  C 不保存数组长度，每次都需要遍历一遍整个数组，获取字符串长度 O(N) ；  redis 自己本身就保存 长度信息<br><strong>2.避免缓冲区溢出：</strong>执行 拼接 or 缩短字符串的操作时，可能出现 缓冲区溢出&#x2F;内存泄漏 的问题<br>现在需要在后面拼接，但是没计算好内存，结果可能因 内存不足，被意外的修改；<br>SDS 结构存储 当前长度+ free未使用长度，在做拼接操作时，会判断是否可以放得下，如果长度够直接执行，如果 不够那就进行扩容<br>    <img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk020cnij611w0bwdgr02.jpg" alt="30466B01-C2DD-46B1-B7C0-90DD45C08A93" width="650" height="200"  /></p>
<p><strong>3.减少 修改字符串时带来的内存重分配次数：</strong> Redis是个高速缓存数据库，如果需要对字符串进行 频繁的拼接和截断操作，在写代码时忘记了重新分配内存，就可能造成缓冲区溢出，以及内存泄露。Redis为避免 C字符串这样的缺陷，就分别采用了两种解决方案，去达到性能最大化，空间利用最大化：<br>***空间预分配：对SDS进行扩展操作的时候，Redis会为 SDS分配好内存，并且根据特定的公式，分配多余的 free空间，还有多余的 1byte空间（这1byte也是为了存空字符），这样就可以避免连续执行 字符串添加所带来的内存分配消耗。<br>*** 算法动态计算调整free值：字符串变长了，Redis还会根据算法计算出一个 free值给他备用；再继续拼接会发现，备用的 free用上了，省去这次的内存重分配</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk0n3hsdj611807ajs102.jpg" alt="DC43FF4A-EFE1-468A-AFF3-6123FF14F3E0" width="650" height="150" />

<p><strong>4.惰性空间释放：</strong> 当执行完一个字符串缩减的操作，为了预防继续添加的操作，redis并不会马上收回空间，这样来减少分配空间带来的消耗；当再次操作还没用到多余空间的时候，Redis就会收回多余的空间，防止内存的浪费。<br>调用删减函数，并不会马上释放掉 free空间；如果需要继续添加，则这个空间就能用上，减少内存的重分配，如果空间不需要，调用函数删掉</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk1cugrtj61120e4jsw02.jpg" alt="DB44101E-34A5-4AEF-AFCE-B7A66ACAC422" width="650" height="200" />

<p><strong>5.二进制安全：</strong> 因为 C 语言中的字符串必须符合某种编码（如 ASCII），中间出现 ‘\0’ 可能会被判定为提前结束的字符串而识别不了；因此 C的字符串  只能保存文本数据；<br>Redis 保存字符串的长度，不判断空字符而是判断长度； 所以redis 可以保存 各种二进制数据，更加安全；</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk1xfew3j611a0cwgmx02.jpg" alt="FBB69EB8-5F6F-40D6-BD76-9111B9FCBF10"  width="650" height="200" />

<p>List：双向链表，类似于 Java 中的 LinkedList，插入、删除 性能好，时间复杂度为 O(1)，但索引定位慢，查询 O(n)；   应用：消息队列；  结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">typedef struct list&#123;</span><br><span class="line">    <span class="comment">//表 头结点</span></span><br><span class="line">    listNode  *head;</span><br><span class="line">    <span class="comment">//表 尾节点</span></span><br><span class="line">    listNode  *tail;</span><br><span class="line">    <span class="comment">//链表 长度</span></span><br><span class="line">    unsigned <span class="type">long</span> len;</span><br><span class="line">    <span class="comment">//节点值复制函数</span></span><br><span class="line">    <span class="keyword">void</span> *(*dup) (viod *ptr);</span><br><span class="line">    <span class="comment">//节点值释放函数</span></span><br><span class="line">    <span class="keyword">void</span>  (*free) (viod *ptr);</span><br><span class="line">    <span class="comment">//节点值对比函数</span></span><br><span class="line">    <span class="type">int</span> (*match) (<span class="keyword">void</span> *ptr,<span class="keyword">void</span> *key);</span><br><span class="line">&#125;list</span><br></pre></td></tr></table></figure>

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk2o47wcj60xi0eywft02.jpg" alt="C494BCEE-029D-4025-94D4-5B8B64A68BC5" width="650" height="250"/>

<h4 id="特性："><a href="#特性：" class="headerlink" title="特性："></a>特性：</h4><p>1.无环双向链表<br>2.获取表头指针，表尾指针，链表节点长度的 时间复杂度均为O(1)<br>3.链表使用 void *指针来保存节点值，可以保存各种不同类型的值</p>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash:"></a>Hash:</h3><p>数组 + 链表， 类似于 Java 中的 HashMap ，链地址法来解决部分 哈希冲突， 2倍扩容， 初始容量 16.</p>
<h4 id="结构："><a href="#结构：" class="headerlink" title="结构："></a>结构：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk36f5cej60ze0j0jsx02.jpg" alt="406435D6-0269-4F31-AAD5-4483C7B8FDC2" width="650" height="300" />

<p>ht[0]： 用于存放真实的key-vlaue数据； ht[1]：用于扩容(rehash)<br>Redis中哈希算法和哈希冲突跟Java实现的差不多，它俩差异: Redis哈希冲突，链表头插法；JDK1.8后，Java哈希冲突，链表尾插法。</p>
<h4 id="渐进式-rehash："><a href="#渐进式-rehash：" class="headerlink" title="渐进式 rehash："></a>渐进式 rehash：</h4><p>Hash 扩容是比较耗时间的，需重新申请新的数组，然后将旧字典所有链表中的元素重新挂接到新数组下面，这是一个 O(n) 的操作，作为 单线程的 Redis 很难承受这样耗时的过程，所以 Redis 使用 渐进式 rehash 来实现小步搬迁。</p>
<p>在 rehash时，保留新旧两个 hash结构，查询时先查新hash, 没有再查旧hash，并搬迁至新hash;  增加直接加到新hash;  修改先改hash, 没有改旧hash, 然后删除搬迁至新hash; 删除先删新hash, 没有再删旧hash。</p>
<p><strong>扩容条件：</strong>当 hash表中 元素个数 &#x3D;&#x3D; 数组.size()  扩容 原数组大小 2 倍。 如果 Redis 正在做 bgsave(持久化命令)，为减少内存，尽量不去扩容，但如果 hash 表非常满，达到一维数组长度 5 倍，这时就会 强制扩容。<br><strong>缩容条件：</strong>当 hash 表中  元素个数 &lt;  数组.size() * 10% ，缩容不会考虑  是否在做 bgsave</p>
<p>在对哈希表进行 扩展或者收缩操作时，reash过程并不是一次性地完成的，而是 渐进式地完成的。<br>Redis在 rehash时采取渐进式的原因：数据量如果过大的话，一次性rehash会有庞大的计算量，这很可能导致服务器一段时间内停止服务。<br>Redis具体是rehash时这么干的：<br>1: 在字典中维持一个 索引计数器变量 rehashidx，并将设置为0，表示rehash开始。<br>2:在 rehash期间每次对字典进行 增加、查询、删除和更新操作时，除了执行指定命令外；还会将ht[0]中rehashidx 索引上的值 rehash到ht[1]，操作完成后 rehashidx+1。<br>3:字典操作不断执行，最终在某个时间点，所有的键值对完成rehash，这时将rehashidx设置为-1，表示rehash完成<br>4:在渐进式rehash过程中，字典会 同时使用两个哈希表ht[0]和ht[1]，所有的更新、删除、查找操作也会在两个哈希表进行。例如要查找一个键的话，服务器会优先查找ht[0]，如果不存在，再查找ht[1]，诸如此类。此外当执行新增操作时，新的键值对一律保存到ht[1]，不再对ht[0]进行任何操作，以保证ht[0]的键值对数量只减不增，直至变为空表。</p>
<h3 id="Set-："><a href="#Set-：" class="headerlink" title="Set ："></a>Set ：</h3><p> 键值对 无序、唯一，类似于 Java 语言中的 HashSet， 在 HashMap 的基础上对所有的 value &#x3D; NULL </p>
<h3 id="SortedSet（zset）"><a href="#SortedSet（zset）" class="headerlink" title="SortedSet（zset）:"></a>SortedSet（zset）:</h3><p>ziplist  +  跳表（ skiplist）；  应用：排行榜 ；    参考： <a href="http://blog.jobbole.com/111731/">http://blog.jobbole.com/111731/</a><br>zset 可以按照 用户指定的 排序规则对输入字段进行排序， 支持随机插入、删除<br>同时满足如下条件时, 使用的是 ziplist,  其他时候使用 skiplist<br><strong>1.有序集合保存的元素  数量小于128个</strong><br><strong>2.有序集合保存的所有元素的 长度小于64字节</strong><br>ziplist 为存储结构时,每个集合元素使用 两个紧挨在一起的 压缩列表结点 来保存, 第一个 节点保存元素的成员, 第二个元素保存元素的分值score 。 </p>
<h4 id="为什么不考虑平衡树，红黑树？"><a href="#为什么不考虑平衡树，红黑树？" class="headerlink" title="为什么不考虑平衡树，红黑树？"></a>为什么不考虑平衡树，红黑树？</h4><p>1.性能考虑： 在高并发情况下，树形结构需要执行一些 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化 只涉及局部 ；<br>2.实现考虑： 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单；</p>
<p>在新产生的链表上，每两个相邻的节点增加一个指针，从而产生第三层链表：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk71tl5oj60g6038jre02.jpg" alt="03F9B84C-612F-40A8-A518-1B898D67ADA4" width="750" height="150" />


<p>skiplist  为每个节点随机出一个层数(level)，比如：一个节点随机出的层数 3，就把它链入到 第 1 层到第 3 层这三层链表中</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk7wpk4pj60u012tq6f02.jpg" alt="35A292CF-7CF8-48E7-9E0F-11775A623FBB" width="750" height="750" />

<p>每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此 插入操作只需要 修改节点前后的指针，而不需要对多个节点都进行调整，这就降低插入操作的复杂度。 从刚才创建的这个结构中查找 23 这个不存在的数，查找路径：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk8ko5wnj60v00aeq3p02.jpg" alt="54079B05-6914-4965-B95B-FA58520C9192" width="750" height="250" />

<h4 id="跳跃表-重要过程："><a href="#跳跃表-重要过程：" class="headerlink" title="跳跃表 重要过程："></a>跳跃表 重要过程：</h4><h4 id="随机层数："><a href="#随机层数：" class="headerlink" title="随机层数："></a><strong>随机层数：</strong></h4><p>对于每一个新插入的节点，都需要调用 一个随机算法给它分配一个合理的层数；<br>直观上期望的目标是 50% 的概率被分配到 Level 1； 25% 的概率被分配到 Level 2； 12.5% 的概率被分配到 Level 3，以此类推…有 2^(-63) 的概率被分配到最顶层，因为这里每一层的晋升率都是 50%<br>默认允许 最大的层数是 32，当 Level[0] 有 264 个元素时，才能达到 32 层，所以定义 32 完全够用了<br>插入节点：找到当前需要插入的位置 （其中包括相同 score 时的处理）； 创建新节点，调整前后的指针指向，完成插入<br>节点删除: 和插入过程类似，先把 “搜索路径” 找出来，然后对于 每个层的相关节点重排一下 前向后向指针，同时更新一下最高层数 maxLevel</p>
<h4 id="节点更新"><a href="#节点更新" class="headerlink" title="节点更新:"></a><strong>节点更新:</strong></h4><p>当调用 ZADD 方法时，如果对应的 value 不存在，那就是插入过程，<br>如果这个 value 已经存在，只是调整一下 score 的值，那就需要走一个 更新流程<br>如果这个新的 score 值 并不会带来排序上的变化，那就不需要调整位置，直接修改元素的 score 值<br>如果 排序位置改变，那就需要调整位置，把这个元素 删除再插入，需要经过两次路径搜索； 需调整顺序，先删再插</p>
<p><strong>元素排名：</strong>跳跃表是有序的， 在 skiplist 的 forward 指针上，为每一个 forward 指针都增加 span 属性，表示从前一个节点沿着当前层的 forward 指针跳到当前这个节点 中间会跳过多少个节点<br>在 插入、删除操作时，都会更新 span 值的大小，所以沿着 “搜索路径”把所有经过节点的 跨度 span 值累加 就可以算出当前元素的最终 rank 值。极端情况, 跳跃表中所有 score 值都是一样，zset 的查找性能会退化为 O(n)</p>
<h3 id="BitMap-位图"><a href="#BitMap-位图" class="headerlink" title="BitMap:  位图"></a>BitMap:  位图</h3><p><strong>应用场景：</strong>对于统计浏览某个网页的 独立访客数量 UV（Unique visitor）的业务场景，考虑使用 BitMap、 布隆过滤器（缓存穿透）  </p>
<p>Redis 位图是一个 二进制位组成的数组，数组的每个单元只能存储 0和1。 将数组中的每个 二进制位与用户 ID 一一对应， 使用位图去记录每个用户当日是否访问，存储的 1的个数就是UV数量。以 当天的日期加固定的前缀作为key，建立一个Bitmap，每一位二进制的 offset做为一个用户 ID的标识，当今天用户访问时就将Bitmap中标识此用户的二进制（value）从0置为1。最后统计所有bitmap 中 1 的个数，即为独立访客数量。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwk9dz2toj60dw0bgjrl02.jpg" alt="F49C49F5-90EC-4448-870F-23D9E3A0A472" width="350" height="250" />



<h3 id="HyperLogLog："><a href="#HyperLogLog：" class="headerlink" title="HyperLogLog："></a>HyperLogLog：</h3><p>基数统计 通常是用来 统计一个集合中不重复的元素个数 ；某个网页的 独立访客数量 UV（Unique visitor）的业务场景<br>Bitmap 已经节约了内存，但如果页面访问量非常大（例如用户规模达到1亿），那么用于统计单个页面的UV内存占用需要 100000000&#x2F;8&#x2F;1024&#x2F;1024 ≈ 12M；若分别统计多个页面，则内存占用会线性增加。如果只需要 每天的UV大致统计数量，使用HyperLogLog 比较合适。<br>HyperLogLog 是用来做 基数估计的算法，HyperLogLog 用12K字节的内存占用，可以计算接近 264 个不同元素的基数（UV）</p>
<p>2.比特串的基数估计<br>在UV统计中需要统计一组集合中 不重复元素的个数。利用哈希算法将集合中的数据转换成 0和1构成的二进制数串，那么一个二进制串可以类比为一次抛硬币实验，1是抛到正面，0是反面。<br>使用 MurmurHash2 算法来计算 集合数据的哈希值，该算法有很好的均匀性，即使输入集合数据按规律排列，哈希之后仍能保证数据随机分布，因此可以保证每 bit出现 0或1的概率均为1&#x2F;2，Redis中采用的是MurmurHash2固定64比特版本，另外该算法的计算速度也较快。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwka6pez0j60v80hwdid02.jpg" alt="AC03EB09-D3C4-4316-80D1-D5A6723A1C4C" width="650" height="350" />

<p>HLL算法思想的核心就在于通过 保留少量的比特信息，来 估计或观察消息流。二进制串中从低位开始第一个 1出现的位置可以理解为抛硬币试验中第一次出现正面的抛掷次数k，那么基于上面的结论，可以 通过多次抛硬币实验的最大抛到正面的次数来预估总共进行了多少次实验，通过第一个1出现位置的最大值  kmax来预估总共有多少个不同数字</p>
<h4 id="分桶平均"><a href="#分桶平均" class="headerlink" title="分桶平均"></a>分桶平均</h4><p>如果直接应用上面的HLL方法进行基数估计会由于偶然性带来较大的误差，因此 HLL算法采用分桶平均的方法来消减偶然性的误差、提高估计的准确度。<br>1.先把数据 分成若干个分组（桶bucket），估计每个分组的基数<br>2.然后用所有 分组基数的平均数来估计总的基数。<br>Redis 中桶的个数是16384，对于每个哈希值（64bit），14 位作为 桶编号用来定位数据分布的桶位置，剩余的50bit 即伯努利过程，每个桶对应 6 bit大小，记录kmax。<br>举例说明，若 UV值通过Hash 算法得到比特串:  10110000 00000000 01101100 00000100 00101001 11000000 00 000100 00011101<br>后面 14位确定桶编号，即bucket&#x3D;1053; 前面的50 bit 伯努利过程，该例中 kmax&#x3D; 9，那么UV基数估计为29<br>多个桶用平均数计算，HLL采用的是 调和平均方法，然后再基于 因子修正公式计算得出，调和平均较比 几何平均有更高的精度<br>Redis中规定 分桶个数16384，每个桶的kmax用 6bit空间来存放，6*16384&#x2F;8 字节，再加上结构头等数据，加起来一共12304个字节；用12K字节的内存占用，即可 计算接近 264 个不同元素的基数。这和基数越大占用内存越大的其它计算基数的方式形成鲜明对比。<br>但Redis对应内存的节约还不止于此，12K字节内存是 encoding&#x3D;HLL_DENSE(密集)模式下的内存占用；<br>对于基数值比较少，大多数桶的计数值kmax为0的情况，Redis采用HLL_SPARSE稀疏模式的存储，稀疏存储的空间占用远小于12K字节。对密集存储和稀疏存储方式，本文做简单介绍：<br>密集存储的结构很简单，就是连续的 16384个6比特连起来的位图。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkb4wfj2j610s04kmxq02.jpg" alt="6715C6C3-8585-4629-BD40-59DE35B1111B" width="650" height="100" />

<p>稀疏存储 针对的就是很多的桶计数值为 0的情况，因此会有大量连续0的情况出现</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkbpk601j6156050gmo02.jpg" alt="23A5FB80-92CF-4E8B-8236-40C6F3C4ABAA" width="650" height="100" />

<h4 id="使用-set-集合问题："><a href="#使用-set-集合问题：" class="headerlink" title="使用 set 集合问题："></a>使用 set 集合问题：</h4><ol>
<li>存储空间巨大： 如果数量庞大，则需要用来存储的 set 集合就会非常大，去重功能将耗费较高的时间复杂度 ，影响性能</li>
<li>统计复杂： 每个场景都需要一个set，对于多个 set 集合，如果要聚合统计一下，也是一个复杂的事情</li>
</ol>
<h3 id="Redis-过期策略：-定期删除-惰性删除"><a href="#Redis-过期策略：-定期删除-惰性删除" class="headerlink" title="Redis 过期策略： 定期删除+ 惰性删除"></a>Redis 过期策略： 定期删除+ 惰性删除</h3><p>定期删除：默认100ms 就随机抽一些 设置了过期时间的key，去检查是否过期，过期了就删<br>如果一直没随机到很多key，里面不就存在大量的无效key了？<br>惰性删除：不主动删，等你来查询我，看看过期没，过期就删了</p>
<p>定期没删，也没查询，那可咋整？</p>
<h4 id="内存淘汰策略："><a href="#内存淘汰策略：" class="headerlink" title="内存淘汰策略："></a>内存淘汰策略：</h4><p>1.noeviction:  永不删除<br>2.allkeys-random:  无过期时间的数据，随机删除一部分<br>3.allkeys-lru: 无过期时间的数据，删除 最近最少使用的（LRU）<br>4.volatile-random:  设置过期时间的数据，随机删除一部分<br>5.volatile-lru: 有过期时间的数据，删除最近最少使用的（LRU）<br>6.volatile-ttl: 有过期时间的数据，删除 剩余时间最短的（TTL）</p>
<h4 id="缓存穿透："><a href="#缓存穿透：" class="headerlink" title="缓存穿透："></a>缓存穿透：</h4><p>缓存和数据库 中都没有的数据，而用户不断发起请求，导致请求不走缓存，直接访问到数据库，数据库压力过大<br>通常是 请求参数非法导致，(例如 id&#x3D;-1)</p>
<h4 id="解决："><a href="#解决：" class="headerlink" title="解决："></a>解决：</h4><p>1.接口层 增加校验，比如 用户鉴权校验，参数做校验<br>2.在缓存中取不到，数据库中也没有取到，此时将对应Key的 Value 改写：{ null、位置错误、稍后重试 }，参照具体的场景<br>3.布隆过滤器（Bloom Filter）利用bitMap结构和hash算法，判断出这个Key是否在数据库中存在，不存在 return，存在就去查 DB刷新KV 再return</p>
<p><strong>缓存击穿：</strong>一个热点 Key，扛着高并发，当这个Key在失效瞬间，持续的高并发击穿缓存，直接请求到数据库<br>解决：<br>1.设置 热点数据永远不过期<br>2.加上互斥锁，保证 同一进程中对同一数据，不会并发请求到DB</p>
<p><strong>缓存雪崩：</strong>同一时间多个热点 Key值， 大面积失效，导致大量请求访问到DB<br>解决：<br>1.把每个 Key的失效时间都加个随机值，保证 数据不会在同一时间大面积失效<br>2.设置 热点数据永远不过期<br>3.将 多个热点数据 均匀分布在不同的Redis库中<br>4.使用主从、集群模型，提高缓存服务的高可用<br>缓存雪崩需要做 熔断等策略</p>
<ul>
<li>事前： Redis 高可用，主从+哨兵，Redis cluster，避免全盘崩溃</li>
<li>事中： 本地 ehcache 缓存 + Hystrix 限流+降级，避免MySQL被打死</li>
<li>事后： Redis 持久化 RDB+AOF，一旦重启，自动从磁盘上加载数据，快速恢复缓存数据</li>
</ul>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>持久化-哨兵/集群</title>
    <url>/2021/07/07/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/A2-Redis-%E6%8C%81%E4%B9%85%E5%8C%96-%E5%93%A8%E5%85%B5:%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="Redis-持久化-哨兵-x2F-集群"><a href="#Redis-持久化-哨兵-x2F-集群" class="headerlink" title="Redis-持久化-哨兵&#x2F;集群"></a>Redis-持久化-哨兵&#x2F;集群</h1><h4 id="Redis-简介："><a href="#Redis-简介：" class="headerlink" title="Redis 简介："></a>Redis 简介：</h4><p>1.非常快<br>2.支持丰富的数据类型<br>3.操作具有 原子性，单线程</p>
<h4 id="为什么快？"><a href="#为什么快？" class="headerlink" title="为什么快？"></a>为什么快？</h4><p>1.数据结构简单，操作的时间复杂度低<br>2.单线程，没有多线程相互切换的开销，避免不必要的上下文切换和锁竞争条件<br>3.所有操作都是基于内存的<br>4.多路I&#x2F;O复用模型，非阻塞IO </p>
<h4 id="RDB：快照持久化，根据指定时间内改变的key数量来做持久化（冷备）"><a href="#RDB：快照持久化，根据指定时间内改变的key数量来做持久化（冷备）" class="headerlink" title="RDB：快照持久化，根据指定时间内改变的key数量来做持久化（冷备）"></a>RDB：快照持久化，根据指定时间内改变的key数量来做持久化（冷备）</h4><p>快照持久化 完全交给 子进程处理，父进程 继续 处理客户端请求。<br>父进程调用 fork函数产生一个子进程 做数据持久化，不会修改现有的内存数据结构，只是对数据结构进行遍历读取，然后序列化写到磁盘中。但父进程继续响应客户端请求，然后对内存数据结构进行不间断的修改。<br>这个时候就会使用 操作系统的 COW 机制来进行 数据段页面 的分离。父进程对其中一个页面的数据进行修改时，将被共享的页面复制一份，并分离出来，然后对这个复制的页面进行修改。这时 子进程 相应的页面是 没有变化的，是一个快照的数据，然后子进程就可以遍历数据进行序列化写磁盘了。 </p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>1.性能影响小，网络传输快<br>2.数据恢复速度快<br>3.文件小</p>
<h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><p>1.无法实时同步，停机时会导致大量丢失数据<br>2.兼容性差（文件需要满足指定格式）</p>
<h3 id="AOF-Append-Only-File-仅追加文件"><a href="#AOF-Append-Only-File-仅追加文件" class="headerlink" title="AOF (Append Only File-仅追加文件)"></a>AOF (Append Only File-仅追加文件)</h3><p>将每条 写入命令作为日志，以 append-only 的模式写入一个日志文件中，这个模式是 只追加的，没有任何磁盘寻址的开销，速度快；先执行指令再将日志存盘。<br>每次执行 修改内存 中数据集的写操作时，都会 记录 该操作，在持久化恢复时 「重放」 所有的 修改性指令序列，来恢复 Redis 当前实例的内存数据结构的状态。AOF 是 先执行指令再将日志存盘，如果先写日志再操作的话，AOF日志中会出现 很多无效&#x2F;错误的命令记录（一些错误的操作也会记录）对本来就庞大的AOF文件来说就是雪上加霜；这一点不同于 MySQL 等存储引擎，如果先存储日志再做逻辑处理，这样就可以保证即使宕机了，仍然可以通过之前保存的日志恢复到之前的数据状态；<br>AOF 文件采用追加写的方式，避免IO 的随机寻址，优化磁盘写入性能</p>
<h3 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h3><p>1.实时持久化，可以做到秒级更新（一秒一次去通过线程 fsync操作，最多丢一秒数据）；<br>2.文件兼容性好，无需满足指定格式；<br>3.文件写入性能快，文件不容易破损；</p>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><p>1.AOF 文件大；<br>2.恢复数据时对系统性能影响大；<br>3.恢复速度慢；</p>
<h3 id="重写AOF-日志："><a href="#重写AOF-日志：" class="headerlink" title="重写AOF 日志："></a>重写AOF 日志：</h3><p>Redis 在长期运行的过程中，AOF 日志会越变越长，如果宕机重启，重放整个AOF日志会非常耗时，导致长时间Redis 无法对外提供服务，所以需要对AOF日志 “瘦身” 。Redis 提供 bg rewrite aof 指令用于对 AOF 日志进行瘦身；<br><strong>原理：</strong>父进程开辟一个子进程，由子进程对内存中的 redis数据库进行遍历 转换成一系列 Redis 的操作指令，序列化到一个新的 AOF 日志文件 中，序列化完毕后再将 操作期间发生的 增量AOF日志追加到这个新的 AOF日志文件中，追加完毕后就立即替代旧的AOF 日志文件</p>
<p>AOF 日志是以文件的形式存在的，当程序对AOF 日志文件进行写操作时，实际上是将内容写到 内核为文件描述符分配的一个内存缓存中，内核会异步将脏数据刷回到磁盘。</p>
<p><strong>出现事故时，第一时间用 RDB恢复，然后AOF做数据补全，冷备热备一起上。</strong></p>
<h4 id="突然机器掉电会怎样？"><a href="#突然机器掉电会怎样？" class="headerlink" title="突然机器掉电会怎样？"></a>突然机器掉电会怎样？</h4><p>取决于AOF日志sync属性的配置，如果不要求性能，在 每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都 sync是不现实的，一般都使用定时sync，比如1s 1次，这个时候最多丢失1s数据</p>
<h4 id="主从复制模型：-主从同步，从从同步"><a href="#主从复制模型：-主从同步，从从同步" class="headerlink" title="主从复制模型： 主从同步，从从同步"></a>主从复制模型： 主从同步，从从同步</h4><h4 id="主从之间数据同步："><a href="#主从之间数据同步：" class="headerlink" title="主从之间数据同步："></a>主从之间数据同步：</h4><p>1.第一次同步时，主节点做一次 bgsave，并同时将后续修改操作记录到 内存buffer<br>2.完成后将 RDB快照文件 全量同步到复制节点，然后复制节点将RDB镜像加载到内存<br>3.加载完成后，再通知主节点将 期间修改的操作记录发送过来，复制节点重放这些操作记录<br>4.后续的 增量数据通过 AOF日志同步<br>主从复制模型： 同时使用 RDB 、 AOF 持久化操作</p>
<h4 id="重点："><a href="#重点：" class="headerlink" title="重点："></a>重点：</h4><p>RDB快照数据生成时，缓存区也同时开始接受新请求，来保存同步期间的增量数据<br>传输过程中有什么网络问题，会自动重连，把缺少的数据补上<br><strong>优点：</strong>高可用，提高数据读的负载能力<br><strong>缺点：</strong>master 主节点故障，无法实现自动故障恢复</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkk6tseij610i0eidh802.jpg" alt="69DF28A0-0405-4D8E-95A3-6E028878273C" width="650" height="300" />



<h3 id="哨兵模型："><a href="#哨兵模型：" class="headerlink" title="哨兵模型："></a>哨兵模型：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkkukxnlj60ci09mjrh02.jpg" alt="9EBF2504-8F59-45EA-BF6D-61EC4F8A8494" width="450" height="300" />

<p>每个哨兵节点（Sentinal）每隔1秒向master、slave、其他哨兵节点发送 ping命令，如果对方能在指定时间内响应，说明节点健康存活。如果未在规定时间内（可配置）响应，那么该哨兵节点认为此节点 主观下线。</p>
<h4 id="故障恢复过程："><a href="#故障恢复过程：" class="headerlink" title="故障恢复过程："></a>故障恢复过程：</h4><p>1.每个 Sentinal 节点  1次&#x2F;s 向 它所关联的 主, 从 , 其他Sentinal 节点发送 ping命令，心跳检测<br>2.如果一个 节点没有回复 ping 命令，或超时， 将被Sentinal 节点标记为 主观下线<br>3.如果主节点被标记主观下线，与主节点相连的其他Sentinal 节点也监测主节点，当达到一定数量的Sentinal 节点都认为主节点下线了，主节点被标记为客观下线<br>4.选举领导哨兵节点： 当主节点被判断客观下线以后，各个Sentinal 节点会进行协商，选举一个领导哨兵节点，并由该领导节点对其进行故障转移操作<br>监听该主节点的所有哨兵，都有可能被选为领导者，选举算法是 先到先得：即在一轮选举中，哨兵 A 向 B 发送成为领导者的申请，如果B没有同意过其他哨兵，则会同意A成为领导者。<br>5.故障转移：选举出的 领导者哨兵，开始进行故障转移操作，分 3个步骤：</p>
<h4 id="在从节点中选择新的主节点，原则"><a href="#在从节点中选择新的主节点，原则" class="headerlink" title="在从节点中选择新的主节点，原则:"></a>在从节点中选择新的主节点，原则:</h4><p>1.首先 过滤掉不健康的从节点； （下线或断线），没有回复过哨兵ping响应的从节点<br>2.然后 根据指定的优先级选择，默认情况下所有的从节点priority值为100，如果倾向于选择同机房的另一台salve节点替代现有的master节点，则可以把同机房的 从节点的 priority值设置的低一些<br>3.如果 优先级无法区分，则选择 复制偏移量最大的从节点；数据更新程度选择<br>4.如果仍无法区分，则选择 runid最小的从节点；每个节点启动的时候都会有一个唯一的runId<br>更新主从状态：通过 slaveof no one命令，让新选出来的从节点成为主节点；并通过 slaveof命令让其他节点成为其从节点，将已经下线的 主节点也设置为从节点。</p>
<p>每个哨兵都设置一个随机休眠时间，苏醒后向其他哨兵发送申请成为领导者的请求；其他哨兵只能对收到的第一个请求进行回复确认   ；首先达到多数确认选票的哨兵节点，成为领导者 Sentinal 节点数量是基数个，通过投票机制来 选出 leader 哨兵，如果当前 选不出来则重新进行投票。 每个Sentinal 节点会把 票投给第一个请求他的 Sentinal 节点 </p>
<p>Redis Sentinal 高可用，提高读负载，在 master宕机时会自动将slave提升为master，继续提供服务。<br>Redis Cluster 扩展性，提高写负载，在单个redis内存不足时，使用Cluster进行分片存储。<br><strong>优点：</strong> 在复制的基础上，实现自动故障恢复<br><strong>缺点：</strong>写操作无法实现负载，存储能力受单机限制 （集群可解决）</p>
<h4 id="集群模型："><a href="#集群模型：" class="headerlink" title="集群模型："></a>集群模型：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkn395yzj60q90ext9y02.jpg" alt="D62740AC-71C8-49D7-97A9-D1644C0A2012" width="750" height="400" />

<p>16384 &#x3D;  2^14<br>一致性hash ： 2^32 -1<br>想扩展 并发读就添加Slaver，想扩展 并发写就添加Master，想扩容也就是添加Master，任何一个 Slaver或几个Master挂了都不会是灾难性的故障。<br>1.Redis集群是一个由 多个节点组成的分布式服务集群，具有复制、高可用和分片特性<br>2.集群没有中心节点，并且带有 复制和故障转移特性，不会因某个节点下线而影响整个集群<br>3.集群中的 主节点负责处理 槽（储存数据），而从节点则是主节点的 复制品<br>4.主节点只会执行自己槽有关的命令，当节点接收到不属于自己处理的槽的命令时，将会处理指定槽节点的地址返回给客户端，而 客户端会向正确的节点重新发送</p>
<p>各个哨兵模型下 slaver 间相互监听，若有故障随时替换，故障恢复<br>各个 master节点间均分数据分片，当 添加节点，删除节点时，由一致性Hash算法维护<br>现在 服务器都是多核的，如何高效使用 Redis?      通过在单机开多个Redis实例<br>集群中，各个master 节点保存 其他master 的数据槽范围，当出现 数据请求不在当前范围时，返回给 客户端并告诉其应该访问的具体master的  ip 信息。</p>
<h4 id="解决单机-Redis-的瓶颈？"><a href="#解决单机-Redis-的瓶颈？" class="headerlink" title="解决单机 Redis 的瓶颈？"></a>解决单机 Redis 的瓶颈？</h4><p><strong>集群部署方式：</strong> Redis cluster； 主从同步读写分离，类似Mysql的主从同步，Redis cluster 支撑 N 个 Redis master node，对数据分片，每个master node都可以挂载多个slave node。整个Redis 可以横向扩容，如果要支撑更大数据量的缓存，那就横向扩容更多的master 节点，每个master 节点能存放更多数据。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis性能优化</title>
    <url>/2021/07/08/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/A3-Redis%20%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Redis性能优化"><a href="#Redis性能优化" class="headerlink" title="Redis性能优化"></a>Redis性能优化</h1><h4 id="布隆过滤器："><a href="#布隆过滤器：" class="headerlink" title="布隆过滤器："></a>布隆过滤器：</h4><p><strong>应用场景：</strong> 缓存穿透，海量数据去重 </p>
<p>K 个哈希函数，每个字符串跟 k个bit对应，降低冲突概率<br>当一个元素被加入集合时，通过  K个散列函数 将这个元素映射成一个 位数组中的K个点，把它们置为 1,  检索时只要看这些点 是不是为 1 就知道集合中有没有它了。如果 这些点有任何一个 0，则被检元素一定不在；  如果都是1，则被检元素很可能在<br><strong>Bloom Filter 和单哈希函数 Bit-Map不同：</strong>Bloom Filter使用了 k个哈希函数，每个 字符串跟 k个bit对应。降低冲突概率</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwks943stj60oy0d8dh802.jpg" alt="DB32F606-7EE5-46FC-9E99-3B5438DC21F1" width="650" height="300"/>

<h4 id="存在的问题："><a href="#存在的问题：" class="headerlink" title="存在的问题："></a>存在的问题：</h4><p><strong>存在误判：</strong>hash之后得到的  k个位置上值都是1，但可能此值不存在；<br><strong>解决：</strong>可以通过建立一个 白名单来存储可能会误判的元素<br>删除困难： 一个放入容器的元素映射到 bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断；<br>解决： 可以采用Counting Bloom Filter</p>
<h4 id="分布式锁：-常规锁只能适用于单机，对于分布式架构无法保证"><a href="#分布式锁：-常规锁只能适用于单机，对于分布式架构无法保证" class="headerlink" title="分布式锁： 常规锁只能适用于单机，对于分布式架构无法保证"></a>分布式锁： 常规锁只能适用于单机，对于分布式架构无法保证</h4><p>避免不同节点重复相同的工作： 比如用户执行某个操作有可能不同节点会发送多封邮件；<br>避免破坏数据的正确性：如果两个节点在同一条数据上同时进行操作，可能会造成数据错误或不一致的情况出现；</p>
<h4 id="Redis-分布式锁的问题：-锁超时"><a href="#Redis-分布式锁的问题：-锁超时" class="headerlink" title="Redis 分布式锁的问题： 锁超时"></a>Redis 分布式锁的问题： 锁超时</h4><p>有两台平行的服务 A B，其中 A 服务在 获取锁之后 由于某种原因突然 挂了，那么 B 服务就永远无法获取到锁； 需要额外设置一个超时时间，来保证服务的可用性。如果 加锁，释放锁 之间的逻辑执行得太长，以至于 超出了锁的超时限制，也会出现问题。<br>因为这时第一个线程持有锁过期了，而临界区逻辑还没执行完，与此同时第二个线程就提前拥有了这把锁，导致临界区的代码不能得到严格的串行执行。为避免这个问题，Redis 分布式锁 不要用于较长时间的任务。</p>
<p><strong>解决：标记版本号</strong>  将锁 value 值设置为一个随机数，释放锁时先匹配随机数是否一致，然后再删除 key， 确保当前线程占有的锁不会被其他线程释放，除非这个锁是因为过期而被服务器自动释放的，但匹配  value 和 删除 key 在 Redis 中并不是一个原子性的操作，需要使用像 Lua 脚本来处理，因为 Lua 脚本可以 保证多个指令的原子性执行</p>
<h4 id="分布式锁：setnx是-SET-if-Not-exists"><a href="#分布式锁：setnx是-SET-if-Not-exists" class="headerlink" title="分布式锁：setnx是 SET if Not exists"></a>分布式锁：setnx是 SET if Not exists</h4><p>设置过期时间：  EXPIRE name  5       # 5s 后过期<br>EXPIRE 命令依赖于 SETNX 的执行结果，而事务中没有 if-else 的分支逻辑，如果 SETNX 没有抢到锁，EXPIRE 就不应该执行。<br>加入 SET 指令扩展参数，使 SETNX 和 EXPIRE 指令一起执行： SET key value [EX seconds | PX milliseconds] [NX | XX] [KEEPTTL]<br>设置一个过期时间，就算线程 1挂了，也会在失效时间到了，自动释放<br>计数： 使用 INCR 命令进行 原子性 的自增操作，多个 客户端对同一个 key 进行操作，也决不会导致竞争的情况</p>
<p>Setnx 加锁， expire 过期时间； 不是原子性操作；<br>Redis:: set( “my:lock”,   $token,  “nx”, “ex”, 10);<br>直接使用 set进行锁，参数配置，让 加锁+过期时间 成原子操作；传统的 del 解锁方式，存在问题； 如果  expire time 释放锁后， 其他线程重新获取，直接 del 解锁，会删除别人建立的锁了。通过 lua脚本（保证一系列操作的原子性），先进行 get，再进行 del； 外加 token 字段，一个随机数，当 lock的时候，往redis的 my:lock中存的是这个token，unlock的时候，先 get一下lock中的token，如果 和要删除的 token是一致的，说明这个锁是之前我 set的，否则说明这个锁已经过期，是别人set的，就不应该对它进行任何操作。</p>
<h4 id="场景题：假如-Redis里面有1亿个-key，有10w-key-是以某个固定前缀开头，如何全部找出？"><a href="#场景题：假如-Redis里面有1亿个-key，有10w-key-是以某个固定前缀开头，如何全部找出？" class="headerlink" title="场景题：假如 Redis里面有1亿个 key，有10w key 是以某个固定前缀开头，如何全部找出？"></a>场景题：假如 Redis里面有1亿个 key，有10w key 是以某个固定前缀开头，如何全部找出？</h4><p>使用 keys 指令可以扫出 指定模式的 key列表；如果 redis正在给 线上的业务提供服务，那使用 keys指令会有什么问题？<br>Redis单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。<br>可以使用 scan指令，无阻塞的提取出指定模式的key列表，但会有一定的重复概率，需要在客户端做一次去重，整体所花费的时间会比直接用keys指令长。<br>分布式场景下，多个微服务间协同调用，调用链使用 UUID 唯一</p>
<h3 id="redis常见性能问题和解决方案："><a href="#redis常见性能问题和解决方案：" class="headerlink" title="redis常见性能问题和解决方案："></a>redis常见性能问题和解决方案：</h3><p>1.Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以 Master最好不要写内存快照。<br>2.Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响 Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化, 如果数据比较关键，某个 Slave开启AOF备份数据，策略为每秒同步一次。<br>3.Master 调用bgrewrite AOF 重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。<br>4.Redis主从复制的性能问题，为主从复制速度和连接的稳定性，Slave和 Master最好在同一个局域网内。</p>
<h3 id="Redis-事务特征："><a href="#Redis-事务特征：" class="headerlink" title="Redis 事务特征："></a>Redis 事务特征：</h3><p>1.在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis 不会再为其它客户端请求提供任何服务，从而保证s事务中的所有命令被原子的执行。<br>2.和关系型数据库中的事务相比，在 Redis事务中，如果 某一条命令执行失败，其后的命令仍然会被继续执行。<br>3.通过 multi 命令开启一个事务，在该语句之后执行的命令都将被视为事务之内的操作，最后通过执行 exec&#x2F;discard  命令来提交&#x2F; 回滚 该事务内的所有操作。 这两个Redis命令可被视为等同于关系型数据库中的 commit&#x2F;rollback 语句。<br>4.在事务开启之前，如果 客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。如果网络中断事件是发生在客户端执行exec 命令之后，那么该事务中的所有命令都会被服务器执行。<br>5.当使用 Append-Only模式时，Redis会通过调用系统函数write 将该事务内的所有写操作在本次调用中全部写入磁盘。如果在写入过程中出现系统崩溃，如电源故障导致宕机，此时也许只有部分数据被写入到磁盘，而另一部分数据却已经丢失。Redis服务器会在重启时执行一系列必要的一致性检测，一旦发现类似问题，会立即退出并给出相应的错误提示。 此时需要充分利用Redis 工具包中提供的 redis-check-aof工具来定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复后就可以再次重新启动 Redis服务器了。</p>
<h3 id="Redis做异步队列："><a href="#Redis做异步队列：" class="headerlink" title="Redis做异步队列："></a>Redis做异步队列：</h3><p>使用 list结构作为队列，rpush生产消息， lpop消费消息<br>当lpop没有消息的时候，要适当sleep一会再重试。不使用 sleep: list还有个指令叫 blpop，在没有消息的时候，它会阻塞住直到消息到来。</p>
<p>使用 pub&#x2F;sub主题订阅者模式，可以实现 1:N 的消息队列。<br>pub&#x2F;sub缺点： 在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等</p>
<h3 id="使用Redis-实现可靠的消息队列-ack-机制？"><a href="#使用Redis-实现可靠的消息队列-ack-机制？" class="headerlink" title="使用Redis 实现可靠的消息队列 ack 机制？"></a>使用Redis 实现可靠的消息队列 ack 机制？</h3><p>消费者用 rpop 取出元素，若消费者在 取出元素之后崩溃了，此时消息 已被取出且没有正确处理，会造成该消息的丢失<br>队列的备份：消费者程序在 从主消息队列中取出消息后，再将其插入到备份队列中，直到消费者程序完成正常的处理逻辑后再将该消息从备份队列中删除。<br>当备份队列中消息过期时，重新将其 再放回到主消息队列中，以便其它的消费者程序继续处理。RPOPLPUSH命令执行过程示意图如下：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwktpi57yj60yc0kyq4o02.jpg" alt="7D32B33D-052D-4C35-AB1A-9F995B4E0833" width="650" height="350" />

<h3 id="Redis-如何实现延时队列？"><a href="#Redis-如何实现延时队列？" class="headerlink" title="Redis 如何实现延时队列？"></a>Redis 如何实现延时队列？</h3><p>使用 sortedset，拿时间戳作为 score，消息内容作为 key调用 zadd来生产消息，消费者用 zrangebyscore指令获取N秒之前的数据轮询进行处理。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>集群一致性hash算法</title>
    <url>/2021/07/09/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/Redis/A4-Redis%E9%9B%86%E7%BE%A4%E4%B8%80%E8%87%B4%E6%80%A7Hash%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Redis集群一致性Hash算法"><a href="#Redis集群一致性Hash算法" class="headerlink" title="Redis集群一致性Hash算法"></a>Redis集群一致性Hash算法</h1><p>​    类似于数据库，当单表数据 &gt;500W 时，需要对其进行分库分表，当数据量很大时，同样需要对 Redis进行分库分表的操作。在做缓存集群时，为缓解服务器压力，会部署多台缓存服务器，把数据资源均匀的分配到每个服务器上，分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkyjmsc7j60cq0dxq3z02.jpg" alt="24B62610-55A7-4EE4-8004-C29EA286ABB3" width="450" height="400" />

<p>​    使用上述 Hash算法进行缓存时，会出现一些缺陷，在服务器数量变动时，所有缓存的位置都要发生改变！那原本 hash(a.png) % 4 &#x3D; 2 的公式就变成了 hash(a.png) % 5 &#x3D; ？， 这个结果不是2的，此时所有缓存位置都要发生改变！也就是当服务器数量发生改变时，所有缓存在一定时间内是失效的。<br>​    假设 4 台缓存中突然有一台缓存服务器出现故障，需要将故障机器移除，但如果移除一台缓存服务器，缓存服务器数量从4台变为3台，也会出现上述问题！</p>
<h4 id="一致性Hash算法就是解决这个问题"><a href="#一致性Hash算法就是解决这个问题" class="headerlink" title="一致性Hash算法就是解决这个问题!"></a>一致性Hash算法就是解决这个问题!</h4><p>​    刚才描述的取模法是对服务器的数量进行取模，而 一致性Hash算法是对 2^32 取模，简单来说，一致性Hash算法将整个哈希值空间组织成一个虚拟的圆环，假设某哈希函数H 的值空间为： 0 ~ 2^14<br>​    0点右侧的第一个点代表1，以此类推，2,3,4,5,6……直到 2^14，也就是说 0点左侧的第一个点代表 2^14， 0和2^14 在零点中方向重合，我们把这个由2^14 个点组成的圆环称为 Hash环。下一步将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置，这里假设将上文中四台服务器使用IP地址哈希后在环空间的位置如下：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwkzf0nilj60j70jpgm602.jpg" alt="901FC87C-32CA-4E10-8943-08F53DD41989" width="350" height="350" />


<p>​    接下来使用如下算法定位数据访问到相应服务器：将数据 key使用相同的函数 Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针“行走”，第一台遇到的服务器就是其应该定位到的服务器！</p>
<p><strong>例如:</strong> 有 Object A,Object B,Object C,Object D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwl006m9dj60iy0joq3x02.jpg" alt="A1D101C3-6A2A-4CFE-BF40-CC1E4E055A93" width="350" height="350"/>


<p>​    根据一致性 Hash算法，数据A会被定为到Node A 上，B被定为到Node B上，C被定为到Node C上，D被定为到Node D上。 </p>
<h3 id="一致性Hash算法-容错性和可扩展性"><a href="#一致性Hash算法-容错性和可扩展性" class="headerlink" title="一致性Hash算法 容错性和可扩展性:"></a>一致性Hash算法 容错性和可扩展性:</h3><p>​    现假设Node C 不幸宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。在一致性Hash算法中，如果一台服务器不可用，则受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它不会受到影响，如果在系统中增加一台服务器Node X，如下图所示：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwl0l7ymmj60it0jqwfl02.jpg" alt="506CDC9D-B69A-4C3B-BC31-2323D07AFEDA" width="350" height="350" />


<p>​    此时对象Object A，B，D不受影响，只有对象C需要重定位到新的Node X ！一般的，在一致性Hash算法中，如果增加一台服务器，则受影响的数据仅仅是新服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据，其它数据也不会受到影响。一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。</p>
<h3 id="Hash环的数据倾斜问题："><a href="#Hash环的数据倾斜问题：" class="headerlink" title="Hash环的数据倾斜问题："></a>Hash环的数据倾斜问题：</h3><p>​    一致性Hash算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜（被缓存的对象大部分集中缓存在某一台服务器上）问题，例如系统中只有两台服务器，其环分布如下：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwl15qxuvj60c70cumxi02.jpg" alt="398CEE1E-B2F5-4272-B255-27F09C2248B2" width="350" height="350" />

<p>​    此时必然造成大量数据集中到Node A上，而只有极少量会定位到Node B上。为了解决这种数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。具体做法可以在服务器IP或主机名的后面增加编号来实现。</p>
<p>​    例如:上面的情况，可以为每台服务器计算 三个虚拟节点，于是可以分别计算 “Node A#1”，“Node A#2”，“Node A#3”，“Node B#1”，“Node B#2”，“Node B#3”  哈希值，于是形成六个虚拟节点：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guwl1quftzj60j80jvdgq02.jpg" alt="C98156D9-C596-492C-A992-01E1A3C3266E" width="350" height="350" />

<p>​    通过虚拟节点做为中间变量，再从虚拟节点—&gt;实际节点，实现数据映射。同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射，例如定位到“Node A#1”，“Node A#2”，“Node A#3”  三个虚拟节点的数据均定位到Node A上。 这样就解决了服务节点少时数据倾斜的问题，在实际应用中，通常将虚拟节点数设置为32甚至更大，因此即使很少的服务节点也能做到相对均匀的数据分布。</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-基础</title>
    <url>/2021/05/08/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/2.Kafka%20%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Kafka消息队列-基础"><a href="#Kafka消息队列-基础" class="headerlink" title="Kafka消息队列-基础"></a>Kafka消息队列-基础</h1><p>Kafka消息队列中，队列的名字叫 topic; 多个生产者往同一个队列 topic丢数据，多个消费者往同一个队列(topic)拿数据，为提高一个队列( topic)吞吐量，Kafka把topic进行分区 Partition，生产者往一个发布订阅的topic分区 Partition丢数据，消费者从分区(Partition)中取数据。  </p>
<p>每个 topic下，可能有多个 partition分区:</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutubka7shj60y60c8tal02.jpg" alt="BCA7225F-6CD7-4997-B720-8C0E97C18FF6" width="650" height="300"  />

<p>Topic 可以有多个分区，分区是最小的读取和存储结构， Consumer 是从Topic下的某个分区获得消息，Producer发送消息也是如此，<strong>数据发往哪个partition呢？</strong></p>
<ol>
<li>写入的时候可以指定 partition，如果有指定，则写入对应的 partition</li>
<li>没有指定partition，但设置了数据key，则会根据key的值 hash出一个partition</li>
<li>没有指定 partition ，也没有指定 key ， 会随机选择一个分区，并尽可能一直使用该分区，待该分区的 batch已满或过了间隔时间，再随机一个分区进行使用</li>
</ol>
<p>一台 Kafka服务器叫做 Broker，集群就是多台 Kafka服务器；一个 topic会分为多个partition，实际上 partition 会分布在不同的broker中，实现多机均匀负载。<br><strong>例子：</strong><br>往 topic里边存数据，这些数据会分到不同 partition上，这些 partition存在不同的broker上。<br>如果其中一台 broker挂了，会丢失其中 partition上的数据；但 kafka把这些 partition都做了备份。<br>如：现有三个partition，分别存在三台broker上，每个partition都会备份，这些备份散落在不同的broker上</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuc5g0cjj619c0oydjc02.jpg" alt="BE9B9937-1DC3-4DE6-ABFA-662EFD27312E" width="650" height="300"  />

<p><strong>红色块的 partition代表的是主分区，紫色的 partition块代表的是备份分区</strong>。<br>生产者，消费者都是与主分区交互；<br>备份分区仅用作于备份不做读写，如果某个Broker挂了，就会选举出其他 Broker的 partition来作为主分区，实现高可用每一个 Partition 其实都是一个文件，收到消息后 Kafka会把数据插入到文件末尾（虚框部分）<br><strong>缺点：</strong>没办法删除数据，所以 Kafka 是不会删除数据的，它会把所有的数据都保留下来，每个消费者对每个 Topic都有一个 offset 用来表示读取到了第几条数据， offset 是由对应的消费者维护，会保存到 Zookeeper 里面。</p>
<p>为避免磁盘被撑满，Kakfa 提供两种策略来删除数据：<br>**1.「基于时间」 （默认七天）；        **</p>
<p><strong>2.「基于 Partition 文件大小」</strong></p>
<p>​                                       <img src="https://tva1.sinaimg.cn/large/008i3skNly1gutud52gfgj60iu09waac02.jpg" alt="4235AE89-DA4A-43E7-8143-536C5A97C641" width="450" height="300" /></p>
<p>消息发往一个主题下的某个分区中，例如：某个主题下有 5 个队列，那么这个主题并发度就提高为 5 ，同时可以有 5 个消费者并行消费该主题的消息。<br>消费者都是属于某个消费组的，一条消息会发往多个订阅这个主题的消费组<br>如：两个消费组分别是Group 1 和 Group 2，它们都订阅 Topic-a，此时有一条消息发往 Topic-a，那么这两个消费组都能接收到这条消息。这条消息实际是 写入Topic中的某个分区，消费组中的某个消费者对应消费一个 Topic 的某个分区。每个消费组会有自己的 offset（消费点位）来标识消费到的位置， 在消费点位之前表明已经消费过。 这个offset是 分区级别的，每个消费组都会维护订阅的 Topic下的每个分区的offset。</p>
<p><strong>kafka并发的粒度是 partition</strong>， 每个 partition对应一个消费者，多个消费者同时进行消费，以此来提高并发量。</p>
<h3 id="消息轮询："><a href="#消息轮询：" class="headerlink" title="消息轮询："></a><strong>消息轮询：</strong></h3><p>消费者 通过轮询 API(poll) 向 服务器定时请求数据，一旦消费者订阅了主题，轮询就会处理群组协调、分区再均衡、发送心跳和获取数据，使得开发者只需要关注从分区返回的数据，然后进行业务处理。</p>
<p>Kafka的 Consumer Group 是采用Pull 方式来消费消息，每个Consumer 该消费哪个 Partition 的消息需要一套严格的机制来保证。Partition 可以水平无限扩展，随着 Partition 的扩展 Consumer消费的 Partition也会重新分配，这里涉及到 kafka消息消费分配策略，在 Kafka内部存在两种默认的分区分配策略：Range 和RoundRobin，当以下事件发生时，<strong>Kafka将会进行一次分区分配：</strong><br>1.同一个 Consumer Group内新增消费者<br>2.订阅的主题新增Partition<br>3.消费者离开当前所属的 Group，包括Shuts Down或Crashes</p>
<p>**副本（Replica）： **为更好的做 负载均衡，Kafka 尽量将所有的 Partition均匀分配到整个集群上。<br><strong>部署方式：</strong>一个 Topic 的Partition数量大于Broker的数量，为提高Kafka的容错能力，需要将同一个 Partition的 Replica尽量分散到不同的机器。实际上，如果所有的 Replica 都在同一个Broker上，那一旦该 Broker宕机，该 Partition的所有 Replica都无法工作，也就达不到 备份的效果。<br>同时，如果某个Broker宕机，需要保证它上面的负载可以被 均匀的分配到其它幸存的所有Broker上。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutudyfq29j60zi0pwgpd02.jpg" alt="8A414154-00B7-4EAB-8025-D0CFAEC15B43" width="650" height="350" />



<h3 id="持久化："><a href="#持久化：" class="headerlink" title="持久化："></a>持久化：</h3><p>Kafka是将 partition数据写在 磁盘(记录消息日志)，是 <strong>追加写入，避免随机 I&#x2F;O 操作，寻址磁盘效率低</strong>。<br>持久化时，partition会先缓存一部分, 放在page cache中，等到 足够多数据量&#x2F;等待一定的时间 再批量写入(flush)。<br>消费者实际上也是从partition中取数据。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuedmg33j61a80nctcs02.jpg" alt="D6797C5D-56AF-4A43-8706-004AEBEE0D7F" width="750" height="400"  />



<p>生产者,消费者 都是可以有多个的，多个消费者可以组成一个消费者组，如果一个消费者消费三个分区，有消费者组就可以 每个消费者去消费一个分区，消费者组中各个消费者并发消费，以此来提高吞吐量。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuepadv8j618a0isdis02.jpg" alt="899EF880-3E09-42EF-9A2A-7599E1DB5DB9" width="750" height="350"  />

<p>​    如果消费者组中的某个消费者挂了，那么其中有一个消费者就要消费两个 partition；如果只有三个partition，而消费者组有4个消费者，那么一个消费者会空闲。消费者组之间从逻辑上是独立的，如果多加入一个消费者组，无论是新增的消费者组还是原本的消费者组，都能消费topic的全部数据；<br>​    生产者往 topic里丢数据是存在partition上，而 partition持久化到磁盘是 IO顺序访问，并且是先写缓存，隔一段时间或者数据量足够大的时候才批量写入磁盘的。正常的读磁盘数据是需要将 内核态数据拷贝到用户态的，Kafka通过零拷贝方式，直接从内核空间（DMA）到内核空间-Socket buffer，少做了一半拷贝操作。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuez2y0mj61860kegn202.jpg" alt="E20EAB06-EA82-4014-AA89-8ECFADAE9169" width="650" height="320"  />

<p>​    offset 表示消费者的消费进度，每个消费者都有自己的 offset; 每次消费者消费的时候，都会提交这个offset。<br>一个消费者组中的某个消费者挂了，但其所在分区可能有存活的消费者，存活的消费者继续去消费，但需要知道挂掉的消费者具体消费到了哪里，这里就需要offset。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuf9vkrnj618i0ny77c02.jpg" alt="3489FA28-B499-43B6-B4E8-D3C1CD8216FB" width="650" height="380"  />

<p><strong>Kafka 利用二分法来查找对应 offset 的消息位置：</strong></p>
<ol>
<li>按照二分法找到小于 offset的 segment 的.log 和.index</li>
<li>用目标 offset 减去文件名中的 offset得到消息在这个 segment 中的偏移量</li>
<li>再次用二分法在 index 文件中找到对应的索引</li>
<li>到 log 文件中，顺序查找，直到找到 offset 对应的消息</li>
</ol>
<p><strong>Kafka是分布式：</strong>往一个 topic丢数据实际上就是 往多个 broker的 partition存储数据，将 partition以消息日志的方式存储起来，通过 顺序访问IO和缓存(等到一定的量或时间) 才真正把数据写到磁盘上，以此来做持久化。<br>单个 partition写入是有顺序的，要保证全局有序 只能写入一个partition； 要消费有序则消费者也只能有一个<br>分布式无法避免 网络抖动&#x2F;机器宕机 等问题的发生，很有可能 消费者A读取数据，还没来得及消费就挂了。<br>Zookeeper 发现消费者A挂了，让消费者B 去消费原本A的分区，等消费者A重连的时候，发现已经重复消费同一条数据了(或消费者超时等等都有可能…)<br>如果 业务上 不允许重复消费，最好 消费者那端做业务上的校验（如果已经消费过就不消费了）</p>
<h3 id="Kafka-和-其他消息队列的区别？"><a href="#Kafka-和-其他消息队列的区别？" class="headerlink" title="Kafka 和 其他消息队列的区别？"></a>Kafka 和 其他消息队列的区别？</h3><p>  Kafka设计目标：高吞吐量</p>
<p>1、Kafka操作 序列文件 I &#x2F; O（序列文件 按顺序写，按顺序读），为保证顺序，强制点对点的按顺序传递消息，一个 consumer在分区 中只有一个位置。<br>2、Kafka 不保存消息状态（消息是否被“消费”）一般消息系统需保存消息的状态，并且还需要以随机访问的形式更新消息的状态。<br>而Kafka 保存Consumer在 Topic分区中的位置 offset，offset之前的消息是已“消费”的， offset之后为“未消费”的，offset 可以任意移动，以此消除随机IO。<br>3、Kafka支持 点对点的 批量消息传递<br>4、Kafka 消息存储在 page cache（大小为一页4K ）用于缓存文件的逻辑内容，从而加快对磁盘上映像和数据的访问</p>
<h3 id="如何保证不丢失消息？"><a href="#如何保证不丢失消息？" class="headerlink" title="如何保证不丢失消息？"></a>如何保证不丢失消息？</h3><p><strong>生产者 ACK机制：</strong><br>Kafka 采用至少一次保证消息不会丢，但可能会重复传输；acks 的默认值即为1，代表消息被 leader 接收之后才算成功发送，可以配置 acks &#x3D; all 代表所有副本都接收到该消息之后，才算真正成功发送。</p>
<p><strong>设置分区：</strong><br>为保证 leader 可以根据follower 同步消息，一般会为 topic设置 replication.factor &gt;&#x3D; 3；这样就可以保证每个分区(partition) 至少有 3个副本，以确保消息队列的安全性；单机情况下，通过持久化到磁盘来保证消息不丢失 。</p>
<p><strong>发送消息：</strong><br>Kafka 支持在生产者一侧进行 本地 buffer，累积一定条数才发送，如果这里设置不当会丢消息的。<br>生产者端设置：producer.type&#x3D;async, 默认是 sync；当设置为 async，会大幅提升性能，因为生产者会在本地缓冲消息，并适时批量发送； 如果对可靠性要求高，设置为 sync 同步发送  ；一般需要设置：min.insync.replicas&gt; 1 ，消息至少要被 写入到这么多 follower 才算成功，也是提升数据持久性的一个参数，与acks配合使用。但如果出现两者相等，还需要设置 replication.factor &#x3D; min.insync.replicas + 1 ，避免一个副本挂掉，整个分区无法工作的情况！</p>
<p><strong>消费者端：</strong><br>消息处理完成前提交offset，可能造成数据的丢失， Consumer默认自动提交 offset(位移)，在后台提交位移前一定要保证消息被正常处理。 如果处理耗时很长，建议把逻辑放到另一个线程中去做，异步提交ack 会提高消费者的响应速度，但容易造成消息丢失。为避免消息丢失，设置 enable.auto.commit&#x3D;false，关闭自动提交位移，在消息被完整处理之后再手动提交位移。</p>
<p>参考：Kafka总结–<a href="https://my.oschina.net/u/4377703/blog/4325442">https://my.oschina.net/u/4377703/blog/4325442</a></p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka-高级</title>
    <url>/2021/05/09/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/3.Kafka%20%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96-%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="Kafka-性能优化-高级"><a href="#Kafka-性能优化-高级" class="headerlink" title="Kafka 性能优化-高级"></a>Kafka 性能优化-高级</h1><p>性能问题主要是三个方面：<strong>网络、磁盘、复杂度</strong>；对于 Kafka 分布式队列，网络、磁盘 是优化的重点<br><strong>解决方案：</strong>并发、压缩、批量、缓存  </p>
<h3 id="Kafka-为什么快？"><a href="#Kafka-为什么快？" class="headerlink" title="Kafka 为什么快？"></a>Kafka 为什么快？</h3><ol>
<li>顺序读写磁盘</li>
<li>零拷贝网络和磁盘</li>
<li>数据批量压缩，传输，减少网络 IO 损耗</li>
<li>Partition 并行和可扩展</li>
<li>高效的文件数据结构设计</li>
<li>优秀的网络模型（基于 Java NIO）</li>
</ol>
<h3 id="1-顺序读写磁盘"><a href="#1-顺序读写磁盘" class="headerlink" title="1.顺序读写磁盘"></a>1.顺序读写磁盘</h3><p>完成一次磁盘IO，经过 寻道、旋转、数据传输三个步骤，如果写磁盘时 省去寻道、旋转可以极大地提高磁盘读写的性能。虽然使用硬盘存储，但仍然速度很快。<br>Kafka 采用 顺序写文件的方式来提高磁盘写入性能，基本减少了 磁盘寻道和旋转的次数。<br>Kafka 中 每个分区是一个有序的，不可变的消息序列，新消息不断追加到 Partition 的末尾，在 Kafka 中 Partition 只是一个逻辑概念，将 Partition 划分为多个 Segment，每个 Segment 对应一个物理文件，Kafka 对 segment 文件追加写，这就是顺序写文件。 </p>
<h3 id="2-零拷贝网络和磁盘"><a href="#2-零拷贝网络和磁盘" class="headerlink" title="2.零拷贝网络和磁盘"></a>2.零拷贝网络和磁盘</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuu3hq52j61020gu40s02.jpg" alt="CE3A9512-3107-4375-9982-6E6E677FE7E4" width="550" height="300" />

<p>传统的 IO流程，先读取 网络IO，再写入磁盘IO，实际需要将数据 Copy 四次</p>
<ol>
<li>第一次：读取 磁盘文件 到 操作系统 内核缓冲区；DMA搬运的</li>
<li>第二次：将 内核缓冲区 的数据，copy 到 应用程序的 buffer；CPU </li>
<li>第三步：将 应用程序 buffer 中的数据，copy 到 socket buffer (网络发送缓冲区); CPU </li>
<li>第四次：将 socket buffer 的数据，copy 到 网卡，由 网卡进行网络传输。  DMA<br>磁盘 —&gt; 内核 buf—&gt; 用户 buf—&gt; Socket buf—&gt; 网卡<br>内核 buf —&gt; Socket buf —&gt; 网卡</li>
</ol>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuue7s5tj60y00lyq3y02.jpg" alt="BE3BEF3C-ABB9-4285-B3E7-6C9FB4647779" width="350" height="300" /><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuvkxwwjj60fe0kit9402.jpg" alt="46ACAB27-0054-4A38-98D2-A82C58E3FEE1" width="350" height="400" /></p>
<p>Kafka 实现零拷贝，在模型中上下文切换数量减少一倍，只有 2次copy，只有DMA来进行数据搬运，而不需要CPU。<br><strong>第一次通过 DMA</strong>，从 磁盘 —&gt; 内核读缓冲区<br><strong>第二次根据 Socket的描述符信息</strong>，使用 DMA 直接从 内核缓冲区—&gt;写入到 网卡缓冲区<br>零拷贝是尽量去减少上面数据的拷贝次数，减少拷贝的 CPU开销，减少用户态内核态的上下文切换次数，从而优化数据传输的性能。</p>
<p><strong>同一份数据的 传输次数从 四次变成两次，并且没有通过 CPU来进行数据搬运，所有数据都通过 DMA来进行传输</strong>。<br>没有在内存层面去复制数据，所以这个方法也被称为零拷贝。 </p>
<h3 id="DMA（Direct-Memory-Access）-技术："><a href="#DMA（Direct-Memory-Access）-技术：" class="headerlink" title="DMA（Direct Memory Access） 技术："></a>DMA（Direct Memory Access） 技术：</h3><p>​    在主板上放⼀块独立的芯片，在进行 内存 和 I&#x2F;O设备的数据传输 时，不再通过 CPU 控制数据传输，而直接通过 DMA控制器  ，传统的 从硬盘读取数据，然后再通过 网卡向外发送，需要进行四次数据传输，其中有两次是发生在内存里的缓冲区和对应的硬件设备之间，没法节省掉。但是还有两次，完全是通过 CPU在内存里面进行数据复制，<br>在 Kafka里，通过 Java 的 NIO 里面 FileChannel的 transferTo方法调用，可以不用把 数据复制到应用程序的内存里面。通过DMA的方式，可以把 数据从内存缓冲区 直接写到 网卡的缓冲区里面。</p>
<p>​    DMAC 是一个 协处理器芯片，通过这个芯片，CPU 只需要告诉 DMAC，我们要 传输什么数据，从哪里来，到哪里去，就可以放心离开了；后续的实际数据传输工作，都会有 DMAC 来完成。随着现代计算机各种外设硬件越来越多， 光一个通用的 DMAC 芯片不够了，我们在各个外设上都加上了 DMAC 芯片，使得 CPU 很少再需要关心数据传输的工作了。  数据传输工作用不到多少 CPU 核新的“计算”功能，发送数据使用sendfile： </p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuwfbh9xj612s0je76g02.jpg" alt="1C7E2EEF-E6D9-40ED-B269-880447776636" width="450" height="300" />



<h3 id="Page-Cache-作用"><a href="#Page-Cache-作用" class="headerlink" title="Page Cache 作用"></a>Page Cache 作用</h3><ul>
<li>缓存最近被访问的数据 </li>
<li>预读功能</li>
</ul>
<p>如果 producer 生产与 consumer消费 速度差不多，可以只对 broker page cache 读写来完成整个生产–消费过程，磁盘访问非常少，producer 生产消息到 Broker ，Broker 按偏移量写入数据，此时数据会先写入 page cache内存区域。consumer 消费消息时，Broker 将数据从  page cache 传输到 Socket buffer，再将 Socket Buffer的数据 copy到网卡，由网卡进行网络传输。 page cache中的数据会随着内核中 flusher 线程的调度写回到磁盘，不用担心数据丢失。如果 consumer要消费的消息不在page cache里，会去磁盘读取。</p>
<h3 id="3-批量发送与压缩"><a href="#3-批量发送与压缩" class="headerlink" title="3.批量发送与压缩"></a>3.批量发送与压缩</h3><p>Producer 向 Broker 发送消息不是一条一条的发送， 而是进行批量发送，将消息缓存在本地，等到定条件 发送到 Broker；<br><strong>1.消息条数；  2.固定一段时间</strong></p>
<p>Producer 执行流程如下图：</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuxm5jfdj62420q843l02.jpg" alt="B84EC345-6856-45D9-9253-F904252F6482" width="850" height="350"  />

<ul>
<li>Serialize：序列化传递的消息 (序列化后可提高网络传输效率)</li>
<li>Partition：决定将消息写入主题的哪个分区</li>
<li>Compress：压缩消息，提高传输速度（生产者—&gt;代理），提高吞吐量，降低延迟并提高磁盘利用率</li>
<li>Accumulate：消息累计器，每个 Partition维护一个双端队列，队列保存将要发送的批次数据，Accumulate将数据累计到一定数量，或在一定时间内，将数据以批次的方式发送出去， 主题中的每个分区都有一个单独的累加器 &#x2F; 缓冲区。</li>
<li>Group Send：记录每个分区的消息数量，当达到定义大小 或达到定义的延迟时间时，将它们发送到的分组</li>
</ul>
<p><strong>压缩作用：</strong> 减少传输的数据量，减轻对网络的传输压力<br>Producer、Broker 和 Consumer  使用相同的压缩算法， producer 向 Broker 写入数据，Consumer 向 Broker 读取数据时不用解压缩，当消息发送到Consumer 后才解压，这样将  节省大量网络开销<br>Producer 压缩之后，Consumer 需进行解压，虽然增加 CPU的工作，但在对大数据处理上，瓶颈在网络而不是CPU，所以这个成本是值得的<br>注意：「批量发送」+「数据压缩」一起使用，单条做数据压缩的话，效果不明显 </p>
<h3 id="4-Partition-并行和可扩展"><a href="#4-Partition-并行和可扩展" class="headerlink" title="4.Partition 并行和可扩展"></a>4.Partition 并行和可扩展</h3><p>​        每个 Partition是一个队列，同一个 Group下不同 Consumer并发消费 Paritition，Paritition分区是并行度最小单元，每增加一个 Paritition就增加了一个消费的并发。 Kafka 具有分区分配算法—StickyAssignor，保证分配尽量均衡，每一次重分配结果尽量与上一次分配结果保持一致。各个 Broker和 Consumer的处理不至于出现太大倾斜</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuy04fzfj61bw0fyq6302.jpg" alt="6B3C5626-E274-4DC7-942B-9C48BF4CC9FF" width="750" height="300"  />

<p><strong>分区多导致的问题：</strong><br>客户端&#x2F;服务器端 需要使用更多的内存：客户端 producer 有个参数 batch.size，默认是 16KB。它会为每个分区缓存消息，一旦满了就打包将消息批量发出。因为这个参数是分区级别的，如果分区数量变多，则 缓存所需的内存也会变得更多。</p>
<p><strong>恢复数据慢：</strong>分区越多，每个 Broker上分配的分区也就越多，当发生 Broker 宕机，那么恢复时间将很长</p>
<h3 id="5-高效的文件数据结构"><a href="#5-高效的文件数据结构" class="headerlink" title="5.高效的文件数据结构"></a>5.高效的文件数据结构</h3><p>消息以 Topic为单位进行归类，各个 Topic之间是彼此独立的，互不影响。每个 Topic可以分为一个或多个分区，每个分区各自存在一个记录消息数据的日志文件,每个分区日志在物理上按大小被分成多个 Segment。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuybbil5j61300ha0us02.jpg" alt="CFBF5196-26D1-477E-A43F-D47B2E727C71" width="750" height="300"  />

<p>segment file 组成： index file 和 data file， 2 个文件一一对应，成对出现（索引文件 .index ，数据文件 .log）<br>segment 文件命名规则：partition 全局的第一个 segment 从 0 开始，后续每个 segment 文件名为上一个 segment 文件最后一条消息的 offset 值。数值最大为 64 位 long 大小，19 位数字字符长度，没有数字用 0 填充。index 采用稀疏索引，这样每个 index文件大小有限。Kafka 采用 mmap的方式，直接将 index文件映射到内存，这样对 index 就不需要操作磁盘IO。mmap的 Java实现对应MappedByteBuffer 。</p>
<h3 id="Mmap-一种-内存映射文件的方法"><a href="#Mmap-一种-内存映射文件的方法" class="headerlink" title="Mmap: 一种 内存映射文件的方法"></a>Mmap: 一种 内存映射文件的方法</h3><p>​    将一个文件或其它对象映射到 进程的地址空间，实现 文件磁盘地址和 进程虚拟地址空间中一段虚拟地址 一一对映关系。实现这样的映射关系后，进程可以采用 指针的方式读写操作这段内存，而系统会自动回写脏页面到对应的文件磁盘上，即对文件进行操作，不必调用 read, write 等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而实现不同进程间的文件共享。</p>
<p><strong>Memory Mapped Files（mmap）：</strong> 将磁盘文件映射到内存, 用户通过修改内存达到修改磁盘文件的效果<br>接收来自socket buffer的网络数据，应用进程不需要中间处理、直接进行持久化时。——可以使用mmap内存文件映射。<br><strong>原理：</strong>直接利用操作系统的 Page来实现文件到物理内存的直接映射, 完成映射之后对物理内存的操作会被同步到硬盘上（操作系统在适当的时候）。通过 mmap，进程像 读写硬盘一样读写内存（虚拟机内存），也不必关心内存的大小（有虚拟内存兜底），这种方式可以获取很大的 I&#x2F;O提升，省去了用户空间到 内核空间复制的开销。 </p>
<p><strong>Mmap问题：</strong>不可靠，写到 mmap中的数据并没有被真正的写到硬盘，操作系统会在程序主动调用 flush的时候才把数据真正的写到硬盘。</p>
<p><strong>解决：</strong>Kafka 提供一个参数——producer.type 来控制是不是主动flush；如果Kafka写入到mmap之后就立即flush然后再返回Producer叫同步(sync)；写入mmap之后立即返回 Producer不调用flush叫异步(async)。 </p>
<h3 id="mmap-write-方式持久化数"><a href="#mmap-write-方式持久化数" class="headerlink" title="mmap+write 方式持久化数"></a>mmap+write 方式持久化数</h3><p>使用 mmap+write 方式代替原来的 read+write 方式，mmap 是一种内存映射文件的方法<br>Mmap将 磁盘文件映射到 内存，支持读和写，对 内存的操作会反映在磁盘文件上。<br>原理：将 读缓冲区地址和 用户缓冲区地址进行映射，内核缓冲区 和 应用缓冲区共享，减少从读缓冲区到用户缓冲区的一次CPU拷贝</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuym6baej61280iktau02.jpg" alt="E4CED1AF-9543-48D1-B4CA-3CC422DD259E" width="750" height="300"  />



<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>现代操作系统都使用虚拟内存，使用虚拟地址取代物理地址，这样做的好处是：<br>1.一个以上的 虚拟地址可以指向同一个物理内存地址<br>2.虚拟内存空间可大于实际可用的物理地址</p>
<p>利用第一条特性可以把 内核空间地址和 用户空间的虚拟地址映射到同一个物理地址，这样 DMA 就可以 填充对内核和用户空间进程同时可见的缓冲区了；省去内核与用户空间的往来拷贝， Java 也利用操作系统的此特性来提升性能，下面重点看看 Java 对零拷贝都有哪些支持。</p>
<h3 id="6-优秀的网络模型（基于-Java-NIO）"><a href="#6-优秀的网络模型（基于-Java-NIO）" class="headerlink" title="6.优秀的网络模型（基于 Java NIO）"></a>6.优秀的网络模型（基于 Java NIO）</h3><p>Kafka 底层基于 Java NIO，采用 Reactor 线程模型，做的网络模型 RPC<br>在传统阻塞 IO 模型中问题：<br>1.每个连接都需要 独立线程处理，当并发数大时，创建线程数多，占用资源；<br>2.采用阻塞IO模型，连接建立后，若当前线程没有数据可读，线程会阻塞在读操作上，造成资源浪费</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuz1l1vnj60xw0bcgnq02.jpg" alt="E8BFFFF6-0AAE-40F9-937D-CAB93D9F5646" width="650" height="250"  />

<p>针对传统阻塞IO模型的两个问题，解决方案：</p>
<p>1.基于 池化思想：避免为每个连接创建线程，连接完成后将业务处理交给线程池处理 </p>
<p>2.基于 IO复用模型：多个连接共用同一个阻塞对象，不用等待所有的连接，遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理 </p>
<h3 id="Reactor-线程模型思想：-基于-IO复用-线程池"><a href="#Reactor-线程模型思想：-基于-IO复用-线程池" class="headerlink" title="Reactor 线程模型思想： 基于 IO复用 + 线程池"></a>Reactor 线程模型思想： 基于 IO复用 + 线程池</h3><p>​    Reactor 模型基于 池化思想，当 连接完成后 将业务处理交给线程池处理，避免为 每个连接创建线程；基于 IO 复用模型，多个连接共用同一个阻塞对象，不用等待所有的连接。遍历到有新数据可以处理时，操作系统会通知程序，线程跳出阻塞状态，进行业务逻辑处理。<br><strong>实现原理：</strong>Reactor 模式 ：处理并发 I&#x2F;O  常见模式，将所有要 处理的 IO 事件注册到一个中心 I&#x2F;O 多路复用器上，同时 主线程&#x2F;进程 阻塞在多路复用器上；一旦有 I&#x2F;O 事件到来或准备就绪 (文件描述符或 socket 可读、写)，多路复用器返回并将事先注册的相应 I&#x2F;O 事件分发到对应的处理器中。<br>​    Reactor 利用事件驱动机制实现，应用程序需提供相应接口，并注册到Reactor 上，如果相应事件发生，Reactor将主动调用应用程序注册的接口。</p>
<p>epoll 模式已经可以使服务器并发几十万连接的同时，维持极高 TPS，为什么还需要 Reactor 模式？<br><strong>原因：</strong>原生的 I&#x2F;O 复用编程复杂性比较高（ epoll ）<br>例如：编程中，处理请求 A 时，可能经过多个 I&#x2F;O 操作 A1-An，每经过一次 I&#x2F;O 操作，再调用 I&#x2F;O 复用时，I&#x2F;O 复用的调用返回里，可能不再有 A，而返回了请求 B。请求 A 会经常被请求 B 打断，处理请求 B 时，又被 C 打断。使得编程较为复杂。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuzhwym1j60yu0jidih02.jpg" alt="A2B0143B-0D56-4D34-8431-18E33083441D" width="600" height="300"  />

<h4 id="Reactor-模型-主要分为三个角色："><a href="#Reactor-模型-主要分为三个角色：" class="headerlink" title="Reactor 模型 主要分为三个角色："></a><strong>Reactor 模型 主要分为三个角色：</strong></h4><p>*Reactor： 把 IO 事件分配给对应的 handler 处理<br>*Acceptor：处理客户端连接事件<br>*Handler： 处理非阻塞的任务</p>
<p>Acceptor线程用于处理新的连接，Handler 线程处理业务逻辑<br>I&#x2F;O 多路复用可以把多个 I&#x2F;O 阻塞，复用到同一个 select 阻塞上，从而使得系统在单线程情况下，可以同时处理多个客户端请求，不需要创建新的线程，降低了系统的资源开销</p>
<h3 id="Reactor线程模型分类："><a href="#Reactor线程模型分类：" class="headerlink" title="Reactor线程模型分类："></a>Reactor线程模型分类：</h3><p>根据 Reactor的数量和处理资源的线程数量的不同，分为三类：  单Reactor单线程模型；单Reactor多线程模型；多Reactor多线程模型。</p>
<p>单Reactor单线程模型：在Reactor中处理事件，并分发事件，如果连接事件交给acceptor处理，如果是读写事件和业务处理，就交给 handler处理，但始终只有一个线程执行所有的事情。<br><strong>问题：</strong><br>1.仅用一个线程处理请求，对于多核资源机器来说是有点浪费的。<br>2.当处理读写任务的线程负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差。<br>3.单线程也会有可靠性的问题。</p>
<p>单Reactor 多线程模型：和单线程模型主要区别： 把业务处理从之前的单一线程脱离出来，换成线程池处理。<br>Reactor线程 只处理 连接事件和读写事件，业务处理交给 线程池处理，充分利用多核机器的资源，提高性能并且增加可靠性。<br><strong>问题：</strong><br>1.Reactor线程承担所有的事件，例如监听和响应，高并发场景下单线程存在性能问题</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutuzz3zk9j60w40lsad802.jpg" alt="98B39D17-7A7C-417D-8D4D-49411EA81C6D" width="600" height="350"  />

<p>多Reactor多线程模型：和单Reactor多线程模型相比，把 Reactor线程拆分 mainReactor和 subReactor两个部分，<br>mainReactor 只处理连接事件，mainRactor只处理连接事件，用一个线程来处理就好。<br>读写事件交给subReactor来处理，处理读写事件的subReactor个数一般和CPU数量相等，一个subReactor对应一个线程，业务逻辑由线程池处理。<br>业务逻辑还是由线程池来处理。<br>这种模型使各个模块职责单一，降低耦合度，性能和稳定性都有提高</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutv0d4suxj60x60m2q6c02.jpg" alt="710026EB-C05B-4CDF-A05C-47DCDD1422C7" width="650" height="450"  />

<p><strong>Reactor三种模式形象比喻：</strong><br>餐厅一般有接待员和服务员，接待员负责在门口接待顾客，服务员负责全程服务顾客<br>单Reactor单线程模型：接待员和服务员是同一个人，一直为顾客服务。客流量较少适合</p>
<ol>
<li>单Reactor多线程模型：一个接待员，多个服务员。客流量大，一个人忙不过来，由专门的接待员在门口接待顾客，然后安排好桌子后，由一个服务员一直服务，一般每个服务员负责一片中的几张桌子</li>
<li>多Reactor多线程模型：多个接待员，多个服务员。这种就是客流量太大了，一个接待员忙不过来了</li>
</ol>
<h3 id="推拉模式："><a href="#推拉模式：" class="headerlink" title="推拉模式："></a>推拉模式：</h3><p>Producer 与 Broker 是推方式;  推拉模式 指 Comsumer 和 Broker 之间的交互</p>
<h4 id="拉模式的优点："><a href="#拉模式的优点：" class="headerlink" title="拉模式的优点："></a>拉模式的优点：</h4><p>1.消费者可以根据自身的情况来发起 拉取消息的请求, 假设当前消费者觉得自己消费不过来，可以根据一定的策略停止拉取，或者间隔拉取<br>2.Broker 只管存生产者发来的消息，消费者主动发起，来一个请求就给它消息，从哪开始拿消息，拿多 少消费者都告诉它<br>3.适合进行 消息批量发送，拉模式可以参考消费者请求的信息来 决定缓存多少消息之后批量发送;  </p>
<h4 id="拉模式的缺点："><a href="#拉模式的缺点：" class="headerlink" title="拉模式的缺点："></a>拉模式的缺点：</h4><p>1.消息延迟，消费者去拉取消息，但消费者不知道消息到了没，它只能不断地拉取，但又不能很频繁地请求，太频繁就变成消费者在攻击 Broker , 因此需要降低请求频率，比如隔个 2 秒请求一次.<br>2.消息忙请求，比如消息隔了几个小时才有，那么在几个小时之内消费者的 请求都是无效的，在做无用功</p>
<p>Kafka 是拉模式，业界基于推模式的消息队列 ActiveMQ </p>
<h3 id="Kafka-应对拉模式缺点："><a href="#Kafka-应对拉模式缺点：" class="headerlink" title="Kafka 应对拉模式缺点："></a>Kafka 应对拉模式缺点：</h3><p>Kafka 中的长轮询：<br>消费者 和 Broker 相互配合，拉取消息请求不满足条件的时候 hold 住，避免多次频繁的拉取动作，当消息一到就提醒返回；拉请求可以设置参数，使消费者在 “长轮询” 中阻塞等待；消费者去 Broker 拉消息，定义一个超时时间，如果有马上返回消息，如果没有消费者等着直到超时，然后再次发起拉消息请求。当没有消息时，Broker 建立一个延迟操作，等条件满足再返回。</p>
<p>这个延迟操作需要 检查机制，查看消息是否已经到了，有消息到了之后该执行的方法，执行完毕后进行什么操作的方法，超时后进行什么操作的方法；判断是否过期就是由 时间轮来推动判断的，在消息写入的时候提醒这些延迟请求消息来了。</p>
<p><strong>推模式：</strong>消息从 Broker 推向 Consumer，即 Consumer 被动的接收消息，由 Broker 来主导消息的发送</p>
<h4 id="推模式的优点："><a href="#推模式的优点：" class="headerlink" title="推模式的优点："></a>推模式的优点：</h4><p>1.消息实 时性高， Broker 接受完消息之后可以立马推送给 Consumer<br>2.对于 消费者使用来说更简单，有消息来了就会推过来</p>
<h4 id="推模式的缺点："><a href="#推模式的缺点：" class="headerlink" title="推模式的缺点："></a>推模式的缺点：</h4><p>1.推送速率难以适应消费速率，以最快的速度推送消息，当生产者往 Broker 发送消息的速率大于消费者消费消息的速率时，消费者可能消费不过来<br>2.不同消费者的消费速率不一样，身为 Broker 很难平衡每个消费者推送速率<br>3.难以根据消费者的状态控制推送速率，适用于消息量不大，消费能力强，要求实时性高的情况</p>
]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法汇总</title>
    <url>/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/1.%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h4 id="排序算法总结："><a href="#排序算法总结：" class="headerlink" title="排序算法总结："></a>排序算法总结：</h4><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fd578lsfj20ll0bp3zc.jpg" alt="82BAF801-27D7-496B-BDE1-0BC3461F6172" width="650" height="400" />



<h3 id="归并排序："><a href="#归并排序：" class="headerlink" title="归并排序："></a><strong>归并排序：</strong></h3><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fczk2g0fj20u00u6wgu.jpg" alt="99D30D77-7213-4598-8705-403B62FC60F0" width="550" height="500" />



<p><strong>思路： 使用额外空间 res[]</strong> </p>
<p>1.首先把一个未排序的序列从中间分割成2部分<br>2.再把2部分分成4部分，依次分割下去，直到分割成一个一个的数据<br>3.再把这些数据两两归并到一起，使之有序，不停的归并，最后成为一个排好序的序列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 归并排序:   r=len-1</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">    merge2(nums, l, m);</span><br><span class="line">    merge2(nums, m+<span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i=l, j=m+<span class="number">1</span>, k=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] tmp = <span class="keyword">new</span> <span class="title class_">int</span>[r-l+<span class="number">1</span>]; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m &amp;&amp; j&lt;=r)&#123;</span><br><span class="line">        tmp[k++] = nums[i]&lt;nums[j]? nums[i++]:nums[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=m) tmp[k++] = nums[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=r) tmp[k++] = nums[j++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>;id&lt;=r-l;id++) nums[id+l] = tmp[id];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.外 for： 0—len<br>2.内 for:  0–i;<br>外层遍历一遍没有交换元素时： 表示排完，终止 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] bubble(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;nums.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;nums.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&gt;nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                nums[j] ^= nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] ^= nums[j];</span><br><span class="line">                nums[j] ^= nums[j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><h4 id="思路：-1"><a href="#思路：-1" class="headerlink" title="思路："></a>思路：</h4><p>从 i –&gt;nums.length 的数组列表中，每次选择最小的元素，放到第 i 个位置上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">get_min</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l)</span>&#123;</span><br><span class="line">    <span class="type">int</span> min_v=nums[l], min_id=l;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l+<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(min_v &gt; nums[i])&#123;</span><br><span class="line">            min_v=nums[i];</span><br><span class="line">            min_id=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min_id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] select_sort(<span class="type">int</span>[] nums)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="type">int</span> min_id=get_min(nums, i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[min_id];</span><br><span class="line">        nums[min_id] = nums[i];</span><br><span class="line">        nums[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><h4 id="思路：-2"><a href="#思路：-2" class="headerlink" title="思路："></a>思路：</h4><p>前面的排好序，每次取当前的值，<strong>从后向前遍历，直到出现 &gt; 情况时， 进行填入</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;len; id++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[id]; <span class="comment">//记录当前元素值</span></span><br><span class="line">        <span class="type">int</span> i=id; </span><br><span class="line">        <span class="comment">// 遍历当前元素之前到所有元素，每一个元素都向后移动一位</span></span><br><span class="line">        <span class="keyword">for</span>( ; i&gt;<span class="number">0</span> &amp;&amp; arr[i-<span class="number">1</span>]&gt;tmp; i--)&#123;</span><br><span class="line">            arr[i] = arr[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>快速排序</title>
    <url>/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/2.%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>思路： </p>
<p>取第一个元素，右–&gt;左：直到碰到&lt; 赋值给左； 再 左–&gt;右：直到碰到&gt; 赋值给右；</p>
<p>一次遍历完划分左右 2部分</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quick_sort</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> ;   <span class="comment">// 终止条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不对数组进行截取时，要定义 起止下标</span></span><br><span class="line">    <span class="type">int</span> high=r, low=l;       </span><br><span class="line">    <span class="type">int</span> base=nums[l];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; base&lt;=nums[r]) r--;</span><br><span class="line">        nums[l]=nums[r];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; base&gt;nums[l]) l++;</span><br><span class="line">        nums[r]=nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l]=base;</span><br><span class="line">    <span class="comment">// 分支递归</span></span><br><span class="line">    quick_sort(nums,low,l-<span class="number">1</span>);</span><br><span class="line">    quick_sort(nums,l+<span class="number">1</span>,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>堆排序算法</title>
    <url>/2022/04/19/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/3.%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h3 id="堆排序算法："><a href="#堆排序算法：" class="headerlink" title="堆排序算法："></a>堆排序算法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> arr[] ,<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">    arr[i] = arr[j];</span><br><span class="line">    arr[j] = tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以 i 作为节点时， 进行的左 右子树的调整</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l= <span class="number">2</span>*i+<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r= <span class="number">2</span>*i+<span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l&lt;len &amp;&amp; arr[base]&lt;arr[l]) base=l;</span><br><span class="line">    <span class="keyword">if</span>(r&lt;len &amp;&amp; arr[base]&lt;arr[r]) base=r;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(base!= i)&#123;</span><br><span class="line">        swap(arr, i, base);</span><br><span class="line">        heapify(arr, base, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] heap_sort(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">    <span class="type">int</span> len=arr.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">parent</span> <span class="operator">=</span> (len-<span class="number">1</span>)/<span class="number">2</span>;   <span class="comment">//最后一个节点的父节点</span></span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(arr, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 排序</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        swap(arr,<span class="number">0</span>, i);</span><br><span class="line">        heapify(arr, <span class="number">0</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>类型题：</p>
<p>查找第K大的数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find_K_nums</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> K)</span>&#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="type">int</span> parent=(len-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=parent; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        heapify(nums, i, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> res=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;len-K; i--)&#123;</span><br><span class="line">        swap(nums, <span class="number">0</span>, i);</span><br><span class="line">        heapify(nums, <span class="number">0</span>, i);</span><br><span class="line">        res = nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>数组小和</title>
    <url>/2022/04/20/Y-LeetCode/A-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/4.%E6%95%B0%E7%BB%84%E5%B0%8F%E5%92%8C/</url>
    <content><![CDATA[<p>归并排序类型题（美团实习二面原题）</p>
<p>数组小和 定义如下：给定一个数组 s，实现 函数返回 s 的小和</p>
<p>例如： 数组s&#x3D;[1,3,5,2,4,6]</p>
<p>s[0] 左边 &lt; &#x3D; s[0]的数的和为0，</p>
<p>s[1]左边 &lt;&#x3D; s[1] 的数的和为1，</p>
<p>s[2]左边 &lt;&#x3D; s[2]的数的和为1+3&#x3D;4，</p>
<p>s[3]左边 &lt;&#x3D; s[3]的数的和为1，</p>
<p>s[4]左边 &lt;&#x3D; s[4]的数的和为1+3+2&#x3D;6，</p>
<p>s[5]左边 &lt;&#x3D; s[5]的数的和为1+3+5+2+4&#x3D;15，</p>
<p>所以s 小和为 0+1+4+1+6+15&#x3D;27 </p>
<p>In:  arr&#x3D;[1, 3, 5, 2, 4, 6]</p>
<p>Out:  27</p>
<p>要求：时间复杂度O( NlogN)，额外空间复杂度O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">smallSum2</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr==<span class="literal">null</span> || arr.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> func(arr, <span class="number">0</span>, arr.length-<span class="number">1</span>); <span class="comment">//归并排序</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">func</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//归并排序的过程会进行拆组再合并，即：拆左组，拆右组，合并左右组</span></span><br><span class="line">    <span class="keyword">return</span> func(s,l,mid) +func(s, mid+<span class="number">1</span>,r) + merge(s, l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] s, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] h = <span class="keyword">new</span> <span class="title class_">int</span>[right-left+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> hi=<span class="number">0</span>; <span class="comment">// h 的首位</span></span><br><span class="line">    <span class="type">int</span> i= left; <span class="comment">// 左组首位</span></span><br><span class="line">    <span class="type">int</span> j= mid+<span class="number">1</span>; <span class="comment">// 右组首位</span></span><br><span class="line">    <span class="type">int</span> sum= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( i&lt;=mid &amp;&amp; j&lt;=right)&#123;  </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( s[i]&lt;=s[j])&#123;</span><br><span class="line">            sum += s[i]*(right-j+<span class="number">1</span>);<span class="comment">//生成小和</span></span><br><span class="line">            h[hi++] =s[i++]; <span class="comment">//左组动</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> h[hi++]=s[j++]; <span class="comment">//右组动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>( ; (j&lt;right+<span class="number">1</span>)||(i&lt;mid+<span class="number">1</span>); j++,i++)&#123;</span><br><span class="line">        h[hi++]= i&gt;mid? s[j]:s[i]; <span class="comment">//左右组合成h</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k!=h.length; k++) s[left++]=h[k];  <span class="comment">// 合成s</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>排序</category>
      </categories>
      <tags>
        <tag>排序算法</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树路径总和-112-113-437</title>
    <url>/2022/04/22/Y-LeetCode/C-%E9%80%92%E5%BD%92/2.%E4%BA%8C%E5%8F%89%E6%A0%91%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C_112_113_437/</url>
    <content><![CDATA[<ol start="112">
<li></li>
</ol>
<p>给定一个二叉树和一个 <strong>目标和</strong>，判断该树中 <strong>是否存在 根节点到叶子节点的路径</strong>，这条路径上所有节点值 <strong>相加等于目标和</strong><br>说明: 叶子节点是指没有 子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<p>​         5</p>
<p>​        &#x2F;  \</p>
<p>​       4    8</p>
<p>​      &#x2F;    &#x2F;  \</p>
<p>​     11   13  4</p>
<p>​     &#x2F; \   \</p>
<p>​    7  2    1</p>
<p>{5,4,8,11,null, 13, 4, 7, 2, null, 1}</p>
<p>返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径  5-&gt;4-&gt;11-&gt;2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasPathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span> &amp;&amp; sum-root.val==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> hasPathSum(root.left, sum-root.val) || hasPathSum(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="113">
<li></li>
</ol>
<p>给定一个二叉树和一个目标和，找到所有从 根节点到 <strong>叶子节点路径总和 &#x3D;&#x3D;给定目标和的路径</strong><br>说明: 叶子节点是指没有子节点的节点。</p>
<p>示例:<br>给定如下二叉树，以及目标和 sum &#x3D; 22，</p>
<p>​            5<br>​         &#x2F;     <br>​        4       8<br>​       &#x2F;  \     &#x2F;  \<br>​      11   N    13   4<br>​     &#x2F; \  &#x2F; \   &#x2F;\   &#x2F;<br>​    7   2 N N  N  N 5  1</p>
<p>{5,4,8, 11, null, 13, 4, 7,2, null, null,null, null, 5,1}</p>
<p>返回:</p>
<p>[</p>
<p>  [5,4,11,2],</p>
<p>  [5,8,4,5]</p>
<p>]</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    pathSum(root, sum, item);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum, List&lt;Integer&gt; item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    item.add(root.val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="literal">null</span> &amp;&amp; root.right==<span class="literal">null</span> &amp;&amp; sum-root.val==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>(item) );  <span class="comment">// 一定要重新赋值，注意深浅copy</span></span><br><span class="line">      <span class="comment">//此处不要 return; 会导致item中末尾节点没有删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此处 不能放在 else 中，否则在 添加满足条件后，无法将最后一个元素删除： 回溯</span></span><br><span class="line">    pathSum(root.left, sum-root.val, item);</span><br><span class="line">    pathSum(root.right, sum-root.val, item);</span><br><span class="line">   item.remove(item.size()-<span class="number">1</span>);  <span class="comment">// 回溯</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>437.链接：<a href="https://leetcode-cn.com/problems/path-sum-iii">https://leetcode-cn.com/problems/path-sum-iii</a><br>二叉树的每个结点都存放着一个整数值, 找出 路径和 等于 给定数值的路径总数<br>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。</p>
<p>root &#x3D; [10,5,-3,3,2,null,11,3,-2,null,1] , sum &#x3D; 8</p>
<pre><code>         10
       /    \
     5      -3
   /  \     / \
  3    2   N   11
 / \      / \
3  -2    N   1
</code></pre>
<p>{10,5,-3,3,2,null,11,3,-2,null,1} </p>
<p>返回 3<br>和等于 8 的路径有:</p>
<ol>
<li>5 -&gt; 3</li>
<li>5 -&gt; 2 -&gt; 1</li>
<li>-3 -&gt; 11</li>
</ol>
<p>思路：<br>1.以当前节点为起始，dfs深搜遍历左右几点，找到所有sum&#x3D;target<br>2.递归遍历root.left ; root.right</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    dfs(root, sum); <span class="comment">//加入 root 节点</span></span><br><span class="line">    <span class="comment">// 不加入root 节点</span></span><br><span class="line">    pathSum(root.left, sum);</span><br><span class="line">    pathSum(root.right, sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> sum)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(sum-root.val==<span class="number">0</span>) res++;</span><br><span class="line">    dfs(root.left, sum-root.val);</span><br><span class="line">    dfs(root.right, sum-root.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式(*.)匹配_10</title>
    <url>/2022/04/23/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/1.%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D_10/</url>
    <content><![CDATA[<p>一个字符串 s和一个字符规律 p，实现一个支持 ‘.’ 和  ‘*’ 的正则表达式匹配。</p>
<p>.匹配任意 单个字符;<br>*匹配 零个或多个前面的那一个元素;  所谓匹配，是要涵盖整个字符串 s的，而不是部分字符串。<br>说明:  s 可能为空，且只包含从 a-z 的小写字母； p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *<br>s &#x3D; “aa”； p &#x3D; “a”<br>输出: false； 解释: “a” 无法匹配 “aa” 整个字符串。</p>
<p>s &#x3D; “aa”；  p &#x3D; “a*”   *<br>输出: true； 解释: 因为 ‘’可以匹配零个或多个前面的那一个元素, 这里前面元素是’a’。字符串”aa”可被视为’a’ 重复一次。</p>
<p>s &#x3D; “ab”；    p &#x3D; “.*”<br>输出: true；   解释: “.” 表示可匹配零个或多个（’’）任意字符（’.’）。</p>
<p>s &#x3D; “aab”；    p &#x3D; “c<em>a</em>b”<br>输出: true；  解释: 因为 ‘*’ 表示零个或多个，这里 ‘c’ 为 0 个, ‘a’ 被重复一次。因此可以匹配字符串 “aab”。</p>
<p>s &#x3D; “mississippi”；    p &#x3D; “mis<em>is</em>p*.”<br>输出: false</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>状态dp(i,j) 表示：  <strong>s 的前 i 个 是否 能被 p 的前 j个匹配</strong></p>
<p>已知 dp(i-1)(j-1) 意思就是前面子串都匹配上了，不知道新的一位的情况</p>
<p>1.p[j-1]  !&#x3D; ‘<em>‘:<br>    p[j-1] &#x3D;&#x3D; s[i-1] ||  p[j-1] &#x3D;&#x3D; “.” :</em>*    dp(i)(j) &#x3D; dp(i-1)(j-1)</p>
<p>2.p[j-1]  &#x3D;&#x3D; ‘<em>‘:   * 的含义是 匹配零个或多个前面的那一个元素，所以要考虑他前面的元素 p[j-1]<br>    1.前一个都不能匹配上 s[i]， * 也无能为力，只能让前一个字符消失<br>        dp(i)(j) &#x3D; dp(i)(j-2);<br>    2.p[j-2] &#x3D;&#x3D; s[i-1] or p[j-2] &#x3D;&#x3D; “.”：  *** 前面那个字符，能匹配 s[i]，或者 * 前面那个字符是万能的</em>*<br>        dp(i)(j) &#x3D; (dp(i - 1)(j) || dp(i)(j); </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">     <span class="type">int</span> l1=s.length()， l2=p.length();</span><br><span class="line">     <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">     <span class="type">char</span>[] ss = s.toCharArray();</span><br><span class="line">     <span class="type">char</span>[] pp = p.toCharArray();</span><br><span class="line">     dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 所有 pp[j-1]==‘*’ , 都可以--将前一个字母消除</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>;j&lt;=l2;j++)&#123;</span><br><span class="line">         <span class="keyword">if</span>(pp[j-<span class="number">1</span>]==<span class="string">&#x27;*&#x27;</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j-<span class="number">2</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l2; j++)&#123;</span><br><span class="line">             <span class="keyword">if</span>(pp[j-<span class="number">1</span>]!=<span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                 <span class="keyword">if</span>(pp[j-<span class="number">1</span>]==ss[i-<span class="number">1</span>] || pp[j-<span class="number">1</span>]==‘.<span class="string">&#x27; )</span></span><br><span class="line"><span class="string">                     dp[i][j] = dp[i-1][j-1];</span></span><br><span class="line"><span class="string">             &#125;else&#123;</span></span><br><span class="line"><span class="string">                 if(j&gt;1) dp[i][j] = dp[i][j-2];</span></span><br><span class="line"><span class="string">                 if(pp[j-2]==&#x27;</span>.<span class="string">&#x27; || pp[j-2]==ss[i-1])</span></span><br><span class="line"><span class="string">                     dp[i][j] = ( dp[i][j] || dp[i-1][j] ); // 前一个字符匹配的话就匹配，不匹配再看是否可以消失</span></span><br><span class="line"><span class="string">             &#125;</span></span><br><span class="line"><span class="string">         &#125;</span></span><br><span class="line"><span class="string">     &#125;</span></span><br><span class="line"><span class="string">     return dp[l1][l2];</span></span><br><span class="line"><span class="string"> &#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串中的最长回文子串_5</title>
    <url>/2022/04/25/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/10.%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2_5/</url>
    <content><![CDATA[<p>Input: “babad”<br>Output: “bab”； </p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<h4 id="思路-（动态规划）"><a href="#思路-（动态规划）" class="headerlink" title="思路:（动态规划）"></a>思路:（动态规划）</h4><p>解决这类问题的核心思想就是两个字“延伸”</p>
<p>可以用 dp(i)(j) 表示 s 中从  i 到 j（包括 i 和 j）是否可以形成回文，状态转移方程 只是将上面的描述转化为代码：</p>
<p>if ( s[i]&#x3D;&#x3D;s[j] &amp;&amp; ( dp(i+1)(j-1) || j-i&lt;3 ) </p>
<p>  dp(i)(j) &#x3D; true;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l][l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;     <span class="comment">// 从后向前</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i;j&lt;l;j++)&#123;</span><br><span class="line">            <span class="comment">// i 左； j 右</span></span><br><span class="line">            dp[i][j] = ( s.charAt(i)==s.charAt(j) ) &amp;&amp;( j-i&lt;<span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(dp[i][j] &amp;&amp; res.length()&lt;j-i+<span class="number">1</span>) res=s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>最长上升子序列_300</title>
    <url>/2022/04/25/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/11.%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97_300/</url>
    <content><![CDATA[<p>给定一个无序的整数数组，找到其中 最长上升子序列的长度</p>
<p>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是  4</p>
<p>说明:<br>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可<br>算法时间复杂度:  O(n2)</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>dp[i] 表示 到当前 i 位置时，最长的上升子序列长度</p>
<p>for（1,len)<br>    dp[i] &#x3D; max( for(j–&gt;0 ) nums[i]&gt;nums[j]) + 1<br>return max( dp[0–&gt;l] )</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int lengthOfLIS(int[] nums) &#123;</span><br><span class="line">    int l=nums.length;</span><br><span class="line">    if(l==0 || l==1) return l;</span><br><span class="line">    int[] dp=new int[l];</span><br><span class="line">    Arrays.fill(dp,1);  </span><br><span class="line">    for(int i=1;i&lt;l;i++)&#123;</span><br><span class="line">        for(int j=i;j&gt;=0;j--)&#123;</span><br><span class="line">            if(nums[i]&gt;nums[j] &amp;&amp; dp[i]&lt;dp[j]+1) </span><br><span class="line">                dp[i]=dp[j]+1;</span><br><span class="line">            res = Math.max(res, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="递归-二分："><a href="#递归-二分：" class="headerlink" title="递归 + 二分："></a>递归 + 二分：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fun2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ceil=<span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    ceil[pos] = nums[<span class="number">0</span>];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ceil[pos] &lt; nums[i]) ceil[++pos] = nums[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> l=<span class="number">0</span>,r=pos;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (ceil[m] &lt; nums[i]) l = m+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = m-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ceil[l] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包--目标和_494</title>
    <url>/2022/04/23/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/2.0-1%E8%83%8C%E5%8C%85-%E7%9B%AE%E6%A0%87%E5%92%8C_494/</url>
    <content><![CDATA[<p>给定一个非负整数数组 { a1, a2, …, an } 和一个目标数 S,  现有两个符号 + 和 - , 对于数组中的任意一个整数，可以从 + 或 - 中选择一个符号添加在前面。返回可以使最终数组和 为目标数 S 的所有 添加符号的方法数</p>
<p>输入：nums: [1, 1, 1, 1, 1],    S: 3  ； 不一定都是 1<br>输出：5<br>解释：<br>    -1+1+1+1+1 &#x3D; 3<br>    +1-1+1+1+1 &#x3D; 3<br>    +1+1-1+1+1 &#x3D; 3<br>    +1+1+1-1+1 &#x3D; 3<br>    +1+1+1+1-1 &#x3D; 3<br>一共有5种方法让最终目标和为 3</p>
<p>思路：<br>换种理解方式：就是从数组中挑出一部分数，作为正数，其余数为负，使其加和为S的所有方案<br>关键是这个选出哪些数作为正数呢？<br>设选出 正数的所有数求和 x ， 选出负数的所有数求和 y （不计符号）<br>x + y &#x3D; sum (  数组中所有元素和 )<br>x - y &#x3D; S<br>x &#x3D; (sum + S ) &#x2F; 2<br>之后此题便转化为一个 0-1背包问题； 即：装满背包容量X 的条件下，有多少种方案</p>
<p>设 dp(i)(j)表示在 数组中元素个数为 i 的条件下，背包容量为 j  的所有方案<br>第 i 个元素 有 2中可能 &#x3D; 不选 + 选<br>dp(i)(j)&#x3D;dp(i-1)(j)+dp(i-1)(j-nums[i])</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> S)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: nums) sum +=v;</span><br><span class="line">    <span class="keyword">if</span>( (sum+S)%<span class="number">2</span>!=<span class="number">0</span> ) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( S&gt;sum) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">W</span> <span class="operator">=</span> (sum+S)/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[nums.length+<span class="number">1</span>][ W+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=W;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&lt; nums[i-<span class="number">1</span>]) dp[i][j] = dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i-<span class="number">1</span>][j-nums[i-<span class="number">1</span>]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包--目标和_494</title>
    <url>/2022/04/23/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/3.0-1%E8%83%8C%E5%8C%85-%E5%88%86%E5%89%B2%E7%AD%89%E5%92%8C%E5%AD%90%E9%9B%86_416/</url>
    <content><![CDATA[<p>给定一个只包含正整数的非空数组, 是否可以将这个<strong>数组分割成两个子集，使两个子集的元素和相等</strong></p>
<p>输入: [1, 5, 11, 5]</p>
<p>输出: true</p>
<p>解释: 数组可以分割成1, 5, 11, 5 [1, 5, 5] 和 [11].</p>
<p>输入: [1, 2, 3, 5]</p>
<p>输出: false</p>
<p>解释: 数组不能分割成两个元素和相等的子集.</p>
<p>思路： 一定要是 <strong>偶数才能平分，</strong>数组元素求和sum 后， 一半作为背包称重</p>
<p><strong>转化为：</strong> 从数组中挑出一些元素，使其 求和后刚好满足背包称重</p>
<p>dp(i)(j) 表示在&#x3D;&#x3D; **遍历 **长度为 i 的数组*<em><strong>， <strong>背包容量为 j 的时刻</strong>，</strong>是否可以平分</em>*</p>
<p><strong>状态转移方程： dp(i)(j)&#x3D; ( dp(i-1)(j) || dp(i-1)(j-nums[i-1]) )</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartition</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: nums) sum+=v;</span><br><span class="line">    <span class="keyword">if</span>(sum%<span class="number">2</span>!=<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span> W=sum/<span class="number">2</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp=<span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length+<span class="number">1</span>][W+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>]=<span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;=W;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( j&lt; nums[i-<span class="number">1</span>]) dp[i][j]=dp[i-<span class="number">1</span>][j];  <span class="comment">// 小于背包重量</span></span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = ( dp[i-<span class="number">1</span>][j] || dp[i-<span class="number">1</span>][j- nums[i-<span class="number">1</span>]] );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[nums.length][W];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>01背包--目标和_494</title>
    <url>/2022/04/23/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/4.0-1%E8%83%8C%E5%8C%85%E5%AE%8C%E5%85%A8%E8%83%8C%E5%8C%85%E5%A4%9A%E9%87%8D%E8%83%8C%E5%8C%85/</url>
    <content><![CDATA[<p>*<em>0–1 背包 *</em> <strong>完全背包 \ 重复背包</strong> 一维数组时全部逆序</p>
<p><strong>0-1背包：</strong> </p>
<p>给定 n 个物体，重量为：w1，w2，……，wn，  价值为：v1，v2，……，vn</p>
<p>一个承受重量 W 的背包，问怎么选取这些物体，放在背包中（不超过背包的承重），让所取的子集达到最大价值。</p>
<p>最大价值 &#x3D; 物体 n 的价值 Vn + 背包在剩余空间（ W - Wn）下只考虑 n-1个物体所能达到的最大价值。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g0qu8ysbj20jt020dfs.jpg" alt="D442E7D1-C76F-450C-A482-6F7DB02E1A37" style="zoom:80%;" />

<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g0r9p9slj20hp011mx1.jpg" alt="C08A8DA4-7538-4CF3-A13C-5F6BF52768E1" style="zoom:80%;" />

<p>F（i, j）表示 <strong>前 i 个物体（1&lt;&#x3D; i &lt;&#x3D;n） 在背包称重为 j</strong> 时，所能达到的最大价值。</p>
<p>依次类推：只要知道物体个数为 1 时，在不同承重量的背包中所能取到的最大价值，就可依次求出物体个数为 2,3，…… , n 时背包中的所能取得的最大价值。</p>
<p><strong>初始条件****为：</strong> i &#x3D; 1： 当 0≤ j ＜w1 时，F(1,j) &#x3D; 0. 当 j ≥ w1 时，F(1,j) &#x3D; v1；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 01背包算法,二维数组实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BeiBao_01</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] v,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;  <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//第一个物体 是 第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123; <span class="comment">// j 背包的重量限制 j 时，最大的价值</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (j &gt;= w[i - <span class="number">1</span>]) &#123; <span class="comment">// 满足重量限制，可以添加 第i个物体</span></span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i-<span class="number">1</span>][j-w[i-<span class="number">1</span>]] + v[i-<span class="number">1</span>]); <span class="comment">// 衡量是否添加</span></span><br><span class="line">            &#125;<span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j]; <span class="comment">// 不满足重量限制，不添加</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0-1背包算法:  一维实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BeiBao_01_2</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] v,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> n=w.length;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[m+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=m;j&gt;=w[i-<span class="number">1</span>];j--)&#123;  <span class="comment">// 逆序：从重量限制为 j 的位置开始，判断第 i 个物体是否加入</span></span><br><span class="line">            dp[j] = Math.max( dp[j], dp[j-w[i-<span class="number">1</span>]] + v[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>用一维数组存放所有状态，也就是让该数组某个时间是第 i-1 层的状态，而过一段时间之后则成为第 i 层的状态。</p>
<p><strong>分清前后关系，****如果使用之前的数据  i-1层：（逆序）0-1背包；</strong>  </p>
<p><strong>使用</strong> <strong>之前的可能是本层的数据：顺序( 完全背包，重复背包****）</strong></p>
<p>初始状态下，一维数组 dp[] 存放的是 i &#x3D; 1 时的状态值, 使用到 i&#x3D;1层的数据，便于统一，初始化时 dp[n+1][m+1]</p>
<p>一维数组能省一些空间，但只能求最大价值。</p>
<p>当需要输出最佳方案时，常常要回溯历史信息，这时一般就只能用二维数组这种保存有各个状态值的方法了。</p>
<p>逆序：从后到前的顺序遍历，原因：</p>
<p>首先，改写 dp[ W ]的值。改写之后，原来dp[ W ]的值就由 3变为4。接着改写 dp[ W-1 ]，由于计算 i&#x3D;2 的 dp[ W-1 ] 不需要用到 i&#x3D;1 的 dp[ W ]状态，所以，dp[ W ]的改动不影响dp[ W-1 ]的计算:</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g0spqbthj20k2056wf2.jpg" alt="845E93A0-ACED-4303-8D9E-56DB72940128" style="zoom:80%;" />



<p><strong>完全背包动态规划过程：</strong></p>
<p>同种物品可以多次选取, <strong>第i种物品最多可以选取V&#x2F;C[i]件价值不变的物品</strong></p>
<p>根据 <strong>第i种物品放多少件进行决策</strong>，所以状态转移方程为</p>
<p>dp(i)(j) &#x3D; max( dp(i-1)(j-k<em>C[i]) + k</em>W[i] ),   0 &lt;&#x3D; k*C[i] &lt;&#x3D; j</p>
<p>dp(i-1)(j-K<em>C[i])+K</em>W[i] 表示前i-1种物品中选取若干件物品放入剩余空间为j-K*C[i] 的背包中所能得到的最大价值加上 k件第i种物品；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完全背包算法:  二维实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BeiBao_wanquan</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] v,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;  <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//第一个物体 是 第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> max_v=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= j/w[i - <span class="number">1</span>]; k++)</span><br><span class="line">                    max_v= Math.max(max_v, dp[i-<span class="number">1</span>][j-k*w[i-<span class="number">1</span>]]+k*v[i-<span class="number">1</span>]);</span><br><span class="line">                dp[i][j]=Math.max(max_v,dp[i-<span class="number">1</span>][j]);</span><br><span class="line">            &#125; <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全背包算法:  一维实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BeiBao_wanquan_22</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] v,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;  <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=n; i++) &#123; <span class="comment">//第一个物体 是 第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j=m; j&gt;=w[i-<span class="number">1</span>]; j--) &#123;   <span class="comment">// 逆序</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 此处无需校验 j &gt;=w[i-1] ,一定是满足的</span></span><br><span class="line">            <span class="type">int</span> tmpMax=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">1</span>; k&lt;= j/w[i-<span class="number">1</span>]; k++)</span><br><span class="line">                 tmpMax = Math.max(tmpMax, dp[j-k*w[i-<span class="number">1</span>]]+k*v[i-<span class="number">1</span>]);</span><br><span class="line">            dp[j]=Math.max(dp[j], tmpMax); <span class="comment">//(dp[j]) 为上一次的 j 重量下的最大价值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>多重背包：</strong></p>
<p>多重背包是在0-1背包的基础上，加条件：<strong>第  i 件物品有 ni 件;</strong>  所有 ni 都满足 ni ≥ W &#x2F; wi ，就变成完全背包的问题</p>
<p>对于多重背包的基本实现，与完全背包是基本一样的，不同就在于物品的个数上界不再是 v&#x2F;c[i] <strong>而是 n[i] , v&#x2F;c[i] 中较小的那个。所以要在完全背包的基本上，再考虑这个上界问题。</strong></p>
<p>完全背包是多重背包的一个特例：当n[i]都大于等于 V &#x2F; c[i] 时，多重背包就变为完全背包问题了；</p>
<p>01背包是完全背包的一个特例：当第i种物品由可以取0,1,2，…件变为只能取0,1件时（也就是从V &#x2F; c[i] + 1 种状态 变为 2种状态）完全背包就变为01背包问题。</p>
<p>三者两两之间的关系有点像集合之间的包含关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多重背包算法:  二维实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BeiBao_duochong</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] mount, <span class="type">int</span>[] v,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;   <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123; <span class="comment">//第一个物体 是 第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123; <span class="comment">// 顺序</span></span><br><span class="line">            <span class="keyword">if</span>(j&gt;=w[i-<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">maxTmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= j / w[i-<span class="number">1</span>] &amp;&amp; k &lt;= mount[i-<span class="number">1</span>]; k++)</span><br><span class="line">                    maxTmp = Math.max(maxTmp, dp[i-<span class="number">1</span>][j-k*w[i-<span class="number">1</span>]] + k*v[i-<span class="number">1</span>]);</span><br><span class="line">                dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], maxTmp);</span><br><span class="line">            &#125; <span class="keyword">else</span> dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重背包算法:  一维实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">BeiBao_duochong_2</span><span class="params">(<span class="type">int</span>[] w,<span class="type">int</span>[] mount,<span class="type">int</span>[] v,<span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> w.length;  <span class="comment">// n：物品个数</span></span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i&lt;=n; i++) &#123; <span class="comment">//第一个物体 是 第1行</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j&gt;=w[i-<span class="number">1</span>]; j--) &#123;  <span class="comment">// 逆序</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">maxTmp</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;=mount[i-<span class="number">1</span>] &amp;&amp; k*w[i-<span class="number">1</span>]&lt;=j; k++)</span><br><span class="line">                maxTmp = Math.max(maxTmp, dp[j-k*w[i-<span class="number">1</span>]] + k*v[i-<span class="number">1</span>]);</span><br><span class="line">            dp[j]= Math.max( dp[j], maxTmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>乘积最大子数组_152</title>
    <url>/2022/04/23/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/5.%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84_152/</url>
    <content><![CDATA[<p>链接：<a href="https://leetcode-cn.com/problems/maximum-product-subarray">https://leetcode-cn.com/problems/maximum-product-subarray</a></p>
<p>一个整数数组 nums ，请找出数组中 乘积最大的 <strong>连续子数组</strong>（该子数组中至少包含一个数字），并返回该 子数组所对应的乘积。</p>
<p>输入: [2, 3, -2, 4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6</p>
<p>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2,  因为 [-2,-1] 不是子数组</p>
<p>思路：<br>分 nums[i] 正负 2 种情况：<br>maxv , minv 依次更新，然后保存最大值 res </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> maxv=<span class="number">1</span>, minv=<span class="number">1</span>,res=Integer.MIN_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> maxv;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v:nums)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            tmp = Math.max(maxv * v, v);</span><br><span class="line">            minv = Math.min(minv * v, v);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            tmp = Math.max(minv * v, v); <span class="comment">//避免临时改动maxv </span></span><br><span class="line">            minv = Math.min(maxv * v, v);</span><br><span class="line">        &#125;</span><br><span class="line">        maxv = tmp;</span><br><span class="line">        res = Math.max(res, maxv);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>购买股票-最大利润</title>
    <url>/2022/04/24/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/7.%E8%B4%AD%E4%B9%B0%E8%82%A1%E7%A5%A8-%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<p>你有一次买入和卖出的机会，只有买入股票以后才能卖出, 求获得的最大收益？</p>
<p>输入：[1,4,2]  返回值：3<br>输入：[2,4,1]  返回值：2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span> <span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">     <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> minv=prices[<span class="number">0</span>];</span><br><span class="line">     <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">         <span class="comment">//记录最小值，每次都计算收益</span></span><br><span class="line">         minv = Math.min(minv, prices[i]);   </span><br><span class="line">         res = Math.max(res, prices[i]-minv);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>





<p>股票问题： <a href="https://blog.csdn.net/baichoufei90/article/details/107245328">https://blog.csdn.net/baichoufei90/article/details/107245328</a></p>
<p>购买股票的最佳时机_122</p>
<p>一个数组，第  i 个元素是第  i 天的价格，求所能获取的最大利润？（ 可以尽可能多的完成更多交易）</p>
<p>注意：不能同时参与多笔交易，必须在 再次购买前出售掉之前的股票</p>
<p>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 &#x3D; 1）的时候买入，在第 3 天（股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。</p>
<p>随后，在第 4 天（股票价格 &#x3D; 3）的时候买入，在第 5 天（股票价格 &#x3D; 6）的时候卖出, 这笔交易所能获得利润 &#x3D; 6-3 &#x3D; 3<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 &#x3D; 1）的时候买入，在第 5 天 （股票价格 &#x3D; 5）的时候卖出, 这笔交易所能获得利润 &#x3D; 5-1 &#x3D; 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出, 因为这样属于同时参与了多笔交易，必须在再次购买前出售掉之前的股票。</p>
<p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0</p>
<hr>
<p>思路：<br>dp[i] 表示在—&gt; <strong>第 i 个元素之前 所能获得的最大利润</strong><br>dp[i] &#x3D; （ i-1天时，所能获得的最大利润） + <strong>（第</strong> <strong>i-1天 时买入同时第 i 天时卖出****）</strong><br>dp[i] &#x3D; dp[i-1] + ( prices[i-1]&gt;prices[i-2]? prices[i-1]-prices[i-2]: 0)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123; </span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> prices.length;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices[i] &gt; prices[i-<span class="number">1</span>])</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + (prices[i]-prices[i-<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> dp[i] = dp[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>矩形地图中的最短路径_62/63/64</title>
    <url>/2022/04/24/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/8.%E7%9F%A9%E5%BD%A2%E5%9C%B0%E5%9B%BE%E4%B8%AD%E7%9A%84%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84_626364/</url>
    <content><![CDATA[<p>m x n 网格的左上角为起始点，机器人每次只能向下 或向右 移动一步，机器人试图达到网格的右下角。有多少条路径？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePaths</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>) dp[i][j]=dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>有障碍物的情况下，有多少条路径？<br>输入:<br>[<br>  [0,0,0],<br>  [0,1,0],<br>  [0,0,0]<br>]<br>output： 2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">uniquePathsWithObstacles</span><span class="params">(<span class="type">int</span>[][] obstacleGrid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> row=obstacleGrid.length;</span><br><span class="line">    <span class="type">int</span> col=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[row][col];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span> &amp;&amp; i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span> &amp;&amp; i==<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>) dp[i][j]=dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span> &amp;&amp; i!=<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">0</span> &amp;&amp; i!=<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>) dp[i][j]=dp[i-<span class="number">1</span>][j]+dp[i][j-<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 其余情况 dp[i][j] = 0 不需要处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[row-<span class="number">1</span>][col-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字 <strong>总和为最小</strong><br>说明：每次只能 <strong>向下 或向右</strong> 移动一步 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="type">int</span> r=grid.length, c=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span>[][] dp=<span class="keyword">new</span> <span class="title class_">int</span>[r][c];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;c;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j]=grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j!=<span class="number">0</span>) dp[i][j]= dp[i][j-<span class="number">1</span>]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j]= dp[i-<span class="number">1</span>][j]+grid[i][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]= Math.min(dp[i-<span class="number">1</span>][j] ,dp[i][j-<span class="number">1</span>]) + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[r-<span class="number">1</span>][c-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>零钱兑换_322 /518</title>
    <url>/2022/04/24/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/9.%E9%9B%B6%E9%92%B1%E5%85%91%E6%8D%A2_322518/</url>
    <content><![CDATA[<p><strong>I 所需最少的硬币数 ：</strong></p>
<p>给定不同面额的硬币 coins 和一个总金额 amount，计算可以凑成 总金额所需的 <strong>最少的硬币个数。</strong></p>
<p>如果没有任何一种硬币组合能组成总金额，返回  -1</p>
<p>输入: coins &#x3D; [1, 2, 5], amount &#x3D; 11</p>
<p>输出: 3     解释: 11 &#x3D; 5 + 5 + 1 </p>
<p>输入: coins &#x3D; [2], amount &#x3D; 3</p>
<p>输出: -1</p>
<p>说明:   可以认为每种硬币的数量是无限的</p>
<p>思路：</p>
<p>dp[i] 表示 <strong>i 面值的钱，至少需要多少个硬币</strong>（构成 i 钱的硬币数量）</p>
<p>for( 1–&gt; amount+1)<br>    for( 1 –&gt; coins)<br>        i &gt;&#x3D; coin &amp;&amp; dp[i - coin] !&#x3D; Integer.MAX_VALUE :  可以构成 i 面值的硬币，且 i-coin 的硬币也可以构            dp[i] &#x3D; min( dp[i] , dp[i-coin]+1) :  <strong>dp[i] 可能存在多种组合，依次更新，寻找最小值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">coinChange2</span><span class="params">(<span class="type">int</span>[] coins, <span class="type">int</span> amount)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[amount + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; amount + <span class="number">1</span>; i++) &#123;</span><br><span class="line">       dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> coin : coins) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= coin &amp;&amp; dp[i - coin] != Integer.MAX_VALUE)</span><br><span class="line">                dp[i] = Math.min(dp[i], dp[i-coin] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount] == Integer.MAX_VALUE？ -<span class="number">1</span>:dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给定 不同面额硬币和一个总金额，计算可以凑成 总金额的硬币组合数,  假设每一种面额的 硬币有无限个</p>
<p>输入:  amount &#x3D; 5,  coins &#x3D; [1, 2, 5]<br>输出: 4        解释: 有四种方式可以凑成总金额<br>5&#x3D;5<br>5&#x3D;2+2+1<br>5&#x3D;2+1+1+1<br>5&#x3D;1+1+1+1+1</p>
<p>输入: amount &#x3D; 3, coins &#x3D; [2]<br>输出: 0    解释: 只用面额2的硬币不能凑成总金额3</p>
<p>输入: amount &#x3D; 10, coins &#x3D; [10]<br>输出: 1</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>dp[i] 表示凑成  i 面值的钱所需要的硬币组合数<br>dp[i] &#x3D; dp[i] + dp[ i-coin ]：   i 面值的钱，是由  i-coin 面值的钱 依次组成<br>先遍历 coins： 每种组合都是在 使用之前的硬币面值 + 新硬币面值，保证不会重复</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">int</span> amount, <span class="type">int</span>[] coins)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp=<span class="keyword">new</span> <span class="title class_">int</span>[amount+<span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: coins)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;= amount; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=v) dp[i] +=dp[i-v];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[amount];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>丑数--剑指 Offer49</title>
    <url>/2022/04/24/Y-LeetCode/D-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/6.%E4%B8%91%E6%95%B0--%E5%89%91%E6%8C%87%20Offer49/</url>
    <content><![CDATA[<p>只包含 <strong>质因子  2，3 ，5</strong>  的数称作丑数，求按从小到大的顺序的第 n 个丑数。</p>
<p>输入: n &#x3D; 10<br>输出: 12<br>解释: 1, 2, 3, 4, 5, 6, 8, 9, 10, 12 是前 10 个丑数</p>
<p>思路：</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g0yt5tljj20vc0ng405.jpg" alt="DA2AD3FC-A2EE-4328-BFFD-7885935D04C4" style="zoom: 50%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">     <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">     dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>, c=<span class="number">0</span>;  <span class="comment">// 下标</span></span><br><span class="line">     </span><br><span class="line">     <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> n1=dp[a]*<span class="number">2</span>, n2=dp[b]*<span class="number">3</span>, n3=dp[c]*<span class="number">5</span>;</span><br><span class="line">       dp[i] = Math.min( Math.min( n1,n2), n3);</span><br><span class="line"></span><br><span class="line">         <span class="keyword">if</span>(dp[i]==n1) a++;</span><br><span class="line">         <span class="keyword">if</span>(dp[i]==n2) b++;</span><br><span class="line">         <span class="keyword">if</span>(dp[i]==n3) c++;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>动态规划</category>
      </categories>
      <tags>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>每日温度_739</title>
    <url>/2022/04/26/Y-LeetCode/E-%E6%A0%88/1.%E6%AF%8F%E6%97%A5%E6%B8%A9%E5%BA%A6_739/</url>
    <content><![CDATA[<p>链接：<a href="https://leetcode-cn.com/problems/daily-temperatures">https://leetcode-cn.com/problems/daily-temperatures</a></p>
<p>单调递减队列：<br>根据每日 气温 列表，重新生成一个列表， 对应位置输出为： 想观测到更高的气温，至少需要等待的天数, 如果气温在这之后都不会升高，请在该位置用 0 来代替。</p>
<p>列表： temperatures &#x3D; [73, 74, 75, 71, 69, 72, 76, 73]<br>输出：  [1, 1, 4, 2, 1, 1, 0, 0 ]</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>单调栈，维护之前的每一个记录 id，和当前值比较， <strong>cur &gt; bef ，记录等待天数</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> temperatures.length;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++)&#123;  </span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; temperatures[i] &gt;temperatures[stack.peek()])&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            res[id] = i-id; </span><br><span class="line">        &#125;</span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>至少有 K个重复字符的最长子串_395</title>
    <url>/2022/04/22/Y-LeetCode/C-%E9%80%92%E5%BD%92/1.%E8%87%B3%E5%B0%91%E6%9C%89%20K%E4%B8%AA%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2_395/</url>
    <content><![CDATA[<p>找到给定字符串（小写字符组成）中的最长子串 T ， 要求 T 中的每一字符出现次数都不少于 k , 输出 T 的长度。</p>
<p>示例 1:<br>输入: s &#x3D; “aaa bb”, k &#x3D; 3<br>输出: 3   最长子串为 “aaa” ，其中 ‘a’ 重复了 3 次。</p>
<p>示例 2:<br>输入: s &#x3D; “ababb c”, k &#x3D; 2<br>输出: 5   最长子串为 “ababb” ，其中 ‘a’ 重复了 2 次， ‘b’ 重复了 3 次。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>递归+分治</p>
<p>1.统计各个字符数量； 对于数量 &lt; k 的字符， <strong>设置为分割点</strong></p>
<p>2.遍历分割点，<strong>切分字符串，进入到递归中</strong></p>
<p>3.在递归中，依次<strong>保存最大值，最终进行返回</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span> || s.length() &lt; k) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] ch = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s.toCharArray()) ch[c-<span class="string">&#x27;a&#x27;</span>]++; <span class="comment">//记录每个字母个数</span></span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; split_id = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">//记录切分点位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( ch[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]&gt;<span class="number">0</span> &amp;&amp; ch[s.charAt(i)-<span class="string">&#x27;a&#x27;</span>]&lt;k )&#123;</span><br><span class="line">            split_id.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( split_id.size()==<span class="number">0</span>) <span class="keyword">return</span> s.length();</span><br><span class="line">    split_id.add( s.length() );  <span class="comment">//记录最后一个位置</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;split_id.size(); i++)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> longestSubstring( s.substring(l, split.get(i)), k);</span><br><span class="line">        res = Math.max(res, tmp);</span><br><span class="line">        l = split.get(i)+<span class="number">1</span>; <span class="comment">//要求下标起始位置为下一个 id+1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>递归</category>
      </categories>
      <tags>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>0～n-1中缺失的数字--剑指Offer53-II</title>
    <url>/2022/04/27/Y-LeetCode/F-%E4%BA%8C%E5%88%86/1.0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97-%E5%89%91%E6%8C%87Offer53-II/</url>
    <content><![CDATA[<p>一个长度为 n-1的 <strong>递增排序数组中的所有数字都是唯一的</strong>，并且每个数字都在范围  0～n-1 之内</p>
<p>在范围 0～n-1 内的 n个数字中 <strong>有且只有一个数字不在该数组中</strong>，请找出这个数字。</p>
<p>输入: [ 0,1,3 ]<br>输出: 2</p>
<p>输入: [ 0,1,2,3,4,5,6,7,  9 ]<br>输出: 8</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>排序数组中的搜索问题，首先想到 <strong>二分法 解决。</strong><br>根据题意，数组可以按照以下规则划分为两部分<br>左子数组： nums[i] &#x3D; i<br>右子数组： nums[i] !&#x3D; i<br>缺失的数字等于  “右子数组的首位元素” 对应的索引； 因此考虑使用 <strong>二分法查找 “右子数组的首位元素”</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>-nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m]!=m ) r=m-<span class="number">1</span> ; <span class="comment">// 不等于，在其左边</span></span><br><span class="line">        <span class="keyword">else</span> l=m+<span class="number">1</span>; <span class="comment">// 等于，在其右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>旋转数组的最小数字_剑指 Offer11</title>
    <url>/2022/04/28/Y-LeetCode/F-%E4%BA%8C%E5%88%86/2.%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97_%E5%89%91%E6%8C%87Offer11/</url>
    <content><![CDATA[<p>一个数组最开始的若干个元素搬到 数组的末尾，称之为数组的旋转。</p>
<p>NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<p>输入： 一个 非递减排序的数组的一个旋转<br>输出： <strong>旋转数组的 最小元素</strong></p>
<p>例如:</p>
<p>In:   {3,4,5, 1,2}   ,为 {1,2,3,4,5} 的一个旋转<br>Out:  1  , 该数组的 <strong>最小值为1</strong></p>
<p><strong>思路：</strong></p>
<p>每一次  nums[mid]  都和 <strong>右侧数值比较</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] numbers)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> numbers.length;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(numbers[m] &lt; numbers[r]) r=m;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(numbers[m] &gt; numbers[r]) l=m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = r-<span class="number">1</span>;  <span class="comment">// 相等时</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>在旋转有序数组中寻找指定数值：</strong></p>
<p><a href="https://www.nowcoder.com/practice/87c0e7abcbda41e7963660fa7d020995?tpId=117&amp;&amp;tqId=37744&amp;rp=1&amp;ru=/ta/job-code-high&amp;qru=/ta/job-code-high/question-ranking">https://www.nowcoder.com/practice/87c0e7abcbda41e7963660fa7d020995?tpId=117&amp;&amp;tqId=37744&amp;rp=1&amp;ru=/ta/job-code-high&amp;qru=/ta/job-code-high/question-ranking</a></p>
<p>输入：  [6,8,10,0,2,4],10<br>返回值：2</p>
<p>输入：   [6,8,10,0,2,4],3<br>返回值：  -1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span> <span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>]==target? <span class="number">0</span>:-<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=len-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] ==target) <span class="keyword">return</span> m;</span><br><span class="line">        <span class="comment">// 双层 if 分左右半段，依次判断，二分</span></span><br><span class="line">        <span class="keyword">if</span>(nums[m] &gt; nums[l])&#123;   <span class="comment">//左半部分</span></span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[m]) l=m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=m-<span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;           <span class="comment">// 右半部分</span></span><br><span class="line">            <span class="keyword">if</span>(target &gt; nums[m] &amp;&amp; target&lt;=nums[r]) l=m+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> r=m-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>在排序数组中查找数字 I--剑指 Offer 53 - I</title>
    <url>/2022/04/28/Y-LeetCode/F-%E4%BA%8C%E5%88%86/3.%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97I-%E5%89%91%E6%8C%87Offer53-I/</url>
    <content><![CDATA[<p>统计一个数字在排序数组中出现的次数</p>
<p>输入: nums &#x3D; [5,7,7,8,8,10],  target &#x3D; 8<br>输出: 2</p>
<p>输入: nums &#x3D; [5,7,7,8,8,10], target &#x3D; 6<br>输出: 0</p>
<p>思路：</p>
<p>2 次二分查找：查找数的 左右边界，做差</p>
<p>排序数组 nums 中所有数字 target 形成一个窗口，记窗口 左 &#x2F; 右边界 索引分别为 left 和 right ，分别对窗口 左边 &#x2F; 右边的首个元素</p>
<p>统计数字 target 的出现次数，可转化为：</p>
<p>二分法分别找到 <strong>左边界 left 和 右边界 right</strong> ，易得数字  <strong>target 的数量为 right - left - 1</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, r=nums.length-<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &lt;= target) l=m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> l;  <span class="comment">//右边界：此时nums[l]！=target</span></span><br><span class="line">    l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l&lt;=r)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[m] &lt; target) l = m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = m-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r;  <span class="comment">//左边界： nums[r]!=target </span></span><br><span class="line">    <span class="keyword">return</span> right - left-<span class="number">1</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
        <category>二分法</category>
      </categories>
      <tags>
        <tag>二分法</tag>
      </tags>
  </entry>
  <entry>
    <title>栈的压入、弹出序列-剑指Offer31</title>
    <url>/2022/04/26/Y-LeetCode/E-%E6%A0%88/2.%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97-%E5%89%91%E6%8C%87Offer31/</url>
    <content><![CDATA[<p>第一个序列表示 <strong>栈的压入顺序，</strong>判断第二个序列 <strong>是否为该栈的弹出顺序。</strong></p>
<p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,5,3,2,1]<br>输出：true.  解释：我们可以按以下顺序执行：</p>
<p>push(1), push(2), push(3), push(4), pop() -&gt; 4,<br>push(5), pop() -&gt; 5, pop() -&gt; 3, pop() -&gt; 2, pop() -&gt; 1</p>
<p>输入：pushed &#x3D; [1,2,3,4,5], popped &#x3D; [4,3,5,1,2]<br>输出：false   解释：1 不能在 2 之前弹出。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.先入栈<br>2.依次判断相等<br>3.取出，后移</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num: pushed)&#123;</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popped[id])&#123;</span><br><span class="line">            id++;</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>栈</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>两个链表相加_2</title>
    <url>/2022/04/28/Y-LeetCode/G-%E9%93%BE%E8%A1%A8/2.%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9B%B8%E5%8A%A0_2/</url>
    <content><![CDATA[<p>两个 非空 链表表示两个非负整数, 它们各自的位数按照 逆序 方式存储的</p>
<p>并且 <strong>每个节点只能存储 一位 数字</strong>。<br>将这两个数相加，返回一个新的链表来表示它们的和,  可以假设除数字 0 之外，这两个数都不会以 0 开头。</p>
<p>示例：（从个位 依次上升）<br>输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)<br>输出：7 -&gt; 0 -&gt; 8<br>原因：342 + 465 &#x3D; 807</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span><span class="literal">null</span>,tail =<span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">null</span> || l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">       <span class="comment">// 如果此位没有数字，用 0 代替</span></span><br><span class="line">       <span class="type">int</span> n1= l1!=<span class="literal">null</span>? l1.val:<span class="number">0</span>;  </span><br><span class="line">       <span class="type">int</span> n2= l2!=<span class="literal">null</span>? l2.val:<span class="number">0</span>;</span><br><span class="line">       <span class="type">int</span> tmp= (n1+n2+carry)%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 保存加和后的 头节点</span></span><br><span class="line">            head = tail= <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           tail.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(tmp);</span><br><span class="line">          tail = tail.next;</span><br><span class="line">        &#125;</span><br><span class="line">       carry = (n1+n2+carry)/<span class="number">10</span>; <span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">if</span>(l1!=<span class="literal">null</span>) l1=l1.next;</span><br><span class="line">        <span class="keyword">if</span>(l2!=<span class="literal">null</span>) l2=l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry!=<span class="number">0</span>)  tail.next =<span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>反转一个单链表</title>
    <url>/2022/04/28/Y-LeetCode/G-%E9%93%BE%E8%A1%A8/1.%E5%8F%8D%E8%BD%AC%E4%B8%80%E4%B8%AA%E5%8D%95%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>反转一个单链表</p>
<p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>
<p>进阶:<br>你可以迭代或递归地反转链表。你能否用两种方法解决这道 题？</p>
<p>思路：</p>
<p>一步一步的走，不要一步走多个节点</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">p</span> <span class="operator">=</span> head.next, pre=<span class="literal">null</span>;</span><br><span class="line">    head.next = <span class="literal">null</span>;  <span class="comment">//设置 终止点，防止死循环</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">null</span>)&#123;</span><br><span class="line">        pre=p.next;    <span class="comment">//保存下一个节点</span></span><br><span class="line">        p.next=head; <span class="comment">//反转</span></span><br><span class="line">        head=p;    <span class="comment">//前进</span></span><br><span class="line">        p=pre;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="递归反转链表："><a href="#递归反转链表：" class="headerlink" title="递归反转链表："></a>递归反转链表：</h4><p>直到倒数第一个节点时，开始进行反转（此时保存的是前一个节点）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(ListNode head)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span>(head.next==<span class="literal">null</span>)&#123;</span><br><span class="line">        H=head;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    fun(head.next);</span><br><span class="line">    head.next.next=head;</span><br><span class="line">    head.next = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>判断链表中是否有环--破环法_141/142</title>
    <url>/2022/04/28/Y-LeetCode/G-%E9%93%BE%E8%A1%A8/3.%E5%88%A4%E6%96%AD%E9%93%BE%E8%A1%A8%E4%B8%AD%E6%98%AF%E5%90%A6%E6%9C%89%E7%8E%AF-%E7%A0%B4%E7%8E%AF%E6%B3%95_141142/</url>
    <content><![CDATA[<p>给定一个链表，判断链表中是否有环.<br>链表中某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。<br>为了表示给定链表中的环，使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。<br>如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。<br>如果链表中存在环，则返回 true 。 否则，返回 false </p>
<p>思路：</p>
<p>定义两个指针，一快一满。慢指针每次只移动一步，而快指针每次移动两步<br>初始时，<strong>慢指针在位置 head，而快指针在位置 head.next</strong>。这样一来，如果在移动的过程中，<strong>快指针反过来追上慢指针</strong>，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    ListNode slow=head, fast=head.next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span> || fast.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>142题：</p>
<p>返回环路中的第一个节点：<br><strong>fast &#x3D;&#x3D; slow 时，</strong> <strong>继续走 fast、head</strong> <strong>,</strong> <strong>直到 fast &#x3D;&#x3D; head 时，此节点为相交节点</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span> || head.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    ListNode slow=head, fast=head.next;</span><br><span class="line">    <span class="keyword">while</span>(fast!=slow)&#123;</span><br><span class="line">        fast=fast.next;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">null</span> || fast.next==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        fast = fast.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和初始头节点，依次比较，前移</span></span><br><span class="line">    <span class="keyword">while</span> (head != slow) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        Slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>K个排序链表合并_23</title>
    <url>/2022/04/29/Y-LeetCode/G-%E9%93%BE%E8%A1%A8/4.K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6_23/</url>
    <content><![CDATA[<p>合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</p>
<p>输入:</p>
<p>[1-&gt;4-&gt;5,<br> 1-&gt;3-&gt;4,<br> 2-&gt;6]</p>
<p>输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] lists)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=lists.length;</span><br><span class="line">    <span class="keyword">if</span>(len==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> mergeK(lists, <span class="number">0</span>, len-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归，O(nlogn) 效率来合并数组中的多个链表</span></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeK</span><span class="params">(ListNode[] lists, <span class="type">int</span> l,<span class="type">int</span> r)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( l==r) <span class="keyword">return</span> lists[l];</span><br><span class="line">    <span class="keyword">if</span>( r-l==<span class="number">1</span>) <span class="keyword">return</span> mergeTwoLists(lists[l],lists[r]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l+r)/<span class="number">2</span>;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">left</span> <span class="operator">=</span> mergeK(lists, l, mid);</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">right</span> <span class="operator">=</span> mergeK(lists, mid+<span class="number">1</span>, r);</span><br><span class="line">    <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span>&#123;</span><br><span class="line">    ListNode h=<span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode p=h;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(l1!=<span class="literal">null</span> &amp;&amp; l2!=<span class="literal">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1.val&lt;l2.val)&#123;</span><br><span class="line">            p.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(l1.val);</span><br><span class="line">            l1=l1.next;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            p.next=<span class="keyword">new</span> <span class="title class_">ListNode</span>(l2.val);</span><br><span class="line">            l2=l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        p=p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    p.next = l1==<span class="literal">null</span>? l2:l1;</span><br><span class="line">    <span class="keyword">return</span> h.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>链表</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>不含重复元素的最长子串_3</title>
    <url>/2022/04/21/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/1.%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>给定一个字符串，请你找出其中 <strong>不含有重复字符的 最长子串 的长度</strong></p>
<p>输入: “abcabcbb”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p>
<p>输入: “bbbbb”</p>
<p>输出: 1</p>
<p>解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p>
<p>输入: “pwwkew”</p>
<p>输出: 3</p>
<p>解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。</p>
<p>   请注意，你的答案必须是 子串 的长度，”pwke” 是一个子序列，不是子串。</p>
<p>滑动窗口：</p>
<p><strong>保证连续，有包含关系时，从下一个 id, 开始截取</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">复杂度： n </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] ch = s.toCharArray();</span><br><span class="line">    <span class="type">int</span> l= -<span class="number">1</span>;  <span class="comment">// l边界 -1， 防止特殊情况全不相同</span></span><br><span class="line">    <span class="type">int</span> res= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123; </span><br><span class="line">        <span class="keyword">if</span>( map.containsKey(ch[r]))&#123; </span><br><span class="line">            <span class="comment">// 确保 左指针一直在向前移动， 不会遍历之前的元素</span></span><br><span class="line">            l = Math.max( l, map.get(ch[r])); </span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, r-l);</span><br><span class="line">        map.put(ch[r], r);  <span class="comment">// 值，下标</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">复杂度： n^<span class="number">2</span> </span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    List&lt;Character&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] ch=s.toCharArray();</span><br><span class="line">    <span class="type">int</span> l=-<span class="number">1</span>, res=<span class="number">0</span>;   <span class="comment">// 左下标 -1 </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123;  <span class="comment">// 右指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(l&lt;r &amp;&amp; list.contains(ch[r]))&#123; <span class="comment">//左指针</span></span><br><span class="line">            list.remove(<span class="number">0</span>);</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = Math.max(res, r-l);</span><br><span class="line">        list.add(ch[r]);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>检验字符串是否包含__567</title>
    <url>/2022/04/21/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/2.%E6%A3%80%E9%AA%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB/</url>
    <content><![CDATA[<p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列,  <strong>排列可以是任何顺序</strong></p>
<p>换句话说：第一个字符串的 <strong>排列之一</strong> 是 <strong>第二个字符串的子串，任意排列是s2 连续的*<em>子串*</em></strong></p>
<p>输入: s1 &#x3D; “ab” s2 &#x3D; “eidbaooo”</p>
<p>输出: True</p>
<p>解释: s2 包含 s1 的排列之一 ( “ba” )</p>
<p>输入: s1&#x3D; “ab” s2 &#x3D; “eidboaoo”</p>
<p>输出: False</p>
<p>注意：</p>
<p>输入的字符串只包含小写字母  </p>
<p>两个字符串的长度都在 [1, 10,000] 之间</p>
<p>优化版本：  </p>
<p>使用外加 res[26],  前–；后++</p>
<p>依次维护 res ，来和 array 比对</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 不需要每一次去比较， 依靠中间变量，删前加后</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion2</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> ll= s1.length();</span><br><span class="line">    <span class="keyword">if</span>(ll&gt; s2.length()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="type">int</span>[] ss1= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] res= <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;ll; i++)&#123;</span><br><span class="line">        ss1[s1.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">       res[s2.charAt(i)-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用 res 依次划窗来维护</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;s2.length()-ll; i++)&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span>( Arrays.equals(res, ss1)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        res[ s2.charAt(i)-‘a<span class="string">&#x27; ]--;</span></span><br><span class="line"><span class="string">        res[ s2.charAt(i+ll )-&#x27;</span>a<span class="string">&#x27;]++;</span></span><br><span class="line"><span class="string">    &#125; </span></span><br><span class="line"><span class="string">    return Arrays.equals(res,ss1);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>





<p>思路：</p>
<p><strong>无序排列的字符串，就是序列字符串，使用 Map | str[ c-‘a’] 来记录</strong></p>
<p><strong>最终判断是否为&#x3D;&#x3D;0，或 2个Map是否相等</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">checkInclusion</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">    <span class="type">int</span> [] ss=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: s1.toCharArray()) ss[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    <span class="type">int</span> sum_l=s1.length();</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] ss2=<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;s2.length()-sum_l+<span class="number">1</span> ; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(match( Arrays.copyOf(ss,ss.length), s2.substring(i,i+sum_l))) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">match</span><span class="params">(<span class="type">int</span>[] ss, String substring)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c:substring.toCharArray())&#123;</span><br><span class="line">        ss[c-<span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        <span class="keyword">if</span>(ss[c-<span class="string">&#x27;a&#x27;</span>]&lt;<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指 Offer 57 - II.和为s的连续正数序列</title>
    <url>/2022/04/21/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/3.%E5%89%91%E6%8C%87%20Offer%2057%20-%20II.%20%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>输入一个 正整数 target ，输出 <strong>所有和为 target</strong> 的 连续 **<em>*正整数序列*<em>（至少含有两个数）</em></em></p>
<p>序列内的 数字由小到大排列，不同序列按照首个数字从小到大排列</p>
<p>输入：target &#x3D; 9</p>
<p>输出：[[2,3,4],[4,5]]</p>
<p>输入：target &#x3D; 15</p>
<p>输出：[[1,2,3,4,5],[4,5,6],[7,8]]</p>
<p>思路：</p>
<p>当窗口的和 &lt; target 时:  右边界向右移动 ，增加</p>
<p>当窗口的和 &gt; target 时:  左边界向右移动 ，减少</p>
<p>当窗口的和 &#x3D;&#x3D; target 时， 记录结果</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1fypl95qcj213e0qcjuc.jpg" alt="76F3FB9B-80E0-4AA1-AEB9-0E0C15368462" width="650" height="400" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">findContinuousSequence</span><span class="params">(<span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> sum=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    List&lt; List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= target/<span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">            sum+=r;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">            sum-=l;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">           <span class="keyword">for</span>(<span class="type">int</span> k=l; k&lt;r; k++) tmp.add(k);</span><br><span class="line">           res.add(tmp);</span><br><span class="line">            <span class="comment">// 左边界继续右移，仍要继续前进</span></span><br><span class="line">            sum-=l; </span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>最小覆盖子串_76</title>
    <url>/2022/04/21/Y-LeetCode/B-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/4.%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2_76/</url>
    <content><![CDATA[<p>一个字符串 s , 一个字符串  t ， 返回 s 中 涵盖 t 所有字符的最小子串?</p>
<p>如果 s 中  不存在涵盖 t 所有字符的子串，则返回空字符串 “” </p>
<p>注意：如果 s 中存在这样的子串，保证它是唯一的答案。</p>
<p>输入：s &#x3D; “ADOBECODEBANC”,  t &#x3D; “ABC”</p>
<p>输出：”BANC”</p>
<p>输入：s &#x3D; “a”,  t &#x3D; “a”</p>
<p>输出：”a”</p>
<p>提示：</p>
<p>1 &lt;&#x3D; s.length,  t.length &lt;&#x3D; 105</p>
<p>s 和 t 由英文字母组成  </p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>左右指针，依次截取判断是否包含。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>( s.length() &lt; t.length() ) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    Map&lt;Character,Integer&gt; map_test = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Map&lt;Character,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">char</span> c: t.toCharArray()) map_test.put( c, map_test.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    String res=<span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>, len=Integer.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt; s.length(); r++)&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(r);</span><br><span class="line">         <span class="comment">// 包括的话，就添加进来</span></span><br><span class="line">        <span class="keyword">if</span>( map_test.containsKey(c)) map.put(c, map.getOrDefault(c,<span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>( l&lt;=r &amp;&amp; check(map_test, map) )&#123;</span><br><span class="line">            <span class="keyword">if</span>(len&gt; r-l+<span class="number">1</span>)&#123;</span><br><span class="line">                res= s.substring(l, r+<span class="number">1</span>);</span><br><span class="line">                len = r-l+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 内部缩减， 左指针前移</span></span><br><span class="line">            <span class="keyword">if</span>(map_test.containsKey(s.charAt(l)))</span><br><span class="line">                map.put(s.charAt(l), map.getOrDefault( s.charAt(l),<span class="number">0</span>)-<span class="number">1</span> );</span><br><span class="line">            l++;  <span class="comment">// 可以考虑使用 map&lt;v, id&gt; 优化</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(Map&lt;Character, Integer&gt; map_test, Map&lt;Character, Integer&gt; map)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>( Map.Entry&lt;Character,Integer&gt; it: map_test.entrySet())&#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">key</span> <span class="operator">=</span> it.getKey();</span><br><span class="line">        <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> it.getValue();</span><br><span class="line">        <span class="keyword">if</span>(map.getOrDefault(key, <span class="number">0</span>)&lt; value) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>滑动窗口</category>
      </categories>
      <tags>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>消息队列-基础</title>
    <url>/2021/05/07/C-%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/1.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%88MQ%EF%BC%89%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="消息队列（MQ）简介"><a href="#消息队列（MQ）简介" class="headerlink" title="消息队列（MQ）简介"></a>消息队列（MQ）简介</h1><p>生产者不断向消息队列中生产消息，消费者不断的从队列中获取消息；因为消息的生产，消费都是异步的，只关心消息的发送和接收，没有业务逻辑的侵入，这样就实现了生产者和消费者的解耦。</p>
<h3 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h3><p><strong>作用：</strong> 异步，解耦，削峰<br><strong>缺点：</strong> 可用性降低，增加系统复杂性（重复消费，消息丢失，消息的顺序消费），数据一致性问题<br><strong>1.系统可用性降低：</strong>  加个 MQ 进来，万一 MQ 挂了，整套系统崩溃<br><strong>2.系统复杂度提高：</strong>  怎么保证消息没有重复消费？怎么 处理消息丢失的情况？怎么保证消息传递的顺序性？<br><strong>3.数据一致性问题：</strong>   A 系统处理完直接返回成功，别人以为你这个请求就成功了；但问题是，如果有ABC 三个系统，AB两个系统写库成功，结果 C 系统写库失败，会导致数据不一致。</p>
<h4 id="异步："><a href="#异步：" class="headerlink" title="异步："></a><strong>异步：</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guttu3mfp8j60z00j6tao02.jpg" alt="E783098A-79FE-49FA-9879-8F75A90C4012" width="500" height="250"  />

<h4 id="解耦："><a href="#解耦：" class="headerlink" title="解耦："></a><strong>解耦：</strong></h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1guttugn5p6j60z60dy0u602.jpg" alt="00C596FF-799E-4322-B17A-30EBA35A332F" width="500" height="220"  />

<p><strong>削峰：</strong></p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gutturqacvj610g07u0tp02.jpg" alt="10A377B4-930E-4EAC-8341-7BFF82631B17" width="450" height="120"  />



<p><strong>事务一致性，分布式事务：</strong>把下单，优惠券，积分 都放在 一个事务里面，要成功一起成功，要失败一起失败</p>
<p><strong>可用性：</strong>重试机制，下游的业务发生异常，会抛出异常并且要求重新发一次</p>
<p><strong>接口幂等：</strong><br>分场景去考虑，强校验、弱校验，如跟金钱相关场景就做强校验。<br><strong>强校验：</strong>多个操作放在一个事务里，成功一起成功，失败一起失败。 每次消息过来都根据订单号+业务场景 唯一标识去流水表查，确认有没有这条流水，有就直接return； 没有则执行后面逻辑 。<br><strong>弱校验：</strong>一些不重要的场景，把 <strong>id+场景唯一标识</strong> 作为Redis的key，放到缓存里面（失效时间看场景），一定时间内的这个消息就去 Redis判断。</p>
<h3 id="消息不丢失："><a href="#消息不丢失：" class="headerlink" title="消息不丢失："></a>消息不丢失：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guttv4xvkaj60wa06m0tb02.jpg" alt="F82785B0-FC0E-4896-9ABD-8DACC736A73E" width="550" height="150"  />



<p><strong>生产消息：</strong>生产者发送消息至 Broker，需要处理 Broker的响应 ack，如果 Broker返回写入失败，需要重试发送，当多次发送失败，需要作报警，日志记录等。<br><strong>存储消息：</strong>存储消息阶段需要在 消息刷盘之后再给生产者响应，假设消息写入缓存中就返回响应，那么机器突然断电这消息就没了，而生产者以为已经发送成功了。如果Broker是集群部署，有多副本机制，即消息不仅要写入当前Broker,还需要 写入副本机中。那配置成至少写入两台机子后再给生产者响应。这样就能保证存储的可靠了。<br><strong>消费消息：</strong> 消费者执行完业务逻辑之后，再发送给 Broker消费成功ack </p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>1.生产者 需要处理好 Broker的响应，出错情况下利用 重试、报警等手段。<br>2.Broker 需要控制响应的时机，单机：消息刷盘后返回响应； 集群多副本：发送至两个副本及以上后再返回响应<br>3.消费者需要在 执行完真正的业务逻辑之后再返回响应给Broker。<br>但要注意 消息可靠性增强，性能就下降了，等待消息刷盘，多副本同步后返回都会影响性能。<br>例如日志的传输可能丢那么一两条关系不大，因此没必要等消息刷盘再响应。</p>
<h3 id="处理重复消息："><a href="#处理重复消息：" class="headerlink" title="处理重复消息："></a>处理重复消息：</h3><p>收到消息后 Broker已经写入，当时响应由于网络原因，生产者没有收到，然后生产者又重发一次，此时消息就重复了<br>解决消息重复关键点就是 幂等：在业务上处理重复消息所带来的影响。</p>
<h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h4><p>1.记录关键key，比如订单ID，假如有重复消息过来，先判断这个ID是否已经被处理过（也可以用全局唯一ID）<br>2.数据库的约束，唯一键</p>
<h3 id="有序性："><a href="#有序性：" class="headerlink" title="有序性："></a>有序性：</h3><p>保证消息有序性：全局有序，部分有序； 消费方都不要开启并行消费</p>
<h3 id="全局有序："><a href="#全局有序：" class="headerlink" title="全局有序："></a><strong>全局有序：</strong></h3><p>一个生产者，一个队列分区，一个消费者<br>保证消息的全局有序，只能由一个生产者往Topic发送消息，并且一个Topic内部只能有一个队列（分区），消费者也必须是单线程消费这个队列。这样才能全局有序！ 不过一般情况下不需要全局有序，参照局部有序的方式，生产者通过指定 partKey的方式将消息发送到某一个集群的某一个 partition，以实现消息的全局有序。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guttwa4u5xj60wi06egmq02.jpg" alt="78CA15D1-1381-498F-B6F9-0344B8D48EFD" width="550" height="150"  />



<h3 id="部分有序："><a href="#部分有序：" class="headerlink" title="部分有序："></a>部分有序：</h3><p>将 Topic 内部划分成需要的队列数，把消息通过特定的策略 发往固定的队列中，然后 每个队列对应一个单线程处理的消费者。这样即完成部分有序的需求，又可以通过 队列数量的并发 来提高消息处理效率。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guttwpnz18j60wq0didin02.jpg" alt="D791CD54-35B3-49DC-9395-7149BC0DC727" width="650" height="200"  />

<p>使用Hash取模法，让同一个订单发送到同一个队列中，同一个订单多步操作同步进行；顺序消费由消费者业务保证!!!</p>
<h3 id="处理消息堆积："><a href="#处理消息堆积：" class="headerlink" title="处理消息堆积："></a>处理消息堆积：</h3><p>1.生产者的生产速度与 消费者的消费速度不匹配<br>2.消息 消费失败反复重试<br>3.消费者 消费能力弱，时间长消息积压<br>本身消费能力较弱，优化消费逻辑，尝试批量消费，<br>逻辑已优化了但还是慢，考虑水平扩容，增加Topic的队列数和消费者数量， 队列数一定增加，不然新增加消费者是没东西消费的。<br>一个 Topic中一个队列只会分配给一个消费者。</p>
<h4 id="实现MQ的有两种主流方式：JMS，AMQP"><a href="#实现MQ的有两种主流方式：JMS，AMQP" class="headerlink" title="实现MQ的有两种主流方式：JMS，AMQP"></a>实现MQ的有两种主流方式：JMS，AMQP</h4><p><strong>两者间的区别和联系：</strong><br>1.JMS 定义了统一的接口，来对消息操作进行统一； AMQP 通过规定协议来统一数据交互的格式<br>2.JMS限定了必须使用 Java语言； AMQP只是协议，不规定实现方式，因此是跨语言的。<br>3.JMS规定了两种消息模型；而 AMQP的消息模型更加丰富</p>
<p>MQ： 消息队列<br>AMQP： 协议： 实现方式：任何语言<br>JMS： jdk标准 java 只支持两种数据模型，rocketMQ， activeMQ<br>常见MQ产品：</p>
<p>ActiveMQ：基于JMS<br>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好<br>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会<br>Kafka：分布式消息系统，高吞吐量</p>
<h3 id="Kafka、ActiveMQ、RabbitMQ、RocketMQ-区别："><a href="#Kafka、ActiveMQ、RabbitMQ、RocketMQ-区别：" class="headerlink" title="Kafka、ActiveMQ、RabbitMQ、RocketMQ 区别："></a>Kafka、ActiveMQ、RabbitMQ、RocketMQ 区别：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutty6zparj61eg0te44v02.jpg" alt="image-20210926104005380" width="750" height="450" />]]></content>
      <categories>
        <category>中间件</category>
        <category>消息队列</category>
      </categories>
      <tags>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title>先-中-后序遍历</title>
    <url>/2022/05/01/Y-LeetCode/I-%E6%A0%91/1.%E5%85%88-%E4%B8%AD-%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h3 id="先序遍历："><a href="#先序遍历：" class="headerlink" title="先序遍历："></a>先序遍历：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder1</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    res.add(root.val);       根</span><br><span class="line">    preorder1(root.left);     左</span><br><span class="line">    preorder1(root.right);    右</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">preorder2</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ; </span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);       <span class="comment">//只有中序遍历不装， 先、后序都是先装入的</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        res.add(p.val);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 栈的结构，要反序： 先右再左</span></span><br><span class="line">        <span class="keyword">if</span>(p.right!=<span class="literal">null</span>) stack.push(p.right);</span><br><span class="line">        <span class="keyword">if</span>(p.left !=<span class="literal">null</span>) stack.push(p.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="中序遍历，事先并不加入到-stack（）-中"><a href="#中序遍历，事先并不加入到-stack（）-中" class="headerlink" title="中序遍历，事先并不加入到 stack（） 中"></a><strong>中序遍历，事先并不加入到 stack（） 中</strong></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;TreeNode&gt; Res = ArrayList&lt;&gt;();</span><br><span class="line">public void inorder1(TreeNode root)&#123;</span><br><span class="line">       if(root==null) return ;</span><br><span class="line"></span><br><span class="line">       inorder1(root.left);</span><br><span class="line">       res.add(root.val);</span><br><span class="line">       inorder1(root.right);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void inorder2(TreeNode root)&#123;</span><br><span class="line">       if(root == null) return ;</span><br><span class="line"></span><br><span class="line">       Deque &lt;TreeNode&gt; stack = new LinkedList&lt;&gt;();</span><br><span class="line">      TreeNode p = root;</span><br><span class="line">       // 中序非递归： 此处没有将root入栈</span><br><span class="line">       while( !stack.isEmpty()  ||  p!=null )&#123;</span><br><span class="line">          // 把左子树压入栈中</span><br><span class="line">           while( p!=null)&#123;</span><br><span class="line">               stack.push(p);</span><br><span class="line">               p=p.left;</span><br><span class="line">           &#125;</span><br><span class="line">           p = stack.pop();</span><br><span class="line">           res.add(p.val);</span><br><span class="line">           p = p.right;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h3 id="后序遍历和先序遍历一样，-左–-gt-根–-gt-右；"><a href="#后序遍历和先序遍历一样，-左–-gt-根–-gt-右；" class="headerlink" title="后序遍历和先序遍历一样， 左–&gt;根–&gt;右；"></a><strong>后序遍历和先序遍历一样， 左–&gt;根–&gt;右；</strong></h3><p><strong>处理完后，一定要记住 反转序列</strong>  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder1</span><span class="params">( TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">    postorder1( root.left);</span><br><span class="line">    postorder1( root.right);</span><br><span class="line">    res.add( root.val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">postorder2</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( root==<span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">    Deque&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    stack.push(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!stack.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> stack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.left! =<span class="literal">null</span>) stack.push(p.left);     <span class="comment">//左 </span></span><br><span class="line">        <span class="keyword">if</span>(p.right! =<span class="literal">null</span>) stack.push(p.right);   <span class="comment">// 右</span></span><br><span class="line">        res.add( p.val);                          <span class="comment">// 根</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归一定要反转：</span></span><br><span class="line">Collections.reverse(res);</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>层次遍历</title>
    <url>/2022/05/01/Y-LeetCode/I-%E6%A0%91/2.%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    <content><![CDATA[<h4 id="层次遍历的2中方式，都是用Queue实现"><a href="#层次遍历的2中方式，都是用Queue实现" class="headerlink" title="层次遍历的2中方式，都是用Queue实现"></a>层次遍历的2中方式，都是用Queue实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 Queue实现层次遍历</span></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">cenorder1</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; que = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    que.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!que.isEmpty())&#123;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">p</span> <span class="operator">=</span> que.poll();</span><br><span class="line">        res.add(p.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(p.left!=<span class="literal">null</span>) que.offer(p.left);</span><br><span class="line">        <span class="keyword">if</span>(p.right!=<span class="literal">null</span>) que.offer(p.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 2 个 Queue 队列实现层次遍历，记录每一层的数据</span></span><br><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">cenorder2</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res= <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    Queue&lt;TreeNode&gt; cur = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">     cur.offer(root);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!cur.isEmpty())&#123;</span><br><span class="line">       List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">       Queue&lt;TreeNode&gt; next = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(TreeNode node: cur)&#123; </span><br><span class="line">            tmp.add(node.val);</span><br><span class="line">            <span class="keyword">if</span>(node.left!=<span class="literal">null</span>) next.offer(node.left);</span><br><span class="line">            <span class="keyword">if</span>(node.right!=<span class="literal">null</span>) next.offer(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.add(tmp);</span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>把二叉搜索树转换为累加树_538</title>
    <url>/2022/05/02/Y-LeetCode/I-%E6%A0%91/3.%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91_538/</url>
    <content><![CDATA[<p>1038: <a href="https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/">https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/</a> </p>
<p>给出 二叉搜索 树的根节点，该树的节点值各不相同，请将其转换为累加树，使每个节点 node 的新值等于原树中 大于或等于 node.val 的值之和<br>注意：二叉搜索树满足下列约束条件<br>1.节点左子树仅包含  键 &lt; 节点键的节点<br>2.节点的右子树仅包含   键 &gt; 节点键的节点<br>3.左右子树也必须是 二叉搜索树</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g6h2itbaj20ps0h4q3p.jpg" alt="D366D6D0-8708-4096-AB3A-55C191508394" style="zoom:50%;" />



<p>输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]<br>输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]</p>
<p>输入：root &#x3D; [0,null,1]<br>输出：[1,null,1]</p>
<p>输入：root &#x3D; [1,0,2]<br>输出：[3,3,2]</p>
<p>输入：root &#x3D; [3,2,4,1]<br>输出：[7,9,4,10]</p>
<p>思路：  反序中序遍历<br>将每个节点的值 修改为 <em><strong>*原来的节点值 +*</strong></em> <em><strong>*所有大于它的节点值之和*</strong></em><br>需要 反序中序遍历该二叉搜索树，记录过程中的节点值之和，并不断更新当前遍历到的节点值，即可得到题目要求的累加树</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反中序遍历： 右—&gt; 根 —&gt;左</span></span><br><span class="line"><span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">convertBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">      convertBST(root.right);</span><br><span class="line">        sum += root.val;</span><br><span class="line">        root.val = sum;</span><br><span class="line">      convertBST(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树的最近公共祖先-剑指Offer68-II</title>
    <url>/2022/05/02/Y-LeetCode/I-%E6%A0%91/4.%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88--%E5%89%91%E6%8C%87Offer68-II/</url>
    <content><![CDATA[<p>给定一个二叉树, 找到该树中 <strong>两个指定节点的最近公共祖先。</strong></p>
<p>例如，给定如下二叉树: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4]</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1g6j5wun7j20aa0a8dfw.jpg" alt="5033CA67-7127-4EBA-B014-56A749C94544" style="zoom:80%;" />

<p>示例 1:</p>
<p>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 1<br>输出: 3<br>解释: 节点 5 和节点 1 的最近公共祖先是节点 3。</p>
<p>示例 2:<br>输入: root &#x3D; [3,5,1,6,2,0,8,null,null,7,4], p &#x3D; 5, q &#x3D; 4<br>输出: 5<br>解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">TreeNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    dfs(root, p, q);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">lson</span> <span class="operator">=</span> dfs(root.left, p, q);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rson</span> <span class="operator">=</span> dfs(root.right, p, q);</span><br><span class="line">    <span class="keyword">if</span>((lson &amp;&amp; rson) || ( (lson || rson)&amp;&amp;(root.val==p.val || root.val==q.val) ))&#123;</span><br><span class="line">        ans = root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lson || rson || root.val==p.val || root.val==q.val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树是否包含子树_572</title>
    <url>/2022/05/02/Y-LeetCode/I-%E6%A0%91/5.%E4%BA%8C%E5%8F%89%E6%A0%91%E6%98%AF%E5%90%A6%E5%8C%85%E5%90%AB%E5%AD%90%E6%A0%91_572/</url>
    <content><![CDATA[<p>给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。<br>s 的一个子树包括 s 的一个节点和这个节点的所有子孙 s 也可以看做它自身的一棵子树。<br>给定的树 s:</p>
<p>   3</p>
<p>  &#x2F; \</p>
<p>  4  5</p>
<p> &#x2F; \</p>
<p>1  2</p>
<p>给定的树 t：</p>
<p>  4</p>
<p> &#x2F; \</p>
<p>1  2</p>
<p>返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。<br>给定的树 s：</p>
<p>   3</p>
<p>  &#x2F; \</p>
<p>  4  5</p>
<p> &#x2F; \</p>
<p>1  2</p>
<p>  &#x2F;</p>
<p>  0<br>给定的树 t：</p>
<p>  4</p>
<p> &#x2F; \</p>
<p>1   2<br>返回 false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归方式遍历：依次判断每个节点所组成的子树是否与其相等</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> &amp;&amp; t==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;     <span class="comment">// TT   </span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s==<span class="literal">null</span> || t==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// TF  FT </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(TreeNode s, TreeNode t)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s==<span class="literal">null</span> &amp;&amp; t==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;             <span class="comment">// T T</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(s!=<span class="literal">null</span> &amp;&amp; t!=<span class="literal">null</span> &amp;&amp; s.val==t.val)     <span class="comment">// F  F</span></span><br><span class="line">        <span class="keyword">return</span> isSame(s.left,t.left) &amp;&amp; isSame(s.right,t.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;                              <span class="comment">// TF FT</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>判断2棵树是否完全相等/对称_100_101</title>
    <url>/2022/05/02/Y-LeetCode/I-%E6%A0%91/6.%E5%88%A4%E6%96%AD2%E6%A3%B5%E6%A0%91%E6%98%AF%E5%90%A6%E5%AE%8C%E5%85%A8%E7%9B%B8%E7%AD%89%E5%AF%B9%E7%A7%B0_100_101/</url>
    <content><![CDATA[<p>100题：</p>
<p>给定两个二叉树，编写一个函数来检验它们是否相同。<br>如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。<br>输入:    </p>
<p>​       1     1</p>
<p>​     &#x2F; \    &#x2F; \</p>
<p>​     2  3   2  3</p>
<p>​    [1,2,3],  [1,2,3]</p>
<p>输出: true<br>输入:   </p>
<p>​      1    1</p>
<p>​     &#x2F;      \</p>
<p>​     2       2</p>
<p>​    [1,2],   [1,null,2]<br>输出: false</p>
<p>思路：<br>递归法： 实现树的遍历，过程中依次判断每个节点值是否相等<br>非递归法： 先序遍历，过程中依次判断每个节点值是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span> &amp;&amp; q!=<span class="literal">null</span> &amp;&amp; p.val==q.val)</span><br><span class="line">        <span class="keyword">return</span> isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先序遍历 2 栈保存数据，和一颗数的形式一样（过程中依次判断每个节点是否相等）--非递归方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSameTree2</span><span class="params">(TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">    Deque&lt;TreeNode&gt; s1=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    Deque&lt;TreeNode&gt; s2=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    s1.push(p);</span><br><span class="line">    s2.push(q);</span><br><span class="line">    <span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; !s2.isEmpty())&#123;</span><br><span class="line">        p=s1.pop();</span><br><span class="line">        q=s2.pop();</span><br><span class="line">        <span class="comment">// 和递归算法一样，都是 3 个 if 条件</span></span><br><span class="line">        <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span> &amp;&amp; q!=<span class="literal">null</span> &amp;&amp; p.val==q.val)&#123;</span><br><span class="line">            s1.push(p.right);</span><br><span class="line">            s2.push(q.right);</span><br><span class="line">            s1.push(p.left);</span><br><span class="line">            s2.push(q.left);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<p>101题：</p>
<p>给定一个二叉树，检查它是否是 <strong>镜像对称的</strong></p>
<p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。</p>
<p>   1</p>
<p>  &#x2F;  \</p>
<p> 2   2</p>
<p> &#x2F; \  &#x2F; \ </p>
<p>3 4 4 3</p>
<p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:</p>
<p>   1 </p>
<p>  &#x2F; \</p>
<p> 2   2</p>
<p>  \   \</p>
<p>   3   3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 递归方式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric11</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span> &amp;&amp; q!=<span class="literal">null</span> &amp;&amp; p.val==q.val)</span><br><span class="line">        <span class="keyword">return</span> isSymmetric11(p.left, q.right) &amp;&amp; isSymmetric11(p.right, q.left);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">    <span class="keyword">return</span> isSymmetric11(root.left, root.right); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归形式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric2</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="type">boolean</span> <span class="variable">r</span> <span class="operator">=</span> isSymmetric22(root.left, root.right);</span><br><span class="line">      <span class="keyword">return</span> r;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric22</span><span class="params">(TreeNode p, TreeNode q)</span>&#123;</span><br><span class="line">      Deque&lt;TreeNode&gt; s1=<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      Deque&lt;TreeNode&gt; s2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">      s1.push(p);</span><br><span class="line">      s2.push(q);</span><br><span class="line">      <span class="keyword">while</span>(!s1.isEmpty() &amp;&amp; !s2.isEmpty())&#123;</span><br><span class="line">          p=s1.pop();</span><br><span class="line">          q=s2.pop();</span><br><span class="line">          <span class="keyword">if</span>(p==<span class="literal">null</span> &amp;&amp; q==<span class="literal">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(p!=<span class="literal">null</span> &amp;&amp; q!=<span class="literal">null</span> &amp;&amp; p.val==q.val)&#123;</span><br><span class="line">             s1.push(p.left);</span><br><span class="line">             s2.push(q.right);</span><br><span class="line"></span><br><span class="line">              s1.push(p.right);</span><br><span class="line">              s2.push(q.left);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>前+中建树—中+后建树_105/106</title>
    <url>/2022/05/02/Y-LeetCode/I-%E6%A0%91/7.%E5%89%8D+%E4%B8%AD%E5%BB%BA%E6%A0%91%E2%80%94%E4%B8%AD+%E5%90%8E%E5%BB%BA%E6%A0%91_105106/</url>
    <content><![CDATA[<p>106题</p>
<p>根据一棵树的 <strong>中序遍历与 后序遍历构造二叉树</strong></p>
<p>注意:你可以假设树中没有重复的元素</p>
<p>中序遍历 inorder &#x3D; [9, 3, 15,20,7]<br>后序遍历 postorder &#x3D; [9, 15,7,20,3]<br>返回如下的二叉树：</p>
<p>   3</p>
<p>  &#x2F;  \</p>
<p> 9  20</p>
<p>​    &#x2F; \</p>
<p>   15  7</p>
<p><strong>根据特例去找一般</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(List&lt;Integer&gt; in , List&lt;Integer&gt; post)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(in.size()==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(in.size()==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(in.get(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">root_v</span> <span class="operator">=</span> post.get( post.size() - <span class="number">1</span> ) ;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root_v);</span><br><span class="line">       <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> in.indexOf(root_v);</span><br><span class="line"></span><br><span class="line">       root.left = buildTree( in.subList(<span class="number">0</span>,id), post.subList( <span class="number">0</span>, id));</span><br><span class="line">        root.right = buildTree( in.subList( id + <span class="number">1</span>, in.size()),  post.subList( id, post.size()-<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>105题：</p>
<p>根据 前序、中序来建树</p>
<p>注意:你可以假设树中没有重复的元素。</p>
<p>例如，给出</p>
<p>前序遍历 preorder &#x3D; [3, 9, 20,15,7]<br>中序遍历 inorder &#x3D; [9, 3, 15,20,7]<br>返回如下的二叉树：</p>
<p>​    3</p>
<p>   &#x2F;  \</p>
<p>   9  20</p>
<p>​       &#x2F; \</p>
<p>​      15  7</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">buildTree2</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(preorder.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">         <span class="type">int</span> <span class="variable">root_v</span> <span class="operator">=</span> preorder[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> getid(inorder, root_v);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(root_v);</span><br><span class="line">        root.left = buildTree2(Arrays.copyOfRange(preorder,<span class="number">1</span>,id+<span class="number">1</span>), Arrays.copyOfRange(inorder,<span class="number">0</span>,id) );</span><br><span class="line">        root.right = buildTree2(Arrays.copyOfRange(preorder, id+<span class="number">1</span>, preorder.length),              Arrays.copyOfRange(inorder,id+<span class="number">1</span>,inorder.length));</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">getid</span><span class="params">(<span class="type">int</span>[] inorder, <span class="type">int</span> root_v)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(inorder[i]==root_v) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>由数组\链表构建二叉搜索平衡数_108\109</title>
    <url>/2022/05/02/Y-LeetCode/I-%E6%A0%91/8.%E7%94%B1%E6%95%B0%E7%BB%84%E9%93%BE%E8%A1%A8%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%B9%B3%E8%A1%A1%E6%95%B0_108109/</url>
    <content><![CDATA[<p>将一个按照  <strong>升序排列的有序数组</strong>, 转换为 <strong>一棵高度 平衡二叉搜索树</strong>。<br>高度 平衡二叉树是指 二叉树每个节点 的左右两个子树的 高度差的绝对值不超过 1<br>给定有序数组: [ -10,-3,0,5,9 ]<br>一个可能的答案是：[ 0,-3,9,-10,null, 5 ]，它可以表示下面这个高度平衡二叉搜索树：</p>
<p>​    0<br>   &#x2F;  <br>  -3   9<br>  &#x2F;   &#x2F;<br>-10  5</p>
<p>思路：依次取中点， 作为 root &#x3D; new TreeNode( arr[id] )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedArrayToBST</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> nums.length/<span class="number">2</span>;</span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(nums[id]);</span><br><span class="line">    root.left = sortedArrayToBST( Arrays.copyOfRange(nums,<span class="number">0</span>,id) );</span><br><span class="line">    root.right = sortedArrayToBST( Arrays.copyOfRange(nums, id+<span class="number">1</span>, nums.length));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>给定一个单链表，其中的元素按 升序排序，将其转换为 高度平衡的二叉搜索树。<br>本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。</p>
<p>示例:<br>给定的有序链表： [-10, -3, 0, 5, 9],<br>一个可能的答案是：[0, -3, 9, -10, null, 5], 它可以表示下面这个高度平衡二叉搜索树：</p>
<p>​    0<br>   &#x2F; <br>  -3  9<br>  &#x2F;  &#x2F;<br>-10  5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> TreeNode <span class="title function_">sortedListToBST</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> buildTreeWithList(head,<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> TreeNode <span class="title function_">buildTreeWithList</span><span class="params">(ListNode head, ListNode tail)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(head==tail) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 找链表中点</span></span><br><span class="line">    ListNode fast=head,slow=head;</span><br><span class="line">    <span class="keyword">while</span>(fast!=tail &amp;&amp; fast.next!=tail) &#123;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(slow.val);</span><br><span class="line">    root.left = buildTreeWithList(head, slow);</span><br><span class="line">    root.right = buildTreeWithList(slow.next, tail);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>树</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数组中数字出现的次数</title>
    <url>/2022/05/03/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/1.%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<p>链接：<a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof</a></p>
<p>一个整型数组 nums 里除 两个数字之外，其他 数字都出现了两次找出 这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)</p>
<p>输入：nums &#x3D; [4,1,4,6]<br>输出：[1,6] 或 [6,1]</p>
<p>输入：nums &#x3D; [1,2,10,4,1,4,3,3]<br>输出：[2,10] 或 [10,2]</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>如果可以把所有数字分成两组，使得：<br>1.两个只出现一次的数字在不同的组中<br>2.相同的数字会被分到相同的组中<br>那么对 两个组分别进行异或操作，即可得到答案的两个数字。这是解决这个问题的关键。</p>
<p>a 和 b  写成二进制的形式：<br>xi &#x3D; ai^bi ， （^ 异或）相异为 1，相同为 0<br>ai 和 bi 的关系 &#x3D;&#x3D;&gt;  xi&#x3D;1 表示 ai 和 bi 不等;  xi &#x3D; 0 —&gt; 表示 ai 和 bi 相等</p>
<p>假如任选一个不为 0 的 xi ，按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组<br>按照第 i 位给原来的序列分组，如果该位为 0 就分到第一组，否则就分到第二组，这样就能满足以上两个条件，<br>两个 相同的数字的对应位都是相同的，所以一个被分到了某一组，另一个必然被分到这一组，所以满足了条件 2<br>这个方法在 xi&#x3D;1 的时候 a 和 b 不被分在同一组，因为 xi&#x3D;1 表示 ai 和 bi 不同，根据这个方法的定义「如果该位为 0 就分到第一组，否则就分到第二组」可以知道它们被分进了两组，所以满足了条件 1。</p>
<p>条件1:</p>
<p>ai^bi^ai  &#x3D;&#x3D;  0.&#x2F;.1<br>ai^bi^bi  &#x3D;&#x3D; 1&#x2F;.0<br>因为 ai 和 bi 互异，彼此必然有一个为 1，另一个为 0</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> v: nums)&#123;</span><br><span class="line">        x = x^v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> div=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>((div &amp; x)==<span class="number">0</span>) div= div&lt;&lt;<span class="number">1</span>; <span class="comment">// 找到2个数之间差异的那一个位置</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//此时 div 为 a^b 从右数第一个1 最低位，xi=1 表示 ai和 bi不等</span></span><br><span class="line">    <span class="type">int</span> a=<span class="number">0</span>, b=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> n: nums)&#123;</span><br><span class="line">        <span class="comment">//验证每个数字的 div位 是1/0， 1为一组； 0为一组</span></span><br><span class="line">        <span class="keyword">if</span> ((div &amp; n) != <span class="number">0</span>) &#123; </span><br><span class="line">            a = a^n;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            b = b^n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;a,b&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h3 id="数组中只出现一次的数（其它数出现k次）"><a href="#数组中只出现一次的数（其它数出现k次）" class="headerlink" title="数组中只出现一次的数（其它数出现k次）"></a><strong>数组中只出现一次的数（其它数出现k次）</strong></h3><p><a href="https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking">https://www.nowcoder.com/practice/5d3d74c3bf7f4e368e03096bb8857871?tpId=188&amp;&amp;tqId=38592&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/job-code-high-week/question-ranking</a></p>
<p>给定一个整型数组 arr和一个整数 k(k&gt;1)<br>已知 arr中只有 1 个数出现一次，其他的数都出现 k次, 请返回只出现了 1 次的数。</p>
<h5 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a><strong>示例1</strong></h5><p>输入：   [ 5,4,1,1,5,1,5],  3<br>返回值： 4</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">foundOnceNumber</span> <span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] binarySum = <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">32</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;   </span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;   <span class="comment">//记录每一位值的求和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> v : arr)&#123;  </span><br><span class="line">            sum = sum + ((v&gt;&gt;i) &amp; <span class="number">1</span>); </span><br><span class="line">        &#125; </span><br><span class="line">        binarySum[i] = sum; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( binarySum[i]%k != <span class="number">0</span> )&#123;</span><br><span class="line">            res += (<span class="number">1</span>&lt;&lt;i); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>N进制转换</title>
    <url>/2022/05/03/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/2.%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2_112/</url>
    <content><![CDATA[<p>给定一个十进制数 M ，以及需要转换的进制数 N 。将十进制数 M 转化为 N 进制数。<br>当 N 大于 10 以后， 应在结果中使用大写字母表示大于 10 的一位，如 ‘A’ 表示此位为 10 ， ‘B’ 表示此位为 11 。<br>若 M 为负数，应在结果中保留负号。<br>M是32位整数，2&lt;&#x3D;N&lt;&#x3D;16.</p>
<p>输入：  7,2<br>返回值：”111”</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(<span class="type">int</span> M, <span class="type">int</span> N)</span> &#123;</span><br><span class="line">    <span class="type">int</span> sign=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(M&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        sign = -<span class="number">1</span>;</span><br><span class="line">        M = -M;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span>(M&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> M%N;</span><br><span class="line">        <span class="keyword">if</span>(v&gt;=<span class="number">10</span>) res.append( (<span class="type">char</span>)(<span class="string">&#x27;A&#x27;</span>+v-<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">else</span> res.append(v);</span><br><span class="line">        M = M/N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> res.reverse().toString();</span><br><span class="line">    <span class="keyword">return</span> sign==<span class="number">1</span>? ans: <span class="string">&#x27;-&#x27;</span>+ ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>二为矩阵顺时针打印</title>
    <url>/2022/05/04/Y-LeetCode/H-%E6%95%B0%E8%AE%BA/3.%E4%BA%8C%E4%B8%BA%E7%9F%A9%E9%98%B5%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0/</url>
    <content><![CDATA[<p>四步：</p>
<p>1.从左到右<br>2.从上到下<br>3.从右到左<br>4.从下到上</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>row_s 行 开始， row 行 结束<br>col_s 列 开始，  col 列 结束<br>While(T)  单独判断跳出条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] spiralOrder( <span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">    <span class="keyword">if</span>(matrix.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 0, len-1;   保持后续 &lt;= , &gt;= 的统一形式</span></span><br><span class="line">    <span class="type">int</span> row_s=<span class="number">0</span>, col_s=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> matrix.length-<span class="number">1</span>, col=matrix[<span class="number">0</span>].length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[( row+<span class="number">1</span>)*(col+<span class="number">1</span>)];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="comment">// 列开始，列结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col_s; i&lt;=col; i++) res[id++] = matrix[ row_s][i];</span><br><span class="line">        row_s++; <span class="comment">// 行开始➕1</span></span><br><span class="line">        <span class="keyword">if</span>(row_s&gt; row) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 行开始，行结束</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row_s; i&lt;=row; i++) res[id++] = matrix[i][col];</span><br><span class="line">        col—-;  <span class="comment">// 列-1</span></span><br><span class="line">        <span class="keyword">if</span>(col&lt; col_s) <span class="keyword">break</span>; </span><br><span class="line">        <span class="comment">// 下+左</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=col; i&gt;=col_s; i--) res[id++] = matrix[row][i];</span><br><span class="line">        row--;</span><br><span class="line">        <span class="keyword">if</span>(row&lt; row_s) <span class="keyword">break</span>; </span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=row;i&gt;=row_s; i--) res[id++] = matrix[i][col_s];</span><br><span class="line">        col_s++;</span><br><span class="line">        <span class="keyword">if</span>(col_s&gt; col) <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>数论</category>
      </categories>
      <tags>
        <tag>数论</tag>
      </tags>
  </entry>
  <entry>
    <title>最多的盛水容器_11</title>
    <url>/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/1.%E6%9C%80%E5%A4%9A%E7%9A%84%E7%9B%9B%E6%B0%B4%E5%AE%B9%E5%99%A8_11/</url>
    <content><![CDATA[<p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。<br>在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。<br>找出其中的两条线，使得它们与 <strong>x 轴共同构成的容器可以容纳最多的水</strong></p>
<p>说明：你不能倾斜容器，且 n 的值至少为 2<br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=height.length-<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> (r-l)*Math.min(height[l],height[r]);</span><br><span class="line">    <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">       <span class="keyword">if</span>(height[l]&gt;height[r]) r—-;</span><br><span class="line">       <span class="keyword">else</span> l++；</span><br><span class="line">       res= Math.max(res, (r-l)*Math.min(height[l],height[r]) );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>跳跃游戏_45/55</title>
    <url>/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/2.%E8%B7%B3%E8%B7%83%E6%B8%B8%E6%88%8F_4555/</url>
    <content><![CDATA[<h4 id="55"><a href="#55" class="headerlink" title="55."></a>55.</h4><p>给定一个非负整数 数组，最初位于数组的第一个位置，数组中的每个元素代表在该位置可以跳跃的最大长度。<br>判断 <strong>是否能够到达最后一个位置。</strong></p>
<p>示例 1:<br>输入: [2,3,1,1,4]<br>输出: true<br>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</p>
<p>示例 2:<br>输入: [3,2,1,0,4]<br>输出: false<br>解释: 无论怎样，你总会到达索引为 3 的位置。但该位置的最大跳跃长度是 0 ， 所以你永远不可能到达最后一个位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> max_l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;nums.length; id++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(max_l&gt;=id &amp;&amp; id+nums[id] &gt; max_l ) </span><br><span class="line">            max_l = id+nums[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_l&gt;=nums.length-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="45-最少次数跳到最后位置，使用-最少的跳跃次数到达数组的最后一个位置"><a href="#45-最少次数跳到最后位置，使用-最少的跳跃次数到达数组的最后一个位置" class="headerlink" title="45.最少次数跳到最后位置，使用 最少的跳跃次数到达数组的最后一个位置"></a>45.最少次数跳到最后位置，使用 <strong>最少的跳跃次数到达数组的最后一个位置</strong></h4><p>输入: [2,3,1,1,4]<br>输出: 2<br>解释: 跳到最后一个位置的最小跳跃数是 2。<br>从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gdbxjzpdj20jo0dh75g.jpg" alt="6600092D-2F93-4F3E-91BC-C810187EEC89" style="zoom:67%;" />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span> step=<span class="number">0</span>, end=<span class="number">0</span>, max_l=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//不用考虑从最后一个位置起跳的情况，所以i &lt; nums.size()-1，而不是i &lt; nums.size()</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;nums.length-<span class="number">1</span>; id++)&#123;</span><br><span class="line"></span><br><span class="line">        max_l = Math.max(max_l, id+nums[id]);</span><br><span class="line">        <span class="keyword">if</span>(id==end)&#123;</span><br><span class="line">            end=max_l;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> step;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>找出最大连续子数组和_53</title>
    <url>/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/3.%E6%89%BE%E5%87%BA%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C_53/</url>
    <content><![CDATA[<p>一个整数数组 nums ，找到一个&#x2F;有 <strong>最大和的连续子数组</strong>（子数组最少包含一个元素），返回其最大和</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4],<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大为 6</p>
<p><strong>进阶:</strong> 如果你已经实现复杂度为 <strong>O(n) 的解法，尝试使用更为精妙的分治法求解。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max_v</span> <span class="operator">=</span> nums[<span class="number">0</span>], res=nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.length; i++)&#123;</span><br><span class="line">        max_v = Math.max( max_v+nums[i], nums[i]);</span><br><span class="line">        res = Math.max(res, max_v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>引爆气球最少箭数_452</title>
    <url>/2022/05/04/Y-LeetCode/J-%E8%B4%AA%E5%BF%83/4.%E5%BC%95%E7%88%86%E6%B0%94%E7%90%83%E6%9C%80%E5%B0%91%E7%AE%AD%E6%95%B0_452/</url>
    <content><![CDATA[<p>在二维空间中有许多球形的气球, 对于每个气球，提供的输入是水平方向上，气球直径的 <strong>开始和结束坐标</strong>。<br>开始坐标总是小于结束坐标，平面内最多存在104个气球。<br>若一个气球直径开始和结束坐标为 xstart，xend，<strong>且满足 xstart ≤ x ≤ xend，则该气球会被引爆。</strong>所需的弓箭的最小数量？   </p>
<p>输入:[[10,16],  [2,8],  [1,6],  [7,12]]<br>排序后：[1,6] [2,8] [7,12] [10,16]<br>输出:  2<br><strong>解释:</strong>  对于该样例，我们可以在x &#x3D; 6（射爆[2,8],[1,6]两个气球）和 x &#x3D; 11（射爆另外两个气球）。</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>类似于集合求相交区间</p>
<p>排序，小–&gt;大<br>right &lt; array[left], 计数加 1<br>right &#x3D; min(right, array[right])  依次向后更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(points.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Arrays.sort(points, (o1,o2)-&gt;o1[<span class="number">0</span>]-o2[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">int</span> res=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> rv=points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">1</span>;id&lt;points.length;id++)&#123;</span><br><span class="line">        <span class="type">int</span>[] tmp = points[id];</span><br><span class="line">        <span class="keyword">if</span>(rv &lt; tmp[<span class="number">0</span>])&#123;</span><br><span class="line">            res++;</span><br><span class="line">            rv = tmp[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        rv = Math.min(rv, tmp[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>贪心</category>
      </categories>
      <tags>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>3个数的和_15</title>
    <url>/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/1.3%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C_15/</url>
    <content><![CDATA[<p><strong>双指针</strong></p>
<p>一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？<br>找出所有满足条件且不重复的三元组。注意：答案中不可以包含重复的三元组。</p>
<p>nums &#x3D; [-1, 0, 1, 2, -1, -4]，<br>满足要求的三元组集合为：<br>[[-1, 0, 1],<br> [-1, -1, 2]]</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>外循环<strong>先固定一个数</strong>，在此数之后，用双指针左（i+1）右（l-1），向中间聚，依次扫描<br>枚举数组中的两个元素时，如果发现随着<strong>第一个元素的递增，第二个元素是递减的</strong>，那么就可以使用双指针的方法，<br>将枚举的时间复杂度从 O(N^2) 减少至 O(N)这是因为在枚举的过程每一步中，「左指针」会向右移动一个位置（也就是题目中的 b），而「右指针」会向左移动若干个位置，这个与数组的元素有关，但它一共会移动的位置数为 O(N)，每次也向左移动一个位置，因此时间复杂度为 O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">threeSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    List&lt; List&lt;Integer&gt; &gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;len-<span class="number">2</span>; id++)&#123;</span><br><span class="line">        <span class="comment">// 固定好 id，一个数</span></span><br><span class="line">        <span class="keyword">if</span>(nums[id]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(id&gt;<span class="number">0</span> &amp;&amp; nums[id]==nums[id-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> l=id+<span class="number">1</span>, r=len-<span class="number">1</span>;  <span class="comment">// 双指针</span></span><br><span class="line">        <span class="keyword">while</span>( l&lt;r )&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[id]+ nums[l]+  nums[r];</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">0</span>)&#123;</span><br><span class="line">                res.add( <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;( Arrays.asList(nums[id],nums[l],nums[r])) );</span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==nums[++l]);  <span class="comment">// 无论是否相等，保证 l+1 前进</span></span><br><span class="line">                <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==nums[--r]); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;<span class="number">0</span>) <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]==nums[++l]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]==nums[--r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>3个数的和_15</title>
    <url>/2022/05/05/Y-LeetCode/K-%E6%8C%87%E9%92%88/2.%E7%9B%9B%E6%B0%B4%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>给定一个整形数组arr，已知其中所有的值都是非负的，将这个数组看作一个容器，请返回容器能装多少水。<br>具体请参考样例解释<br><strong>示例1</strong><br>Input: <strong>[3,1,2,5,2,4]</strong><br>Output:  5</p>
<p>思路：</p>
<p>左右夹击， 左侧记录一个最大值，右侧记录一个最大值；<br>遇到比其lmax, rmax 小的数，+ 差值;<br>遇到比其lmax, rmax 大的数， 替换更新</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxWater</span> <span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">     <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> arr.length;</span><br><span class="line">     <span class="type">int</span> l=<span class="number">0</span>, r=len-<span class="number">1</span>;</span><br><span class="line">     <span class="type">int</span> lmax=arr[l], rmax=arr[r];</span><br><span class="line"></span><br><span class="line">     <span class="type">long</span> res=<span class="number">0</span>;</span><br><span class="line">     <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">         lmax = Math.max(lmax, arr[l]);</span><br><span class="line">         rmax = Math.max(rmax, arr[r]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(lmax &lt; rmax)&#123;</span><br><span class="line">           res +=(lmax - arr[l]);</span><br><span class="line">             l++;</span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           res +=(rmax - arr[r]);</span><br><span class="line">             r--;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> res;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>指针</category>
      </categories>
      <tags>
        <tag>指针</tag>
      </tags>
  </entry>
  <entry>
    <title>不重复的子串_3</title>
    <url>/2022/05/06/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/1.%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E4%B8%B2_3/</url>
    <content><![CDATA[<h4 id="最长不重复子串"><a href="#最长不重复子串" class="headerlink" title="最长不重复子串"></a>最长不重复子串</h4><p>Input:  “abc abcbb”<br>Output:  3</p>
<p>思路：（双指针）<br>fast 前， slow 后, 保证此区间内不重复，用Map（） 走过的记录字符<br>保存临时子串 ： tmp_l，依次判断 s[fast] 是否在 tmp_l 中 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> len=s.length();</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,l=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(len&lt;<span class="number">2</span>) <span class="keyword">return</span> len;</span><br><span class="line">    Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> r=<span class="number">0</span>; r&lt;len; r++)&#123;</span><br><span class="line">        <span class="keyword">if</span>( l&lt;r &amp;&amp; map.containsKey(s.charAt(r)))</span><br><span class="line">            <span class="comment">// aabaab!bb , 在 slow=4, a 时,map.get(b)+1 = 3, 会出现更小的数值，此处可以保证 slow 一直向前走</span></span><br><span class="line">            l= Math.max( l, map.get(s.charAt(r))+<span class="number">1</span> );</span><br><span class="line"></span><br><span class="line">        map.put(s.charAt(r), r);</span><br><span class="line">        res= Math.max(res, r-l+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>重复子串_459</title>
    <url>/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/2.%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2_459/</url>
    <content><![CDATA[<p>非空的字符串，判断它是否可以由它的一个 <strong>子串重复多次构成,</strong>  字符串只含小写英文字母，并且长度不超过10000</p>
<p>输入: “abab”<br>输出: True<br>解释: 可由子字符串 “ab” 重复两次构成。</p>
<p>输入: “aba”<br>输出: False</p>
<p>输入: “abc abc abc abc”<br>输出: True<br>解释: 可由子字符串 “abc” 重复四次构成，(或者子字符串 “abcabc” 重复两次构成。)</p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>for (1 ~ len(s)&#x2F;2)  所有 子字符串（从index&#x3D;0开始取）<br>所取 <strong>子字符串 * 切片数  len(s) &#x2F;&#x2F; i ,</strong> 得到的字符串若和 原字符串相等，则返回 True<br>判断 2个str的值相等:   str1.equals(str2)<br>地址相等： str1&#x3D;&#x3D;str2</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">method</span><span class="params">(String s)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=s.length()/<span class="number">2</span> ; i&gt;<span class="number">0</span>; i—)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> s.length()/i;    <span class="comment">//切片的数量</span></span><br><span class="line">        <span class="keyword">if</span>(s.length()%i == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">StringBuilder</span> <span class="variable">tmp_s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">            <span class="comment">// 拼接形成 new 字符串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt; k; j++) tmp_s.append( s.substring(<span class="number">0</span>,i));</span><br><span class="line">            <span class="keyword">if</span>( String.valueOf(tmp_s).equals(s) ) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最大回文子串-回文子序列</title>
    <url>/2022/05/07/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/3.%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2-%E5%9B%9E%E6%96%87%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p><strong>回文子串： boolean(len)(len) dp  ;   回文序列：  int(len)(len) dp</strong></p>
<p>回文：</p>
<p>for(int i&#x3D;len-1; i&gt;&#x3D;0; i–){</p>
<p>  for(int j&#x3D;i; j&lt;len; j++){</p>
<p>字符串中最长的回文子串：</p>
<p>Input: “babad”<br>Output: “bab”&#x2F; “aba” </p>
<p>Input: “cbbd”<br>Output: “bb”</p>
<h4 id="思路：（动态规划）"><a href="#思路：（动态规划）" class="headerlink" title="思路：（动态规划）"></a>思路：（动态规划）</h4><p>核心思想就是两个字“延伸”</p>
<p>在一个 <strong>不是回文字符串的字符串两端添加任何字符，或者在回文串左右分别加不同的字符，得到的一定不是回文串</strong></p>
<p>dp(i)(j):  表示 <strong>从 i 到 j 是否可以形成回文</strong><br>dp(i)(j)&#x3D; ( s.charAt(i)&#x3D;&#x3D;s.charAt(j) ) &amp;&amp; (j-i&lt;3 || dp(i+1)(j-1) );</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">String</span> <span class="variable">res</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[l][l];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=l-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i; j&lt;l; j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i)==s.charAt(j)) dp[i][j] = (j-i&lt;<span class="number">3</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]) ;</span><br><span class="line">            <span class="keyword">if</span>( dp[i][j] &amp;&amp; res.length()&lt;j-i+<span class="number">1</span> ) res=s.substring(i,j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>字符串 s ，找到其中<strong>最长的回文子序列，并返回该序列的长度。</strong></p>
<p>输入:  “bbbab”<br>输出:  4  ；一个可能的最长回文子序列为 “bbbb”</p>
<p>输入:  “cbbd”<br>输出:  2  ；一个可能的 最长回文子序列为 “bb”</p>
<h4 id="思路：DP"><a href="#思路：DP" class="headerlink" title="思路：DP"></a>思路：DP</h4><p>dp(i)(j): i 左 j 右， <strong>从 s[i] – s[j] 此字符串内， 最长的回文子序列</strong></p>
<p>if s[i] &#x3D;&#x3D; s[j] :  dp(i)(j) &#x3D; dp(i+1)(j-1) + 2;<br>else dp(i)(j) &#x3D; max( dp(i+1)(j), dp(i)(j-1) )</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(s == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[ len ][ len ];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;len; i++) dp[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 从下往上遍历</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>; j&lt;len; j++)&#123;</span><br><span class="line">            <span class="comment">// 那么就说明在原先的基础上又增加了回文子序列的长度</span></span><br><span class="line">            <span class="keyword">if</span>( s.charAt(i) == s.charAt(j))&#123;</span><br><span class="line">                dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 表明这时 dp[i][j]只需取两者之间的 最大值即可</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i+<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][len-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>字符串相加</title>
    <url>/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/4.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%8A%A0/</url>
    <content><![CDATA[<h4 id="字符串形式实现数字相加"><a href="#字符串形式实现数字相加" class="headerlink" title="字符串形式实现数字相加"></a>字符串形式实现数字相加</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">solve</span> <span class="params">(String s, String t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> carry=<span class="number">0</span>;  <span class="comment">//进位</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">char</span>[] chs=s.toCharArray(), cht=t.toCharArray();</span><br><span class="line">    <span class="type">int</span> l1=s.length(), l2=t.length();</span><br><span class="line">    <span class="type">int</span> i=l1-<span class="number">1</span>, j=l2-<span class="number">1</span>; </span><br><span class="line">    <span class="keyword">for</span>(; i&gt;=<span class="number">0</span> &amp;&amp; j&gt;=<span class="number">0</span>; i--,j--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + chs[i]-<span class="string">&#x27;0&#x27;</span> + cht[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + chs[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(;j&gt;=<span class="number">0</span>;j--)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> carry + cht[j]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        carry = tmp/<span class="number">10</span>;</span><br><span class="line">        res.append(tmp%<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(carry==<span class="number">1</span>) res.append(carry); <span class="comment">//记录最后进位值</span></span><br><span class="line">    <span class="keyword">return</span> res.reverse().toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最长递增子序列</title>
    <url>/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/5.%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>寻找一个字符串中的 <strong>最长递增子序列</strong></p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>1.对 <strong>字符串按字母排序</strong><br>2.排序后的字符串，和 原字符串的 *<strong>*最长公共子*</strong>*序列****，即为所求的 <strong>字符串中最长递增子序列</strong></p>
<p>In:  bacdgat;  aabcdgt<br>Out:  acdgt</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">    <span class="type">int</span>[] nums_i = Arrays.copyOf(nums, nums.length);</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    <span class="type">int</span> l=nums.length;</span><br><span class="line">    <span class="type">int</span>[][] dp= <span class="keyword">new</span> <span class="title class_">int</span>[l+<span class="number">1</span>][l+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>( nums_i[i-<span class="number">1</span>]==nums[j-<span class="number">1</span>] ) dp[i][j] =dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = Math.max(dp[i-<span class="number">1</span>][j], dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l][l];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>最长公共子串-公共子序列</title>
    <url>/2022/05/08/Y-LeetCode/L-%E5%AD%97%E7%AC%A6%E4%B8%B2/6.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<p>最长公共子串：字串要保证连续</p>
<p>s1[i] ，s2[j] 表示以 s1 以下标 i 结尾， s2 以下标 j 结尾<br>dp(i)(j) 表示分别以s1[i], s2[j] 结尾的 公共子串的长度<br>dp(0)(j)&#x3D;0, dp(i)(0) &#x3D;0;</p>
<p>1.s1[i-1]!&#x3D;s2[j-1]    dp(i)(j)&#x3D; 0     当前位置不等，子串要连续，则此位置&#x3D;&#x3D;0<br>2.s1[i-1]&#x3D;&#x3D;s2[j-1]   dp(i)(j)&#x3D;dp(i-1)(j-1)+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求 2 个字符串中的最长公共子串</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">longestCommonSubstring</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1=s1.length(),l2=s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> max_v=<span class="number">0</span>, start_id=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=l2;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>( s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>))&#123;</span><br><span class="line">                dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(max_v&lt;dp[i][j])&#123;</span><br><span class="line">                    max_v=dp[i][j];</span><br><span class="line">                    start_id=i-max_v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s1.substring(start_id,start_id+max_v);</span><br></pre></td></tr></table></figure>





<h4 id="求最长公共子序列：可以不是连续的"><a href="#求最长公共子序列：可以不是连续的" class="headerlink" title="求最长公共子序列：可以不是连续的"></a><strong>求最长公共子序列：可以不是连续的</strong></h4><p>1.s1[i-1]!&#x3D;s2[j-1]  dp(i)(j) &#x3D; Math.max(dp(i-1)(j) , dp(i)(j-1) ) 当前位置不等，依次 -1 看 <strong>其他子序列是否相等，取最大</strong> </p>
<p>2.s1[i-1]&#x3D;&#x3D;s2[j-1]  dp(i)(j)&#x3D;dp(i-1)(j-1)+1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 求 2 个字符串中的最长公共子序列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestCommonLxlie</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">    <span class="type">int</span> l1=s1.length(), l2=s2.length();</span><br><span class="line">    <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l1+<span class="number">1</span>][l2+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max_v=<span class="number">0</span>, start_id=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=l1;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=l2;j++)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(s1.charAt(i-<span class="number">1</span>)==s2.charAt(j-<span class="number">1</span>)) dp[i][j]=dp[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> dp[i][j]= Math.max(dp[i-<span class="number">1</span>][j],dp[i][j-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l1][l2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>字符串</category>
      </categories>
      <tags>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>全排列_46/47</title>
    <url>/2022/05/09/Y-LeetCode/M-DFS/1.%E5%85%A8%E6%8E%92%E5%88%97_4647/</url>
    <content><![CDATA[<p>给定一个 **<em>*没有重复 数字*<em>的序列，返回其所有可能的全排列。</em></em></p>
<p>输入: [1,2,3]<br>输出:</p>
<p>[[1,2,3],<br> [1,3,2],<br> [2,1,3],<br> [2,3,1],<br> [3,1,2],<br> [3,2,1] ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private List&lt;List&lt;Integer&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;</span><br><span class="line">    int l=nums.length;</span><br><span class="line">    if(l==0) return new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;lists=new ArrayList&lt;&gt;();</span><br><span class="line">    for(int v:nums) lists.add(v);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; item=new ArrayList&lt;&gt;();</span><br><span class="line">    DFS(lists, item);</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>47</p>
<p>给定一个 <strong><em>*可包含重复数字的序列 nums*</em> ，按任意顺序 返回所有不重复的全排列。</strong></p>
<p>输入：nums &#x3D; [1,1,2]<br>输出：<br>[[1,1,2],<br>[1,2,1],<br>[2,1,1]]</p>
<p>输入：nums &#x3D; [1,2,3]<br>输出：[ [1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1] ]</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Set&lt;List&lt;Integer&gt;&gt; res=new HashSet&lt;&gt;();</span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; permuteUnique(int[] nums) &#123;</span><br><span class="line">    if(nums.length==0) return new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt;lists = new ArrayList&lt;&gt;();</span><br><span class="line">    for(int v:nums) lists.add(v);</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt;item = new ArrayList&lt;&gt;();</span><br><span class="line">    DFS2(lists, item);</span><br><span class="line">    return new ArrayList&lt;&gt;(res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void DFS2(List&lt;Integer&gt; lists, List&lt;Integer&gt; item) &#123;</span><br><span class="line">    if(lists.size()==0)&#123;</span><br><span class="line">        res.add(new ArrayList&lt;&gt;(item));</span><br><span class="line">        return ;</span><br><span class="line">    &#125;</span><br><span class="line">    for(int id=0;id&lt;lists.size();id++)&#123;</span><br><span class="line">        int v=lists.get(id);</span><br><span class="line">        lists.remove(id);</span><br><span class="line">        item.add(v);</span><br><span class="line"></span><br><span class="line">        DFS2(lists, item);</span><br><span class="line"></span><br><span class="line">        lists.add(id,v);</span><br><span class="line">        item.remove(item.size()-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>岛屿数量</title>
    <url>/2022/05/09/Y-LeetCode/M-DFS/2.%E5%B2%9B%E5%B1%BF%E6%95%B0%E9%87%8F/</url>
    <content><![CDATA[<p>输入：<br>[[1,1,0,0,0],<br>[0,1,0,1,1],<br>[0,0,0,1,1],<br>[0,0,0,0,0],<br>[0,0,1,1,1] ]</p>
<p>返回值：3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">solve</span> <span class="params">(<span class="type">char</span>[][] grid)</span> &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> grid.length, col=grid[<span class="number">0</span>].length;</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;row; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;col; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j]==<span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                dfs(grid, i, j);</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=grid.length || j&lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].length || grid[i][j]==<span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> ;</span><br><span class="line">    </span><br><span class="line">    grid[i][j]=<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    dfs(grid, i-<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i+<span class="number">1</span>, j);</span><br><span class="line">    dfs(grid, i, j-<span class="number">1</span>);</span><br><span class="line">    dfs(grid, i, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>整数二进制拆解-Pow50</title>
    <url>/2022/05/09/Y-LeetCode/M-DFS/3.%E6%95%B4%E6%95%B0%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8B%86%E8%A7%A3-Pow50/</url>
    <content><![CDATA[<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p>输入: 2.00000, 10<br>输出: 1024.00000</p>
<p>输入: 2.10000, 3<br>输出: 9.26100</p>
<p>输入: 2.00000, -2<br>输出: 0.25000</p>
<p>解释: 2-2 &#x3D; 1&#x2F;22 &#x3D; 1&#x2F;4 &#x3D; 0.25<br>说明:<br>-100.0 &lt;  x  &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−2^31, 2^31 − 1] </p>
<h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>把指数 n n 做「二进制分解」，在底数不断自身乘以自身的过程中，将最终结果需要的部分保存下来</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1gegtwt4tj20hq05tt91.jpg" alt="FA5A6E3C-3205-45CD-B1F3-01A343C29506"  />



<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">N</span> <span class="operator">=</span> n;</span><br><span class="line">    <span class="keyword">return</span> N &gt;= <span class="number">0</span>? fun2(x,N) : <span class="number">1.</span>/fun2(x,-N);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">double</span> <span class="title function_">fun</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">if</span>(n%<span class="number">2</span>==<span class="number">0</span>) <span class="keyword">return</span> fun(x*x, n/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> x*fun(x*x, n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--------------------------------------</span><br><span class="line">    <span class="comment">// 非递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">m</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">if</span>(m &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            x = <span class="number">1.</span>/x;</span><br><span class="line">            m = -m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.</span>;</span><br><span class="line">        <span class="keyword">while</span>(m&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m%<span class="number">2</span>==<span class="number">1</span>) res *= x;  <span class="comment">//碰到1，res扩展</span></span><br><span class="line">            m = m/<span class="number">2</span>;</span><br><span class="line">            x *= x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>DFS版0-1背包问题</title>
    <url>/2022/05/10/Y-LeetCode/M-DFS/4.0-1%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> 链接：<a href="https://ac.nowcoder.com/acm/problem/207796">https://ac.nowcoder.com/acm/problem/207796</a><br> 有 n个物品，每个物品有一个体积  v[i] ，重量  g[i], 选择其中总体积恰好为 V的若干个物品，最大总重量为多少？<br>（如果不存在合法方案，返回-1）</p>
<p>输入： v &#x3D; [1,2,3]； g &#x3D; [2,3,4]； V &#x3D; 3<br>输出： 5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Maximumweight</span> <span class="params">(<span class="type">int</span>[] v, <span class="type">int</span>[] g, <span class="type">int</span> V)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> DFS(V, v, g, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">DFS</span><span class="params">(<span class="type">int</span> V, <span class="type">int</span>[] v, <span class="type">int</span>[] g, <span class="type">int</span> id, <span class="type">int</span> item)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(V==<span class="number">0</span>) <span class="keyword">return</span> item;</span><br><span class="line">    <span class="keyword">if</span>(V&lt;<span class="number">0</span> || id==v.length) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> DFS(V,   v, g, id+<span class="number">1</span>, item);     <span class="comment">// id 物品不要</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> DFS(V-v[id],   v, g, id+<span class="number">1</span>, item+g[id]); <span class="comment">// id 物品要</span></span><br><span class="line">    <span class="keyword">return</span> Math.max(r1, r2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>LeetCode</category>
        <category>DFS</category>
      </categories>
      <tags>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/04/20/Y-LeetCode/M-DFS/A-DFS%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 标准的 DFS 深搜模板</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">DFS</span><span class="params">(List&lt;Integer&gt; lists, List&lt;Integer&gt; item)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(lists.size()==<span class="number">0</span>)&#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(item));</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> id=<span class="number">0</span>; id&lt;lists.size(); id++)&#123;</span><br><span class="line">        <span class="type">int</span> v=lists.get(id);</span><br><span class="line">        lists.remove(id);</span><br><span class="line">        item.add(v);</span><br><span class="line"></span><br><span class="line">        DFS(lists, item);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回溯</span></span><br><span class="line">        lists.add(id,v);</span><br><span class="line">        item.remove(item.size()-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>Mysql:原理-优化</title>
    <url>/2022/03/09/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A2-%E5%8E%9F%E7%90%86-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="工作原理-优化"><a href="#工作原理-优化" class="headerlink" title="工作原理-优化"></a>工作原理-优化</h1><h3 id="mysql-执行过程："><a href="#mysql-执行过程：" class="headerlink" title="mysql 执行过程："></a>mysql 执行过程：</h3><p>客户端 —&gt;连接器 —&gt;缓存—&gt;分析器 —&gt;优化器—&gt;执行器 —&gt;引擎 —&gt; 查询结果<br>客户端 —&gt;连接器 —&gt;缓存—&gt; 查询结果  </p>
<p>调优是在执行器执行之前的分析器，优化器阶段完成</p>
<h3 id="主从复制同步原理："><a href="#主从复制同步原理：" class="headerlink" title="主从复制同步原理："></a>主从复制同步原理：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwuc4hfij60h307zaab02.jpg" alt="216B1176-D897-40A4-BED9-E0784E96CFE8" width="650" height="250"   />

<p>1.从库启动复制时，首先创建  I&#x2F;O 线程连接主库，主库随后创建 Binlog 线程将主库上的改变记录到二进制日志中<br>2.从库通过  I&#x2F;O 线程，将主库的 二进制日志文件 copy 到 从库的中继日志 Relay Log<br>3.从库上的 SQL线程 读取中继日志 Relay Log，重做 中继日志中的事件，将数据的改变更新到自己的数据库中</p>
<ul>
<li><p><strong>异步复制：</strong>主库执行完提交的事务后，会立即将结果返给给客户端，并不关心从库是否已经接收并处理，如果主 crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。</p>
</li>
<li><p><strong>全同步复制：</strong>指当主库执行 完一个事务，所有的从库都执行该事务后，主库才返回给客户端。需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。</p>
</li>
<li><p><strong>半同步复制：</strong>主库执行完客户端提交的事务后 不是立刻返回给客户端，而是等待 至少一个从库接收到并写到 relay log中才返回给客户端。半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP&#x2F;IP往返的时间。所以，半同步复制最好在低延时的网络中使用。</p>
</li>
</ul>
<h3 id="MySQL-数据一致性："><a href="#MySQL-数据一致性：" class="headerlink" title="MySQL 数据一致性："></a>MySQL 数据一致性：</h3><p>1.半同步，从库 ack 确认机制<br>2.缓存， 先写缓存再入主库，读从时先读缓存</p>
<h4 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a><strong>读写分离</strong></h4><p>主服务器：写 +  读 （实时性要求高）<br>从服务器：读 </p>
<h4 id="读写-分离能提高性能的原因在于："><a href="#读写-分离能提高性能的原因在于：" class="headerlink" title="读写 分离能提高性能的原因在于："></a><strong>读写 分离能提高性能的原因在于：</strong></h4><p>1.主从服务器负责各自的读和写，极大程度缓解了锁的争用</p>
<p>2.从服务器可以使用 MyISAM，提升查询性能以及节约系统开销</p>
<p>3.增加冗余，提高可用性</p>
<p>读写分离常用代理方式来实现： 代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwumox9hj60x20q4gne02.jpg" alt="DD2CC108-950E-4E49-B982-E984E6AD8076" width="650" height="450"   />

<h3 id="explain-分析-select查询语句的参数："><a href="#explain-分析-select查询语句的参数：" class="headerlink" title="explain 分析 select查询语句的参数："></a>explain 分析 select查询语句的参数：</h3><p>select_type：常用的有 SIMPLE 简单查询，UNION 联合查询，SUBQUERY子查询等<br>Table：要查询的表<br>possible_keys：可选择的索引<br>key： 实际使用的索引<br>rows： 扫描的行数<br>type：索引查询类型，经常用到的索引查询类型：<br>    **const：使用 主键或 唯一索引 进行查询的时候只有一行匹配<br>    **ref： 使用 非唯一索引<br>    **range：使用 主键、单个字段的辅助索引、多个字段的辅助索引的最后一个字段进行范围查询<br>    **index： 和 all的区别是 只扫描索引树  1.查询字段是索引的一部分，覆盖索引;  2.使用主键进行排序<br>    **all：扫描全表<br>system：触发条件：表只有一行，这是一个 const type 的特殊情况</p>
<h3 id="查询优化："><a href="#查询优化：" class="headerlink" title="查询优化："></a>查询优化：</h3><p>1.只返回必要的列，行： 最好不要使用 SELECT*语句； 使用  LIMIT语句来限制返回的数据；只有一条数据 limit 1<br>2.多使用普通索引,  背景：写多读少，对唯一性要求不高，或业务代码来保证唯一性时<br>  普通索引使用 change buffer ，可以把一些写操作缓存下来，在读取的时候进行，避免磁盘操作，提高效率<br>3.注意：String字段，但 DB中是int ,用到隐式转换 cast(str) 函数转换，导致不走索引<br>  碰到不走索引情况，可以考虑使用 force index，强制走索引；<br>4.建立联合索引：出现频率较高，常在一起作为 where条件的字段，考虑建立联合索引，减少建立索引的数量；并借助索引下推减少回表；<br>  减少服务器端扫描的行数, 使用索引来覆盖查询。对于业务中有一些不好的索引，考虑使用覆盖索引(最左匹配原则)，把设置错误的索引给覆盖掉</p>
<p>5.开启MRR（mult-range Read）：此操作可以在 回表之前，进行一个排序，把原来一个随机操作变成一个顺序操作<br>原理：根据辅助索引的叶子结点，找到主键值的集合并存储到read_rnd_buffer中，在该buffer中对主键值进行排序，最后利用已经排序好的主键值的集合，去访问表中的数据，这样就由原来的 随机&#x2F;O变成为 顺序I&#x2F;O，降低查询过程中的I&#x2F;O消耗。</p>
<h4 id="6-分解大连接查询："><a href="#6-分解大连接查询：" class="headerlink" title="6.分解大连接查询："></a>6.分解大连接查询：</h4><p>将一个大连接查询分解成 对每一个表进行一次单表查询，然后在 应用程序中进行关联，这样做的好处有：<br>1.让缓存更高效；对于连接查询，如果一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用<br>2.分解成多个单表查询；这些单表查询的缓存结果 更可能被其它查询使用到，从而减少冗余记录的查询。<br>3.减少锁竞争；在应用层进行连接，更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。查询本身效率也可能会有所提升。</p>
<h4 id="7-分页查询优化："><a href="#7-分页查询优化：" class="headerlink" title="7.分页查询优化："></a>7.分页查询优化：</h4><p>1.控制返回的总页数；<br>2.对超过特定 阈值的页数进行 SQL 改写，借助主键 id 的索引覆盖<br>SELECT a.* FROM USER a  INNER JOIN  (SELECT id  FROM USER WHERE age &#x3D; 10 LIMIT 100000,10) b  ON a.id &#x3D; b.id;  结果0.53s<br>需要对 where条件增加索引，id 因为是主键自带索引，select返回减少回表可以提升查询性能, 所以采用查询主键字段后进行关联大幅度提升了查询效率。<br>3.使用Redis 来保存lastMaxtId, 下一次分页查询时直接拼接在 where 条件后边，直接跨过 offset 行数据。</p>
<h4 id="8-很长的字段如何设置索引："><a href="#8-很长的字段如何设置索引：" class="headerlink" title="8.很长的字段如何设置索引："></a>8.很长的字段如何设置索引：</h4><p>索引选取越长，占用磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。<br>1.短长度：把字段 hash为另外一个字段存起来，每次校验 hash就好了，hash的索引也不大，hash 后的数值要 区分度过高。<br>2.高区分：通过函数处理倒序，删减字符串减少字段长度，并增加区分度； 如：身份证区域开头，同区域人很多，REVERSE() 函数翻转一下，提高区分度。</p>
<h3 id="MySQL-工作原理："><a href="#MySQL-工作原理：" class="headerlink" title="MySQL 工作原理："></a>MySQL 工作原理：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwvhdqzkj60j20eq76s02.jpg" alt="EE963375-2D0A-44B3-A209-211FEFFB0A07" width="650" height="450"   />

<h3 id="Buffer-Pool"><a href="#Buffer-Pool" class="headerlink" title="Buffer Pool"></a>Buffer Pool</h3><p>MySQL 不会直接去修改磁盘的数据，因为这样做太慢了，MySQL 会先记录 redo log，再改内存 Buffer Pool ，等有空了再刷磁盘，如果内存 Buffer Pool里没有数据，就去磁盘 load ；Buffer Pool 是 一个以 页为元素的链表。<br>持久化： 宕机时，Buffer Pool 丢失数据，重做 redo log； 先 redo log, 再 buffer pool<br>Buffer Pool 链表结构：基于 LRU， 和缓存一样，需要淘汰算法来管理数据；</p>
<p>​          <img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwvnzevmj60ip0cuq4a02.jpg" alt="4EC434C3-08BC-41E3-A059-E31B470752DB" width="650" height="450"  /></p>
<h3 id="Change-buffer"><a href="#Change-buffer" class="headerlink" title="Change  buffer:"></a>Change  buffer:</h3><p>​    查询数据时，如果内存里没有对应页的数据，MySQL 会从磁盘里 load ，如果每次需要的 页 都不同（或不是相邻的页），那每次都要去 load，很慢。如果 MySQL 发现你要修改的页不在内存里，就把要对页的修改，先记到一个叫 Change Buffer 的地方，同时记录 redo log，然后再慢慢把数据 load 到内存，load 过来后再把 Change Buffer 里记录的修改，应用到内存 Buffer Pool中，此操作： merge； 把内存数据刷到磁盘操作： <strong>purge</strong> </p>
<p><strong>ChangeBuffer</strong> 只在操作「二级索引」时才使用，原因是「聚簇索引」必须是「唯一」的，也就意味着每次插入&#x2F;更新，都需要检查 是否已经有相同的字段存在，也就没有必要使用 Change Buffer ；另外「聚簇索引」操作的随机性比较小，通常在相邻的「页」进行操作，比如使用自增主键的「聚簇索引」，那么 insert 时就是递增有&#x2F;序的，不像「二级索引」，访问非常随机。</p>
<p>​    MySQL 以16KB「页」 为 读取和写入单位，一个「页」里面有多行数据，写入数据时，MySQL 会先写 内存中的页，然后再刷新到磁盘中的页。假设在某一次从 内存刷新到磁盘的过程中，一个「页」刷了一半，突然操作系统或 MySQL 进程 崩了，此时内存里的 页数据被清除了，而磁盘里的页数据，刷了一半，处于一个中间状态，可以说是一个「不完整」，甚至是「坏掉的」的页。<br>redo log 在 磁盘中的页数据是正常、没有损坏情况下，才能把磁盘里页数据 load 到内存，如果磁盘中的页数据已经损坏，是无法应用 redo Log 的。</p>
<h3 id="Doublewrite-Buffer："><a href="#Doublewrite-Buffer：" class="headerlink" title="Doublewrite Buffer："></a><strong>Doublewrite Buffer：</strong></h3><p>在 刷数据到 磁盘之前，先把数据写到另外一个地方 DoubleWrite Buffer， 写完后再开始写磁盘；Doublewrite Buffer 是一个备份，当发生 crash时，就可以利用 它来 修复磁盘里的数据</p>
<p>1.刷数据之前宕机：内存—&gt; 磁盘，重做 redo log 日志<br>2.刷数据时宕机： 利用 Doublewrite Buffer 修复磁盘数据</p>
<p>​    要更新一个数据页时，如果数据页在 内存中就直接更新；但如果这个数据页还没有在内存中，在不影响数据一致性的前提下，InooDB会将这些更新操作缓存在 change buffer中，这样就不需要 从磁盘中读入这个数据页。在下次查询需要访问这个数据页的时候，将数据页读入内存，然后执行change buffer中与这个页有关的操作，通过这种方式就能保证这个数据逻辑的正确性。<br>Change buffer 是可以持久化的数据，在内存中有拷贝，也会被写入到磁盘上，将change buffer中的操作应用到原数据页，得到最新结果的过程称为 merge。</p>
<h3 id="Merge触发条件："><a href="#Merge触发条件：" class="headerlink" title="Merge触发条件："></a>Merge触发条件：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gutxx7tvv9j60l80wsabd02.jpg" alt="E84FCF6C-D50D-46D4-92A6-93B6B4CC1FD9" width="250" height="350"   />

<p>1.访问这个数据页<br>2.系统后台线程定期 merge<br>3.在数据库正常关闭（shutdown）的过程中，也会执行merge将更新操作先记录在 change buffer，可以减少读磁盘，语句的执行速度会得到明显的提升, 数据读入 内存是需要占用 buffer pool的，所以这种方式还能够避免占用内存，提高内存利用率</p>
<h3 id="使用-change-buffer-的条件？"><a href="#使用-change-buffer-的条件？" class="headerlink" title="使用 change buffer 的条件？"></a>使用 change buffer 的条件？</h3><p>普通索引可以使用 change buffer ,唯一索引（主键，聚簇索引）的更新就不能使用 change buffer<br>唯一索引更新操作都要先判断这个操作 是否违反唯一性约束, 要判断表中是否存在这个数据，就必须要将数据页读入内存才能判断，都已经读入到内存，那直接更新内存会更快，就没必要使用change buffer</p>
<p>change buffer 是 buffer pool里的内存，不能无限增大；<br>change buffer大小可以通过参数 innodb_change_buffer_max_size来动态设置，设置为50 表示change buffer大小最多只能占用buffer pool的50%</p>
<h3 id="change-buffer-使用场景："><a href="#change-buffer-使用场景：" class="headerlink" title="change buffer 使用场景："></a>change buffer 使用场景：</h3><p>适合：写多读少业务，页面在写完以后马上被访问到的概率比较小，此时change buffer的使用效果最好，业务模型常见：账单类,日志类的系统<br>不适合：读多写少（写入后马上会做查询 ）将更新先记录在change buffer，但由于马上要访问这个数据页，会立即触发merge过程，访问IO次数不会减少，反而增加 change buffer的维护代价</p>
<p>数据库进行 Merge 时，是真正进行 数据更新的时刻，而 change buffer 主要目的就是将记录的变更动作缓存下来，所以在一个数据页做merge之前，change buffer 记录的变更越多（页面上要更新的数据越多），收益就越大</p>
<p><strong>flush 操作：</strong> redo log 会找个时间去更新到磁盘，这个操作就是flush<br>脏页：在更新之前，当内存数据页跟磁盘数据页内容不一致的时候<br>干净页：内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致</p>
<h3 id="flush-操作条件："><a href="#flush-操作条件：" class="headerlink" title="flush 操作条件："></a>flush 操作条件：</h3><ol>
<li>InnoDB的 redo log写满了</li>
<li>系统内存不足，需要淘汰一些数据页，空出内存给别的数据页使用。 如果淘汰“脏页”，就要先将脏页写到磁盘。</li>
<li>MySQL认为系统 “空闲”的时候，只要有机会就刷一点 “脏页”</li>
<li>MySQL正常关闭，会把内存的脏页都flush到磁盘上，这样下次启动的时候，就可以直接从磁盘上读数据，启动速度会很快。</li>
</ol>
<p>​            </p>
<h3 id="MySQL-中数据的存储："><a href="#MySQL-中数据的存储：" class="headerlink" title="MySQL 中数据的存储："></a><strong>MySQL 中数据的存储：</strong></h3><p>各个 数据页 组成一个 双向链表；<br>每个 数据页中的记录又组成一个 单向链表<br>每个 数据页都会为存储的记录 生成页目录，一个数据页内： 主键查找，二分法快速定位 ； 其他非主键列查找，从最小记录开始一次遍历单链表</p>
<h3 id="数据库连接池设置："><a href="#数据库连接池设置：" class="headerlink" title="数据库连接池设置："></a>数据库连接池设置：</h3><p>如果你有 10000个并发用户，设置一个10000的连接池基本等于失了智, 即是100也太多了。你需要一个10来个连接的小连接池，然后让剩下的业务线程都在队列里等待。连接池中的连接数量应该等于你的数据库能够有效同时进行的查询任务数（通常不会高于2*CPU核心数）。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库隔离级别</title>
    <url>/2022/03/11/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A3-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h1><h4 id="MVCC：MVCC（Multi-Version-Concurrency-Control）多版本的并发控制协议"><a href="#MVCC：MVCC（Multi-Version-Concurrency-Control）多版本的并发控制协议" class="headerlink" title="MVCC：MVCC（Multi-Version Concurrency Control）多版本的并发控制协议"></a>MVCC：MVCC（Multi-Version Concurrency Control）多版本的并发控制协议</h4><p>1.同一时刻，不同的事务读取到的数据可能是不同的 (即多版本)——在T5时刻，事务A和事务C可以读取到不同版本的数据。</p>
<p>​                            <img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx63fribj60vs0nwgo602.jpg" alt="620165EF-CFEB-4480-AA0F-49D6F836E3B2" width="450" height="350"/>       </p>
<p><strong>MVCC最大的优点：</strong> 读不加锁，因此 读写不冲突，并发性能好<br>InnoDB 存储引擎中，SELECT 操作的不可重复读问题 通过 MVCC 得到解决，而 UPDATE、DELETE 的不可重复读问题通过 Record Lock 解决，INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决的。</p>
<p>InnoDB 实现 MVCC，多个版本的数据可以共存，主要基于以下技术及数据结构：<br><strong>1）隐藏列：</strong>InnoDB中 每行数据都有隐藏列，隐藏列中包含本行数据的事务id，指向 undo log的指针等。<br><strong>2）基于undo log的版本链：</strong>前面说到每行数据的隐藏列中包含了指向 undo log的指针，而每条undo log也会指向更早版本的undo log，从而形成一条版本链。<br><strong>3）ReadView：</strong>通过隐藏列和版本链，MySQL可以将数据恢复到指定版本；但具体要恢复到哪个版本，需要根据 ReadView来确定。</p>
<p>ReadView：指事务（记做事务A）在某一时刻给整个事务系统（trx_sys）打快照，之后再进行 读操作时，会将读取到的数据中的事务 id与 trx_sys快照比较，从而判断数据对该 ReadView是否可见，即对事务A是否可见。</p>
<p>trx_sys 中的主要内容，判断可见性的方法如下：</p>
<ul>
<li>low_limit_id：生成ReadView时系统中应该分配给下一个事务的id，如果数据的事务 id&gt;&#x3D;low_limit_id，则对该ReadView不可见。</li>
<li>up_limit_id：生成ReadView时当前系统中活跃的读写事务中最小的事务id，如果数据的事务 id&lt;up_limit_id，则对该ReadView可见。</li>
<li>rw_trx_ids：表示生成ReadView时当前系统中活跃的读写事务的事务 id列表。<br>如果数据的事务 low_limit_id &lt; id &lt; up_limit_id ，则需要判断事务 id 是否在rw_trx_ids中：<br>如果在，说明生成 ReadView时事务仍在活跃中，因此数据对ReadView不可见；<br>如果不在，说明生成 ReadView时事务已经提交了，因此数据对ReadView可见。</li>
</ul>
<h3 id="RR隔离级别为例："><a href="#RR隔离级别为例：" class="headerlink" title="RR隔离级别为例："></a>RR隔离级别为例：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx7nmijaj60ug0hsgn702.jpg" alt="955EFA49-F4D3-4F25-B180-2CE6CA78E73C" width="550" height="350" />


<p>​    当事务 A在T3时刻读取zhangsan的余额前，会生成ReadView，由于此时事务B没有提交仍然活跃，因此其事务id一定在ReadView的rw_trx_ids中，因此根据前面介绍的规则，事务B的修改对ReadView不可见。接下来，事务A根据指针指向的 undo log查询上一版本的数据，得到zhangsan的余额为100，这样事务A就避免了脏读。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx7jj81uj60ti0mcjti02.jpg" alt="7EBA    16D3-DE67-4CB1-8E64-14B06468BAA9" width="450" height="350"/>

<p>当事务A在T2时刻读取zhangsan 的余额前，会生成 ReadView。此时事务 B 分两种情况讨论:<br>一种是如图中所示，事务已经开始但没有提交，此时其事务id在ReadView的rw_trx_ids中；<br>一种是事务B还没有开始，此时其事务id &gt;&#x3D; ReadView的 low_limit_id；<br>无论是 哪种情况，根据前面介绍的规则，事务B的修改对ReadView都不可见。当事务A在 T5时刻再次读取zhangsan的余额时，会根据T2时刻生成的ReadView对数据的可见性进行判断，从而判断出事务B的修改不可见；因此事务A根据指针指向的undo log查询上一版本的数据，得到zhangsan的余额为100，从而避免了不可重复读。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurx8dda69j60t20swjtp02.jpg" alt="41C08622-F246-4B8C-84E7-58F2AA86A073" width="450" height="400" />

<p>MVCC避免幻读机制与避免不可重复读非常类似。当事务 A在 T2时刻读取 0&lt;id&lt;5的用户余额前，会生成ReadView。此时事务 B分两种情况讨论：<br>一种是 如图中所示，事务已经开始但没有提交，此时其事务 id在ReadView的rw_trx_ids中；<br>一种是 事务B还没有开始，此时其事务 id &gt;&#x3D; ReadView 的low_limit_id。<br>无论是哪种情况，根据前面介绍的规则，事务B的修改对 ReadView都不可见。<br>当事务A在 T5时刻再次读取0&lt;id&lt;5的用户余额时，会根据 T2时刻生成的ReadView对数据的可见性进行判断，从而判断出事务B的修改不可见。因此对于新插入的数据 lisi(id&#x3D;2)，事务A根据其指针指向的 undo log查询上一版本的数据，发现该数据并不存在，从而避免了幻读</p>
<h3 id="可重复读隔离级别实现过程："><a href="#可重复读隔离级别实现过程：" class="headerlink" title="可重复读隔离级别实现过程："></a>可重复读隔离级别实现过程：</h3><p>​    当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号。数据行快照的创建版本号是创建数据行快照时的系统版本号，系统版本号随着创建事务而递增，因此新创建一个事务时，这个事务的系统版本号比之前的系统版本号都大，也就是比所有数据行快照的创建版本号都大。</p>
<h3 id="MVCC-："><a href="#MVCC-：" class="headerlink" title="MVCC ："></a>MVCC ：</h3><p>A 事务读取数据，记录此时刻的快照 id 值， 放在 ReadView 中保存，每次对数据修改都会改变快照 id 值，此id 值保持递增；当后来再次读取 数据时，会比较此时的数据版本 id 值，是否 &gt; 之前的 id 值，如果 &gt; , 说明已经被修改；<br>通 undo log 日志，查询之前的记录数据的快照，访问那个版本时的数据</p>
<p>RR：  可避免 脏读，不可重复读，不能避免 幻读<br>RC： 可避免  脏读， 不能避免 不可重复读，幻读<br>因为 B 线程修改数据提交后，A线程在第二次 select 时，此时不再进行 id 值的比较，会重建ReadView, 使得数据丢失</p>
<h3 id="MVCC是RR-隔离级别下“非加锁读”实现隔离性的方式"><a href="#MVCC是RR-隔离级别下“非加锁读”实现隔离性的方式" class="headerlink" title="MVCC是RR 隔离级别下“非加锁读”实现隔离性的方式"></a>MVCC是RR 隔离级别下“非加锁读”实现隔离性的方式</h3><h4 id="1）读已提交（RC）隔离级别下的非加锁读"><a href="#1）读已提交（RC）隔离级别下的非加锁读" class="headerlink" title="1）读已提交（RC）隔离级别下的非加锁读"></a>1）读已提交（RC）隔离级别下的非加锁读</h4><p>RC与RR一样，都使用了 MVCC，其主要区别在于：<br>RR 是在事务开始后第一次执行select前创建ReadView，直到事务提交都不会再创建；RR可以避免脏读，不可重复读和幻读。<br>RC 每次执行select前都会重新建立一个新的ReadView，因此如果事务 A第一次select之后，事务B对数据进行了修改并提交，那么事务A第二次select 时会重新建立新的ReadView，因此事务 B的修改对事务 A是可见的；因此RC隔离级别可以避免脏读，但是无法避免不可重复读和幻读。</p>
<h4 id="2）加锁读-与-next-key-lock"><a href="#2）加锁读-与-next-key-lock" class="headerlink" title="2）加锁读 与 next-key lock"></a>2）加锁读 与 next-key lock</h4><p>按照是否加锁，MySQL的读可以分为两种：<br>1.非加锁读（快照读，一致性读），使用普通 select语句，这种情况下使用 MVCC避免了脏读，不可重复读，幻读，保证了隔离性。<br>2.加锁读，在查询时会对查询的 数据加锁（共享锁或排它锁）；由于锁的特性，当某事务对数据进行加锁读后，其他事务无法对数据进行写操作，因此可以 避免脏读和不可重复读。而避免幻读，则需要通过 next-key lock，它是一种行锁，相当于 record lock(记录锁) + gap lock(间隙锁)；其不仅会锁住 记录本身(record lock功能)，还会 锁定一个范围(gap lock功能)；因此，加锁读同样可以避免脏读，不可重复读和幻读，保证隔离性。<br>#共享锁读取<br>select…lock in share mode<br>#排它锁读取<br>select…for update</p>
<p>参考：<a href="https://www.cnblogs.com/kismetv/p/10331633.html">https://www.cnblogs.com/kismetv/p/10331633.html</a></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL扩展</title>
    <url>/2022/03/12/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A4-Mysql%E6%89%A9%E5%B1%95/</url>
    <content><![CDATA[<h1 id="MySQL扩展"><a href="#MySQL扩展" class="headerlink" title="MySQL扩展"></a>MySQL扩展</h1><h3 id="Mysql-数据库连接池参数："><a href="#Mysql-数据库连接池参数：" class="headerlink" title="Mysql 数据库连接池参数："></a>Mysql 数据库连接池参数：</h3><p>user<br>password<br>characterEncoding  编码方式<br>autoReconnect：    当数据库连接异常中断时，是否自动重新连接？<br>maxReconnects：   autoReconnect设置为true时，重试连接的次数<br>connectTimeout：   和数据库服务器建立 socket连接时的超时，单位：毫秒。 0表示永不超时<br>allowMultiQueries： mysql驱动开启批量执行sql的开关</p>
<h3 id="Mysql-的参数："><a href="#Mysql-的参数：" class="headerlink" title="Mysql 的参数："></a>Mysql 的参数：</h3><p>max_connections&#x3D;3000:  MySql的最大连接数，如果服务器的并发连接请求量比较大，建议调高此值，以增加并行连接数量<br>default-storage-engine:   MySQL的 默认存储引擎 </p>
<p>innodb_buffer_pool_size:  (默认128M) 存储页面缓存数据<br>innodb_change_buffer_max_size： changeBuffer缓存区,修改记录的<br>read_rnd_buffer_size : 随机读缓冲区大小  MRR 做随机IO时使用，这里会对主键进行排序<br>read_buffer_size : 读入缓冲区大小。对表进行 顺序扫描的请求将分配一个读入缓冲区<br>innodb_log_buffer_size :  事务日志所使用的缓冲区； redo_log日志需要先缓存，再刷盘</p>
<p>wait_timeout&#x3D;1800:  MySQL连接闲置 超过一定时间后将会被强行关闭<br>back_log&#x3D;500  : 连接数据达到 max_connections时，新来请求将会被存在堆栈中，等待某一连接释放资源，该堆栈数量即back_log<br>max_user_connections ： 同一个账号能够同时连接到mysql服务的最大连接数。设置为0表示不限制</p>
<h3 id="MySQL主机宕机后，如何恢复？"><a href="#MySQL主机宕机后，如何恢复？" class="headerlink" title="MySQL主机宕机后，如何恢复？"></a>MySQL主机宕机后，如何恢复？</h3><p>主库宕机：<br>1.确保所有从节点 relay log 全部更新完毕； 在每个从库上执行 show processlist 查看<br>2.登录所有 从节点，查看 master.info文件， 找 最大的  pos 节点作为新主库，数据最全<br>3.登录 pos 最大从节点，执行 stop slave;   删 relay-log.info 等从相关文件； 开启 bin-log 来记录sql 日志； 执行 reset master<br>4.创建用于 同步的用户并授权slave<br>5.登录其他从节点 ，执行 stop slave停止同步，再 执行 start slave ；<br>6.测试 新master 和 slave 数据是 否同步</p>
<h3 id="从库宕机："><a href="#从库宕机：" class="headerlink" title="从库宕机："></a>从库宕机：</h3><p>1)查看 从库上 mysql 的错误日志，里面有记录 主从挂掉时的binlog信息<br>2)有了 binlog和postion信息后，只需要 重新在 从库上进行change master to配置； 配置后开启slave 状态，没有报错<br>3)查看 slave状态，发现slave已经正常了，开始进行 延时数据恢复 </p>
<h3 id="MHA-多节点集群："><a href="#MHA-多节点集群：" class="headerlink" title="MHA+多节点集群："></a>MHA+多节点集群：</h3><p>MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master，整个故障转移过程对应用程序完全透明。<br>1）service mysql stop (关闭主库)<br>2）备库自动提升为主，IP地址同时漂移至备机<br>3）从库自动同步备库<br>修复原主库，将角色变为备，连接至现主库，三台主从又恢复了正常，重新建立MHA</p>
<h3 id="redo-log-与-binlog-区别："><a href="#redo-log-与-binlog-区别：" class="headerlink" title="redo log 与 binlog 区别："></a>redo log 与 binlog 区别：</h3><p>1）作用不同：<br>redo log是用于保证MySQL宕机也不会影响持久性；<br>binlog是用于 保证服务器可以 基于时间点恢复数据，此外 binlog还用于主从复制。<br>2）层次不同：<br>redo log是 InnoDB存储引擎实现的；<br>binlog 是MySQL的服务器层实现的，同时支持InnoDB和其他存储引擎。<br>3）内容不同：<br>redo log 是物理日志，内容基于磁盘的Page；<br>binlog 内容是二进制的，根据binlog_format参数的不同，可能基于 sql语句，基于数据本身或者二者的混合。<br>4）写入时机不同：<br>binlog在事务提交时写入；<br>redo log 写入时机相对多元：<br>** 当事务提交时会调用 fsync对redo log进行刷盘；这是默认情况下的策略，修改innodb_flush_log_at_trx_commit参数可以改变该策略，但事务的持久性将无法保证。<br>** 除事务提交时，还有其他刷盘时机：如master thread每秒刷盘一次redo log等，这样好处是不一定要等到commit时刷盘，commit速度加快。</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL语法</title>
    <url>/2022/03/14/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B1-SQL%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<h1 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h1><p>本地启动： sudo  &#x2F;usr&#x2F;local&#x2F;mysql&#x2F;support-files&#x2F;mysql.server start –skip-grant-tables<br>关闭： sudo pkill -9 mysql<br>登陆 docker 中的 mysql:  mysql -h  10.85.172.27 -P  4058  -u  rootName -p  passWord  cashier<br>忘记密码启动： 修改  mysql.user 表里面的password字段</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;  update mysql.user <span class="built_in">set</span> password=‘***<span class="string">&#x27;  where host=‘***&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt; flush privileges;</span></span><br></pre></td></tr></table></figure>

<h4 id="数据库："><a href="#数据库：" class="headerlink" title="数据库："></a><strong>数据库：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database **if not exists dbName character set utf8;**</span><br><span class="line">**show databases;**</span><br><span class="line">**drop database if exists dbName;**</span><br><span class="line">use dbName;</span><br><span class="line">select database();  -- 显示当前打开的数据库</span><br></pre></td></tr></table></figure>

<h4 id="创建表："><a href="#创建表：" class="headerlink" title="创建表："></a><strong>创建表：</strong></h4><p>PRIMARY KEY:  主键约束</p>
<p>UNIQUE KEY:   唯一约束</p>
<p>NOT NULL:     非空约束</p>
<p>DEFAULT:      默认约束</p>
<p>FOREIGN KEY:  外键约束</p>
<p>主键可自动编号，则可加上 “AUTO_INCREMENT”</p>
<p>级联外键字段：</p>
<p>CASCADE：父表的删除、更新操作会使得子表中匹配的行也自动进行删除或更新；</p>
<p>SET NULL：父表的删除、更新操作会使得子表中的外键列为NULL，并且前提是外键列没有指定为NOT NULL；</p>
<p>RESTRICT：拒绝对父表的删除或更新操作；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create table if not exists teacher(</span><br><span class="line">  id   **int primary key** unique key ,</span><br><span class="line">  name  varchar(20) not null ,</span><br><span class="line">  score  float(8,2) UNIQUE,</span><br><span class="line">  age   int not null</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">\# 子表</span><br><span class="line">CREATE TABLE users(</span><br><span class="line">  id    SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username VARCHAR(10) NOT NULL,</span><br><span class="line">  pid    SMALLINT UNSIGNED, </span><br><span class="line">  FOREIGN KEY (pid) REFERENCES province (id)  /* 外键列，外键列和参照列必须具有相似的数据类型 */</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">CREATE TABLE user3(</span><br><span class="line">  id     SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  username  VARCHAR(10) NOT NULL,</span><br><span class="line">  pid     SMALLINT UNSIGNED,</span><br><span class="line">  FOREIGN KEY (pid) REFERENCES province (id) ON DELETE CASCADE</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 外键</span><br><span class="line">create table province(</span><br><span class="line">  id   **SMALLINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,** </span><br><span class="line">  pname  VARCHAR(20) NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show tables;</span><br><span class="line">**show columns** from teacher; -- 查看数据表结构</span><br></pre></td></tr></table></figure>

<h4 id="修改表属性："><a href="#修改表属性：" class="headerlink" title="修改表属性："></a><strong>修改表属性：</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table user3  add  age tinyint unsigned not null; -- 添加一列</span><br><span class="line">alter table teacher add  (class varchar(20),  address varchar(10) not null);  —- 添加多列</span><br><span class="line">alter table teacher drop class; -- 删除一列</span><br></pre></td></tr></table></figure>

<p><strong>– 添加约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table  teacher  add  unique(age);</span><br><span class="line">alter table  user3   add  foreign key(pid) references province(id);</span><br></pre></td></tr></table></figure>

<p><strong>– 删除约束</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table user3  drop primary key;</span><br></pre></td></tr></table></figure>

<p><strong>– 修改列定义</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table user3 modify id smallint unsigned not null first;</span><br></pre></td></tr></table></figure>

<p><strong>– 修改列名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table user3 change age userage tinyint unsigned;</span><br></pre></td></tr></table></figure>

<p><strong>– 修改表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table user3 rename as user33;</span><br></pre></td></tr></table></figure>

<p><strong>删除表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table user;  </span><br></pre></td></tr></table></figure>

<p><strong>增删改：</strong></p>
<h4 id="增-删-改"><a href="#增-删-改" class="headerlink" title="增-删-改:"></a><strong>增-删-改:</strong></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**insert into** teacher (id,name,score) values (0,&#x27;whq&#x27;,98.3241),(1,&#x27;wxb&#x27;,34.42);</span><br><span class="line"></span><br><span class="line">**delete from** teacher where id = 1;</span><br><span class="line"></span><br><span class="line">**update** teacher **set age=24** where name=&#x27;whq&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="查询："><a href="#查询：" class="headerlink" title="查询："></a>查询：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT select_expr1[,select_expr2,...]</span><br><span class="line">[</span><br><span class="line">  FROM table_name</span><br><span class="line">  [WHERE   where_condition]</span><br><span class="line">  [GROUP BY  &#123;col_name | position&#125; [ASC | DESC],...]</span><br><span class="line">  [HAVING   where_condition]</span><br><span class="line">  [ORDER BY  &#123;col_name | expr | position&#125; [ASC | DESC],...]</span><br><span class="line">  [LIMIT   &#123;[offset,] row_count | row_count OFFSET offset&#125;]</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">select name, age</span><br><span class="line">from teacher</span><br><span class="line">group by age asc;</span><br><span class="line">select name, age</span><br><span class="line">from teacher</span><br><span class="line">group by age asc having age&gt;=10;</span><br><span class="line"></span><br><span class="line">/* 从查询结果中的第3行开始（从0开始计数），共返回4行 */</span><br><span class="line">SELECT name,age </span><br><span class="line">FROM teacher </span><br><span class="line">ORDER BY age ASC </span><br><span class="line">LIMIT 3,4;</span><br><span class="line"></span><br><span class="line">/* 子查询的结果作为上一层查询的条件。可使用IN()/NOT IN()、ANY()、SOME()、ALL()等操作符和比较运算符搭配使用。 */</span><br><span class="line">SELECT goods_id,goods_name,goods_price </span><br><span class="line">FROM tdb_goods </span><br><span class="line">WHERE goods_price &gt;= (SELECT AVG(goods_price) FROM tdb_goods);</span><br><span class="line"></span><br><span class="line">-- LEFT/RIGHT [OUTER] JOIN左外连接/右外连接</span><br><span class="line">SELECT goods_id, goods_name, cate_name </span><br><span class="line">FROM tdb_goods as tg **LEFT JOIN** tdb_goods_cates as tgc</span><br><span class="line">**ON tg.cate_id = tgc.cate_id;**</span><br></pre></td></tr></table></figure>



<h4 id="–-多表删除"><a href="#–-多表删除" class="headerlink" title="– 多表删除"></a>– 多表删除</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DELETE t1 </span><br><span class="line">FROM tdb_goods AS t1 </span><br><span class="line">LEFT JOIN (SELECT goods_id,goods_name </span><br><span class="line">					  FROM tdb_goods </span><br><span class="line">						GROUP BY goods_name </span><br><span class="line">						HAVING count(goods_name) &gt;= 2 ) AS t2 </span><br><span class="line">ON t1.goods_name = t2.goods_name </span><br><span class="line">WHERE t1.goods_id &gt; t2.goods_id;</span><br></pre></td></tr></table></figure>

<h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数:"></a><strong>聚合函数:</strong></h3><ol>
<li><p>AVG()：求平均值；</p>
</li>
<li><p>COUNT()：计数；</p>
</li>
<li><p>MAX()：求最大值；</p>
</li>
<li><p>MIN()：求最小值；</p>
</li>
<li><p>SUM()：求和</p>
</li>
</ol>
<h3 id="数值运算："><a href="#数值运算：" class="headerlink" title="数值运算："></a><strong>数值运算：</strong></h3><ol>
<li>ceil(x)：返回大于 x的最小整数值；</li>
<li>div：整数除法，即结果中只保留整数部分；</li>
<li>floor(x)：返回小于 x的最大整数值；</li>
<li>mod：取余；</li>
<li>power(x, y)：幂运算，即 x的y次方；</li>
<li>round(x, y)：四舍五入，即将数值 x四舍五入为y位小数。</li>
<li>truncate(x, y)：数字截取，将数值 x保留y位小数（不进行四舍五入）</li>
</ol>
<h3 id="比较运算"><a href="#比较运算" class="headerlink" title="比较运算:"></a><strong>比较运算:</strong></h3><ol>
<li>[NOT] BETWEEN…AND…：【不】在范围之内；</li>
<li>[NOT] IN()：【不】在列出值范围内；</li>
<li>IS [NOT] NULL：【非】空</li>
</ol>
<h3 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数:"></a><strong>字符函数:</strong></h3><ol>
<li><p>CONCAT(  str1, str2, …)： 字符连接；</p>
</li>
<li><p>CONCAT_WS(separator, str1, str2, …)： 使用指定的分隔符进行字符连接；</p>
</li>
<li><p>FORMAT(x, d)： x为某数字，d为小数位；</p>
</li>
<li><p>LOWER(str)： 将字符串转化为小写字母；</p>
</li>
<li><p>UPPER(str)： 将字符串转化为大写字母；</p>
</li>
<li><p>LEFT(str, len)：  返回指定长度的字符串的左侧部分；</p>
</li>
<li><p>RIGHT(str, len)： 返回指定长度的字符串的右侧部分；</p>
</li>
<li><p>MID(str, pos[, len])： 返回str里从pos位置开始，长度为len的字符串部分；</p>
</li>
<li><p>SUBSTRING(str, pos, len)： 返回str里从pos位置开始，长度为len的字符串部分；</p>
</li>
<li><p>LENGTH(str)： 返回字符串str的长度，空格也会一起计算长度，以字节为单位；</p>
</li>
<li><p>LTRIM(str)： 删除前导空格；</p>
</li>
<li><p>RTRIM(str)： 删除后续空格；</p>
</li>
<li><p>TRIM([{BOTH | LEADING | TRAILING} [removed_str]] FROM str)： 删除前后缀不需要的字符；</p>
</li>
<li><p>[NOT]LIKE()： 与通配符一起使用选择数据。MySQL提供两个通配符（%和_），其中，“%”用于匹配任何字符串，“_”用于匹配任何单个字符。如果需要匹配的字符本身就是通配符，可使用ESCAPE；</p>
</li>
<li><p>REPLACE(str, old_str, new_str)：将str字符串里的old_str字符串部分替换为new_str；</p>
</li>
<li><p>LOCATE(substr,str)： 返回子符串substr在字符串str的第一个出现的位置；</p>
</li>
<li><p>LOCATE(substr,str,pos)：返回子符串substr在字符串str，从pos处开始的第一次出现的位置。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* LIKE()举例 */</span><br><span class="line">SELECT * FROM test WHERE first_name LIKE &#x27;%1%%&#x27; ESCAPE &#x27;1’;    --  不将“1”后的“%”认为是通配符 </span><br></pre></td></tr></table></figure>



<h3 id="日期时间函数"><a href="#日期时间函数" class="headerlink" title="日期时间函数:"></a><strong>日期时间函数:</strong></h3><ol>
<li>NOW()： 当前日期和时间；</li>
<li>DATE(date)： 返回日期；</li>
<li>CURDATE()： 当前日期；</li>
<li>CURTIME()： 当前时间；</li>
<li>YEAR(date)： 返回date中的年份；</li>
<li>MONTH(date)： 返回date中的月份；</li>
<li>DAY(date)：    返回date的中的日；</li>
<li>DATE_ADD(date, INTERVAL expr type)：日期加减。type类型可以是DAY、WEEK、MONTH、YEAR等。例：SELECT DATE_ADD( ‘2017-11-20’, INTERVAL 2 DAY);</li>
<li>DATEDIFF()：返回两个日期之间的天数；</li>
<li>DATE_FORMAT( date, format)：日期时间格式化。例如%d、%m、%Y等</li>
</ol>
<h3 id="信息函数"><a href="#信息函数" class="headerlink" title="信息函数:"></a><strong>信息函数:</strong></h3><ol>
<li>CONNECTION_ID()：返回数据库的连接次数</li>
<li>DATABASE()：  当前数据库；</li>
<li>LAST_INSERT_ID()： 最后插入记录的id；</li>
<li>USER()： 当前用户；</li>
<li>VERSION()： 版本信息</li>
</ol>
<h3 id="加密函数："><a href="#加密函数：" class="headerlink" title="加密函数："></a><strong>加密函数：</strong></h3><ol>
<li>MD5()：信息摘要算法；</li>
<li>PASSWORD()：密码算法</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL实践案例</title>
    <url>/2022/03/15/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B2-SQL%E5%AE%9E%E8%B7%B5%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<h1 id="SQL实践案例"><a href="#SQL实践案例" class="headerlink" title="SQL实践案例"></a>SQL实践案例</h1><p>查寻每个省份中，金额排 前三的数据</p>
<p><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryq33sqkj60q00g0mys02.jpg" alt="779BB0D3-D123-45C3-9705-FBE5B65973CA" width="350" height="200" />          <img src="https://tva1.sinaimg.cn/large/008i3skNly1guryq7vz98j60pe08swfa02.jpg" alt="A8F514AE-FB66-4027-B813-4FA44385AE55" width="350" height="150" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># a.province = b.province 表示分组，里外统一省份</span><br><span class="line"># b.amount &gt; a.amount 表示 内部金额 &gt; 外部金额的 条数</span><br><span class="line"># 先确定 外部金额，在从内部金额中找到满足条件的数量</span><br><span class="line">select * </span><br><span class="line">from city_order as a </span><br><span class="line">where 3 &gt; ( select count(*) from city_order as b </span><br><span class="line">            where a.province=b.province and a.amount&lt; b.amount );</span><br><span class="line">ORDER BY amount desc;</span><br></pre></td></tr></table></figure>



<p>使用group by 分组统计之后，select 后面只能跟：  group by 的字段、聚合函数</p>
<p>select 中的非多行函数列，都必须出现在group by 中,在group by 中的列，可以出现或不出现在 select 字句中:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select deptno, avg(sal)</span><br><span class="line">from emp</span><br><span class="line">group by deptno;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select province , max(amount) amount</span><br><span class="line">from city_order</span><br><span class="line">group by province;</span><br><span class="line"></span><br><span class="line">select province , avg(amount) amount</span><br><span class="line">from city_order</span><br><span class="line">group by province</span><br><span class="line">having max(amount)&gt; 500;  # amount&gt;500 报错，</span><br></pre></td></tr></table></figure>

<p>在 having ,select 的字段中，只能写 group by 分组的字段 + 聚合函数（其他字段）</p>
<p>不适用 order by ， 实现在 salaries 表 中找 第二大 的员工信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select b.emp_no, max(b.salary),  a.last_name, a.first_name</span><br><span class="line">from  employees a,  salaries b  on a.emp_no = b.emp_no</span><br><span class="line">where b.salary &lt; (select max(bb.salary) from salaries bb);</span><br></pre></td></tr></table></figure>

<p><strong>知识点：</strong><br>在 from 后边写 连接 left join,  right join ,  inner join;   通过 on  连接2个表的相连字段。<br>对所有员工的 薪水按照 salary降序进行 1-N的排名，要求相同 salary并列且按照 emp_no升序排列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select emp_no, salary, </span><br><span class="line">    (select  count(distinct salary) from salaries s2  where s1.salary&lt;=s2.salary )</span><br><span class="line">from salaries s1</span><br><span class="line">order by salary Desc, emp_no Asc;</span><br></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>联合索引</title>
    <url>/2022/03/10/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/B3-%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h1 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h1><h3 id="联合索引使用："><a href="#联合索引使用：" class="headerlink" title="联合索引使用："></a>联合索引使用：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where a=1 and b=1 and c =1;     #利用到定义的索引（a,b,c）,用上a,b,c</span><br><span class="line">select * from t where a=1 and b=1;              #利用到定义的索引（a,b,c）,用上a,b</span><br><span class="line"></span><br><span class="line">select * from t where b=1 and a=1;   -- 利用到定义的索引（a,b,c）,用上a,b（mysql有查询优化器）</span><br><span class="line">select * from t where a=1;           -- 可以利用到定义的索引（a,b,c）,用上a</span><br><span class="line"></span><br><span class="line">select * from t where b=1 and c=1;    -- 不可以利用到定义的索引（a,b,c）； 最左 a 不匹配</span><br><span class="line">select * from t where a=1 and c=1;    -- 利用到定义的索引（a,b,c），但只用上a索引，b,c索引用不到</span><br></pre></td></tr></table></figure>

<p>通过最左匹配原则你可以定义一个联合索引，但是使得多中查询条件都可以用到该索引。<br>值得注意的是，当遇到范围查询( &gt;、&lt;、between、like )就会停止匹配</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where a=1 and b&gt;1 and c =1;  -- 这样a,b可以用到（a,b,c），c索引用不到 </span><br></pre></td></tr></table></figure>

<p>但是如果是建立 (a,c,b)联合索引，则 a,b,c都可以使用索引，因为优化器会自动改写为最优查询语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where a=1 and b &gt;1 and c=1; -- 如果是建立(a,c,b)联合索引，则a,b,c都可以使用索引</span><br></pre></td></tr></table></figure>

<h4 id="优化器改写为："><a href="#优化器改写为：" class="headerlink" title="优化器改写为："></a>优化器改写为：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where a=1 and c=1 and b &gt;1;  </span><br></pre></td></tr></table></figure>

<p>最左匹配原则，索引index1:(a,b,c)，只会走a、a,b、a,b,c 三种类型的查询； 注意：a,c也走，但是只走a字段索引，不会走c字段。<br>特殊情况说明： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table where a = &#x27;1&#x27; and b &gt; ‘2’ and c=&#x27;3&#x27;; -- 这种类型只会有 a与b走索引，c不会走</span><br></pre></td></tr></table></figure>



<p>以index （a,b,c）为例建立这样的索引相当于建立了索引a、ab、abc三个索引。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1guryje2r28j60lt0i8jse02.jpg" alt="236D41B5-19F2-4ADE-B133-7CCA5383265C" width="650" height="450" />

<p>​    该图就是一个形如 (a,b,c) 联合索引的 b+ 树，其中的非叶子节点存储的是第一个关键字的索引 a，而叶子节点存储的是三个关键字的数据。这里可以看出 a 是有序的，而 b，c 都是无序的。但是当在 a 相同的时候，b 是有序的，b 相同的时候，c 又是有序的。最左匹配原则中如果遇到范围查询就会停止, </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where a=5 and b&gt;0 and c =1;   -- 这样a,b可以用到（a,b,c），c不可以</span><br></pre></td></tr></table></figure>

<p>例子: 当查询到 b 的值以后（这是一个范围值），c 是无序的, 所以就不能根据联合索引来确定应该取哪一行。</p>
<p>在 InnoDB 中联合索引只有先确定前一个（左侧的值）后，才能确定下一个值。如果有范围查询的话，那么联合索引中使用范围查询的字段后的索引在该条 SQL 中都不会起作用。</p>
<p>值得注意的是，in 和 &#x3D;  都可以乱序，比如有索引（a,b,c），语句:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from t where c =1 and a=1 and b=1，</span><br><span class="line">这样的语句也可以用到最左匹配，因为 MySQL 中有一个优化器，他会分析 SQL 语句，将其优化成索引可以匹配的形式，即：</span><br><span class="line">select * from t where a =1 and a=1 and c=1 </span><br></pre></td></tr></table></figure>



<h4 id="为什么要使用联合索引"><a href="#为什么要使用联合索引" class="headerlink" title="为什么要使用联合索引:"></a>为什么要使用联合索引:</h4><p><strong>1.减少开销：</strong> 建一个联合索引(col1,col2,col3)，实际相当于建 (col1),(col1,col2),(col1,col2,col3)三个索引,每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！<br><strong>2.覆盖索引：</strong> 对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1&#x3D;1 and col2&#x3D;2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作，覆盖索引是主要的提升性能的优化手段之一。<br><strong>3.效率高：</strong> 索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1&#x3D;1 and col2&#x3D;2 and col3&#x3D;3, 假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%&#x3D;100w条数据，然后再回表从 100w条数据中找到符合col2&#x3D;2 and col3&#x3D; 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%&#x3D;1w，效率明显提升.</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql:索引-事务</title>
    <url>/2022/03/08/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A1-%E7%B4%A2%E5%BC%95-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h1 id="索引-事务"><a href="#索引-事务" class="headerlink" title="索引-事务"></a>索引-事务</h1><h3 id="搜索引擎："><a href="#搜索引擎：" class="headerlink" title="搜索引擎："></a>搜索引擎：</h3><p><strong>InnoDB :</strong>   支持事务，外键，行锁（用MVCC支持高并发）；聚簇索引，叶子节点data域存行记录；跨平台copy 容易复制；Delete 表时一行一行删除<br><strong>MyIsAM:</strong>  不支持 事务，外键，行锁；   非聚簇索引，叶子节点data域中存引用地址；   跨平台难 copy 不易复制； Delete表时先Drop 再Create； </p>
<h4 id="InooDB"><a href="#InooDB" class="headerlink" title="InooDB:"></a>InooDB:</h4><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准隔离级别(未提交读、提交读、可重复读、可串行化)。<br>默认级别时可重复读（REPEATABLE READ），在可串行化级别下，通过 MVCC + Next-Key Lock防止幻读。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwcf2dv8j60zk0hgmz202.jpg" alt="CB82D46E-3719-4F4B-BCC8-515631B077E7" width="650" height="300"  />

<h4 id="MyIsam索引："><a href="#MyIsam索引：" class="headerlink" title="MyIsam索引："></a>MyIsam索引：</h4><img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1f9ljnyb4j21dy0rcq7u.jpg" alt="image-20220419193858190" width="650" height="350" />

<h3 id="索引优点："><a href="#索引优点：" class="headerlink" title="索引优点："></a>索引优点：</h3><p>1.提高数据检索的效率，降低数据库的 IO成本，类似于书的目录</p>
<p>2.索引列对 数据进行排序，降低数据排序的成本，降低CPU消耗</p>
<p>**被索引的列会 自动进行排序，包括【单列索引】和【组合索引】，只是组合索引的排序要复杂一些。如果按照 索引列的顺序进行排序，对应 order by语句来说，效率就会提高很多。</p>
<h3 id="索引缺点："><a href="#索引缺点：" class="headerlink" title="索引缺点："></a>索引缺点：</h3><p>1.索引会占据磁盘空间 </p>
<p>2.索引虽然会 提高查询效率，但是会降低更新表的效率。每次对表增删改，不仅要保存数据，还保存或更新对应的索引文件。</p>
<h3 id="为什么索引结构使用B-树？"><a href="#为什么索引结构使用B-树？" class="headerlink" title="为什么索引结构使用B+树？"></a>为什么索引结构使用B+树？</h3><p>Hash :  不适合范围查找；无法用于排序与分组；<br>二叉树：根节点的取值，容易导致 二叉树不分叉<br>平衡二叉树： 不支持 范围查询快速查找； 范围查询时需要从根节点多次遍历，查询效率不高。</p>
<p><strong>B树：</strong><br>1.B树 不支持范围查询 的快速查找（节点保存记录）；<br>2.每个节点的 data域存储 行记录，行的大小随着列数的增多，所占空间会变大。 这时一个 页中可存储的数据量就会变少，树相应就会变高，磁盘IO次数就会变大。</p>
<p><strong>B+ 树：</strong> 可以保证等值，范围查询的快速查找范围查询时，因为主键具备唯一性（后面不会有 &lt;&#x3D; max_val 数据），不需再向后查找，终止。<br>InnoDB存储引擎一次 IO读取一页（默认16K）的数据量，MySQL的数据存储在磁盘文件中，查询处理数据时，需先把 磁盘中数据加载到内存中，磁盘IO操作很耗时，所以优化重点就是 尽量减少磁盘 IO 操作。</p>
<p><strong>自适应Hash:</strong>  InnoDB 存储引擎中，当某个 索引值被频繁使用时，会在 B+Tree 索引之上 再创建一个哈希索引，让 B+Tree 索引可以根据哈希值来快速查找。MySQL 会自动评估使用自适应索引是否值得，如果观察到建立哈希索引可以提升速度，则建立。<br>一般情况下 聚簇索引 &#x3D;&#x3D; 主键索引，当一个表没有创建主键索引时，<strong>InnoDB会 自动构建聚簇索引，规则如下：</strong>                                                                                                                             1.在表上定义 主键 PRIMARY KEY，InnoDB 将主键索引用作聚簇索引<br>2.如果表没有定义主键，InnoDB会选择 第一个不为NULL的 唯一索引列  用作聚簇索引                                                   3.如果以上两个都没有，InnoDB 使用一个 6 字节长整型的字段 ROWID字段构建聚簇索引，该 ROWID字段会在 插入新行时自动递增<br> 辅助索引： 聚簇索引之外的所有其他索引。</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwdw8ihtj60we0u0n3r02.jpg" alt="8F527CD4-0314-4103-BB56-350BEB31EE6E" width="650" height="450"  />



<h4 id="联合索引查询："><a href="#联合索引查询：" class="headerlink" title="联合索引查询："></a>联合索引查询：</h4><img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwed8u8zj60uj0u0jv602.jpg" alt="91A14DB9-9D64-45B1-9856-D319978A60B0" width="650" height="500"  />

<h3 id="前缀索引："><a href="#前缀索引：" class="headerlink" title="前缀索引："></a>前缀索引：</h3><p>​    MySQL 支持前缀索引，可以定义字符串的一部分作为索引，如果创建索引的语句不指定前缀长度，索引默认包含整个字符串<br><strong>优点：</strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用 额外增加太多的查询成本。<br>有前缀索引的联合索引 一定要回表： 联合索引已包涵相关信息，还是会回表，因为有前缀索引，不确定到底是不是一个完整的信息。<br>就算是 <a href="http://www.aobing@mogu.com/">www.aobing@mogu.com</a> 一个完整的邮箱去查询，但无法判断后续是否有数据，不知道是否是完整的数据，所以需要回表去判断</p>
<p><strong>最左匹配原则：</strong> 在条件允许的情况下 使用组合索引替代多个单列索引使用。<br><strong>组合索引最左匹配：</strong>组合索引查询时，mysql 一直向右匹配直至遇到范围查询 ( &gt;、&lt;、between、like ) 停止匹配<br>**最左前缀匹配原则：** MySQL会一直向右匹配直到遇到范围查询 （&gt;,&lt;,BETWEEN,LIKE）就停止匹配。<br><strong>覆盖索引：</strong> 使用辅助索引的时候，只可以拿到主键值，获取数据还需要再根据主键查询主键索引取到数据。在上面abc_innodb 表中的组合索引查询时，如果只需要 abc字段，则查询到组合索引的叶子节点就可以直接返回，不需要回表。like 模糊匹配支持索引，支持最左匹配原则； Like 要使索引生效，like后不能以%开头， like %字段名%、like %字段名 这类语句会使索引失效</p>
<p>索引列不能参与计算，尽量保持列“干净”：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM_UNIXTIME(create_time) = &#x27;2016-06-06’ </span><br></pre></td></tr></table></figure>

<p>不能使用索引，原因：B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优化：  create_time = UNIX_TIMESTAMP(&#x27;2016-06-06&#x27;)。</span><br></pre></td></tr></table></figure>



<h3 id="复合（联合）索引设计原则"><a href="#复合（联合）索引设计原则" class="headerlink" title="复合（联合）索引设计原则"></a>复合（联合）索引设计原则</h3><p>1.把频繁使用的列、区分度高的列放在前面<br>2.将范围查询的列放在复合索引的最后面，例如 idx_status_create_time<br>3.在常需要作为 查询返回的字段上增加到联合索引中，在联合索引上增加一个字段而使用到覆盖索引，此时建议这种情况下使用联合索引</p>
<p>索引下推：在使用联合索引时</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from table </span><br><span class="line">where name like &#x27;敖%&#x27; and size=22 and age = 20;</span><br></pre></td></tr></table></figure>

<p>语句在搜索索引树时只能用 “敖”，找到第一个满足条件的记录ID1，然后判断其他条件是否满足，比如 size等后续条件；<br>在 MySQL 5.6之前，只能从 ID1开始 一个个回表，到主键索引上找出数据行，再对比字段值。</p>
<p><strong>索引下推优化：</strong> 可以在索引遍历过程中对 联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数</p>
<img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h1f9r7n2oqj21bq0dewgs.jpg" alt="image-20220419194536370" width="850" height="280" />

<h4 id="唯一索引、普通索引区别：（核心-change-buffer）"><a href="#唯一索引、普通索引区别：（核心-change-buffer）" class="headerlink" title="唯一索引、普通索引区别：（核心 change buffer）"></a>唯一索引、普通索引区别：（核心 change buffer）</h4><p>普通索引使用 change buffer, 唯一索引不适用 change buffer</p>
<h3 id="索引字段选取："><a href="#索引字段选取：" class="headerlink" title="索引字段选取："></a>索引字段选取：</h3><p>1.主键，外键<br>2.尽量保持自增，差异性大的字段<br>3.出现频率高，常在where子句中出现的字段<br>4.小的字段（减少所占用的空间）</p>
<h3 id="破坏使用索引的场景："><a href="#破坏使用索引的场景：" class="headerlink" title="破坏使用索引的场景："></a>破坏使用索引的场景：</h3><p>1.索引列 有函数运算&#x2F; 运算<br>2.索引列有  !&#x3D;   &lt;&gt;    not in    not exist<br>3.like <code>%刘</code>  百分号在前的索引<br>4.字符型索引列<br>5.隐式类型转换<br>select * from t where id &#x3D; 1<br>如果 id 是字符类型的，1是数字类型的，explain会发现走全表扫描，根本用不上索引；<br>因为MySQL底层会对 比较进行转换，相当于加了 cast( id AS signed int ) 这样的一个函数，上面说过函数会导致走不上索引。</p>
<h3 id="MySQL-联接方式："><a href="#MySQL-联接方式：" class="headerlink" title="MySQL 联接方式："></a>MySQL 联接方式：</h3><p>1、内联接（ 使用  &#x3D; ， &lt; ，&gt; 比较运算符）： 包括相等联接、自然联接<br>内联接使用比较运算符根据 每个表 共有的列的值 匹配两个表中的行。例如，检索 students和courses表中 学生标识号相同的所有行  </p>
<p>2、外联接：左向外联接、右向外联接、完整外部联接<br>在 FROM子句中指定外联接时，可以由下列几组关键字中的一组指定：<br>1）LEFT  JOIN或 LEFT OUTER JOIN<br>左向外联接的结果集包括  LEFT OUTER 子句中指定的左表的所有行，而不仅仅是 联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的 结果集行中右表的所有选择列表列均为空值 null<br>2）RIGHT  JOIN 或 RIGHT  OUTER  JOIN<br>右向外联接是 左向外联接的反向联接, 将返回右表的所有行, 如果右表的某行在左表中没有匹配行，则将为左表返回空值 null<br>3）FULL  JOIN 或 FULL OUTER JOIN<br>完整 外部联接返回 左表和右表中的所有行。当某行在 另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。   </p>
<p>3、自然连接(笛卡尔积) 返回左表中的所有行，左表中的每一行与右表中的所有行组合</p>
<h3 id="事务四大特性：-原子性，一致性，隔离性，持久性"><a href="#事务四大特性：-原子性，一致性，隔离性，持久性" class="headerlink" title="事务四大特性：  原子性，一致性，隔离性，持久性"></a>事务四大特性：  原子性，一致性，隔离性，持久性</h3><p><strong>1.持久性：</strong>保证事务 提交后不会因为宕机等原因导致数据丢失； redo log<br><strong>2.原子性：</strong>语句要么 全执行，要么全不执行，是事务最核心的特性，事务本身就是以原子性来定义的；undo log （回滚找到前版本数据）<br><strong>3.隔离性：</strong>保证 事务执行尽可能不受其他事务影响；undo log<br><strong>4.一致性：</strong>事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障<br>InnoDB默认的隔离级别是RR，RR的实现主要基于 锁机制（包含next-key lock），MVCC（包括数据的隐藏列、基于undo log的版本链、ReadView）</p>
<p>Redo log 保证事务 持久性； undo log 保证事务原子性、隔离性</p>
<h3 id="持久性：-redo-log（重做日志）"><a href="#持久性：-redo-log（重做日志）" class="headerlink" title="持久性： redo log（重做日志）"></a>持久性： redo log（重做日志）</h3><p>InnoDB 作为存储引擎，数据是存放在磁盘中的，但如果每次读写数据都需要磁盘IO，效率会很低。为此，InnoDB提供了缓存(Buffer Pool)，Buffer Pool  中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：当从数据库读取数据时，会首先从Buffer Pool中读取，如果Buffer Pool中没有，则从磁盘读取后放入Buffer Pool；当向数据库写入数据时，会首先写入Buffer Pool，Buffer Pool中修改的数据会 定期刷新到磁盘中（这一过程称为刷脏）。Buffer Pool 的使用提高了读写数据的效率，但是也带了新的问题：如果MySQL宕机，而此时Buffer Pool中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。<br>Redo log 解决这个问题：当数据修改时，除了修改 Buffer Pool中的数据，还会在 redo log记录这次操作；当事务提交时，会调用 fsync接口对redo log进行刷盘。如果MySQL宕机，重启时可以读取redo log中的数据，对数据库进行恢复。redo log采用的是 预写日志，（WAL Write-ahead logging），所有 修改先写入日志，再更新到Buffer Pool，保证数据不会因MySQL宕机而丢失，从而满足持久性要求。<br>redo log也需要在事务提交时将日志写入磁盘，为什么它比直接将Buffer Pool中修改的数据写入磁盘(即刷脏)要快？<br>主要有以下两方面的原因：<br>（1）刷脏是随机IO，因为每次修改的数据位置随机，但写 redo log是追加操作，属于顺序IO<br>（2）刷脏是以 数据页（Page）为单位的，MySQL默认页大小是16KB，一个Page上一个小修改都要整页写入；而 redo log中只包含真正需要写入的部分，无效IO 减少。</p>
<h3 id="原子性：undo-log-（回滚日志）"><a href="#原子性：undo-log-（回滚日志）" class="headerlink" title="原子性：undo log （回滚日志）"></a>原子性：undo log （回滚日志）</h3><p>undo log: 当 事务回滚时能够撤销所有已经成功执行的sql语句，当事务对数据库进行修改时，InnoDB会生成对应的undo log；如果事务执行 失败或调用了rollback，导致事务需要回滚，可以利用undo log中的信息将数据回滚到修改之前的样子。<br>undo log属于逻辑日志： 记录的是 sql执行相关的信息，当发生回滚时，InnoDB 会根据undo log的内容 做与之前相反的工作：对于每个insert，回滚时会执行delete；对于每个delete，回滚时会执行insert；对于每个update，回滚时会执行一个相反的update，把数据改回去。</p>
<h3 id="隔离性：undo-log"><a href="#隔离性：undo-log" class="headerlink" title="隔离性：undo log"></a>隔离性：undo log</h3><p>并发情形下事务之间互不干扰， 隔离性主要可以分为两个方面（读、写操作）：<br>1.锁： (一个事务) 写操作对(另一个事务)写操作；</p>
<ol start="2">
<li><p>MVCC： (一个事务) 写操作对 (另一个事务)读操作</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwfv4xltj61bk0e43zo02.jpg" alt="207BFD43-7158-4542-8CD9-87A50C94B083" width="650" height="200"  /></li>
</ol>
<p><strong>未提交读：</strong> 事务可以读取 其他未提交事务的执行结果<br><strong>已提交读：</strong> 事务可以读取  已经提交事务所做的改变<br><strong>可重复读：</strong> 同一事务在 多次读取数据时，可以读取到相同的结果<br><strong>可串行化：</strong> 各个事务间串行执行， 在每个读数据行上加上共享锁。在这个级别，导致大量的超时现象和锁竞争。</p>
<p><strong>脏读：</strong> 不同事务下，当前事务可以读取到 另外事务未提交的数据<br><strong>不可重复读：</strong> 同一事务内 多次读取同一数据，读取到的数据是不一样的<br><strong>幻读：</strong> 一个事务读取 某一范围的数据行时，另一个事务在该范围内 插入新行，当此事务再次读取范围内的数据行时，返回之前不存在的行。 幻读是一种特殊的不可重复读问题。</p>
<h3 id="InnoDB-锁类型"><a href="#InnoDB-锁类型" class="headerlink" title="InnoDB 锁类型 :"></a>InnoDB 锁类型 :</h3><p><strong>行锁：</strong>行锁则只锁定需要操作的数据，并发性能好 </p>
<p><strong>共享锁（S Lock）：</strong> 共享锁可以和其他锁共存；<br>多个事务可以同时访问 同一数据，但 只能读不能修改<br><strong>排他锁（X Lock）：</strong> 排他锁和其他锁不能共存；<br>一个事务获取一个数据行的排他锁，其他事务就不能再获取该行的 共享锁和排他锁，获取排他锁的事务可以对数据进行读取和修改。<br>有排他锁的数据行，其他事务不能修改此数据行，也不能通过 for update和 lock in share mode 锁的方式查询数据，但可以直接通过 select …from…查询数据，因为 普通查询没有任何锁机制<br>读时加共享锁，其他事务可以并发读，但不能写； 写时加排它锁，其他事务不能并发写，也不能并发读</p>
<p><strong>Record Lock：</strong>行记录锁；<br><strong>Gap Lock：</strong>间隙锁，在索引记录间隙上的锁，在第一条索引记录之前，最后一条索引记录之后上的间隙锁；<br><strong>Next-key lock：</strong>下键锁，上面2个锁的组合锁；</p>
<p>间隙锁（Gap锁）</p>
<p>在使用范围条件检索数据，请求共享或排他锁时，InnoDB会给符合条件的已有数据的索引项加锁；对于 键值在条件范围内但并不存在的记录，叫做 “间隙(GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是 间隙锁（GAP锁）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c1 FROM t </span><br><span class="line">WHERE c1 BETWEEN 10 and 20 </span><br><span class="line">FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p>字面上意思是锁住 10-15的数据，如果id&#x3D;10的数据已存在，那么别的用户 不可以修改该条数据，但是如果 id&#x3D;15的数据并不存在，也是不可以插入的，因为无论该列中是否已有这样的值，因为该范围中 id 在 （10，15）所有 现有值之间的间隙也是锁定的。</p>
<h3 id="间隙锁的目的："><a href="#间隙锁的目的：" class="headerlink" title="间隙锁的目的："></a>间隙锁的目的：</h3><p>1.防止幻读，满足相关隔离级别的要求，要是不使用间隙锁，其他事务插入(10,20)闭区间的任何记录，本事务再次执行上述语句，就会发生幻读<br>2.为满足其恢复和复制的需要，有关其恢复和复制机制的影响，以及不同隔离级别下InnoDB使用间隙锁的情况。</p>
<p><strong>Record Lock：</strong> 锁定一个 记录上的索引，而不是记录本身；<br><strong>Gap Lock：</strong>锁定索引之间的间隙，但不包含索引本身。</p>
<p>当一个事务执行以下语句，其它事务就不能在 t.c 中插入 15：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT c FROM t </span><br><span class="line">WHERE c BETWEEN 10 and 20 </span><br><span class="line">FOR UPDATE;</span><br></pre></td></tr></table></figure>

<p><strong>Next-Key Lock：</strong> Record Locks + Gap Locks 结合，不仅锁定 一个记录上的索引，也锁定索引之间的间隙。</p>
<p>一个索引包含以下值：10, 11, 13, and 20，那么就需要锁定以下区间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(-∞, 10]</span><br><span class="line">(10, 11]</span><br><span class="line">(11, 13]</span><br><span class="line">(13, 20]</span><br><span class="line">(20, +∞)</span><br></pre></td></tr></table></figure>

<h3 id="间隙锁作用："><a href="#间隙锁作用：" class="headerlink" title="间隙锁作用："></a>间隙锁作用：</h3><p>​    当事务A执行 update user set name&#x3D;’风筝2号’ where age &#x3D; 10 时，由于条件 where age &#x3D; 10 ，数据库不仅在 age &#x3D;10 的行上添加了行锁，而且在这条记录的两边，也就是(负无穷, 10]， (10,30] 这两个区间加了间隙锁，从而导致事务 B插入操作无法完成，只能等待事务A提交。不仅插入 age &#x3D; 10 的记录需要等待事务A提交，age&lt;10， 10&lt;age&lt;30 记录页无法完成，而 &gt;&#x3D; 30的记录不受影响，这足以解决幻读问题了.这是有索引的情况，如果 age 不是索引列，那数据库会为整个表加上间隙锁，不管 age 是否 &gt;&#x3D; 30，都要等待事务 A提交才可以成功插入.<br>​    </p>
<h4 id="表锁：表锁在操作数据时会锁定整张表，并发性能较差；"><a href="#表锁：表锁在操作数据时会锁定整张表，并发性能较差；" class="headerlink" title="表锁：表锁在操作数据时会锁定整张表，并发性能较差；"></a>表锁：表锁在操作数据时会锁定整张表，并发性能较差；</h4><p><strong>意向共享锁（IS Lock）：</strong>事务对 一张表中 某几行的数据加上共享锁；</p>
<p><strong>意向排他锁：</strong> 事务对一张表中 某几行的数据加上 排他锁；<br>一个事务想要给一张表加上表锁，前提是 没有其他任何事务已经锁定这张表的任意一行数据，需要去全表扫描，确认是否有哪一行数据被其他事务锁定，但这非常低效。因此引入意向锁，意向锁相当于一个标识，表示 是否有其他事务 锁定该表中的某几行数据。</p>
<p><strong>未提交读 ：</strong>  总是 读取最新的数据行，没有任何加锁，更新数据就会被读取到<br><strong>可串行化：</strong>  MVCC + Next-Key Lock（Record Lock + Gap Lock）所有 读取的行都加锁</p>
<h3 id="已提交读："><a href="#已提交读：" class="headerlink" title="已提交读："></a><strong>已提交读：</strong></h3><p>根据 MVCC 实现，事务每次查询开始时 都会生成一个独立的 ReadView<br>在数据库表中看到的一行记录可能有多个版本，每个版本记录除了有数据本身外，还有一个 表示版本的字段（row trx_id），它在事务开始的时候向事务系统申请，按时间先后顺序递增<br>已提交读是  每次执行语句时都重新生成一次快照，可重复读在事务开始的时候生成一个当前事务全局性的快照</p>
<p>一个快照能够读到那些版本数据，要遵循以下规则：<br>1.当前事务内的更新，可以读到；<br>2.版本 未提交，不能读到；<br>3.版本 已提交，但是却在快照创建后提交的，不能读到；<br>4.版本 已提交，且是在快照创建前提交的，可以读到；</p>
<p>已提交读-可重复读：主要区别是在快照的创建上，可重复读仅在事务开始时创建一次， 已提交读每次执行语句时都重新创建一次</p>
<h3 id="对于已提交读-—-可重复读区别："><a href="#对于已提交读-—-可重复读区别：" class="headerlink" title="对于已提交读-—-可重复读区别："></a>对于已提交读-—-可重复读区别：</h3><p>它们生成 ReadView的策略不同，已提交读每次查询时都会生成一个新的 ReadView，而可重复读每次查询都复用第一次生成的ReadView，ReadView中保存数据版本号。</p>
<h3 id="可重复读："><a href="#可重复读：" class="headerlink" title="可重复读："></a><strong>可重复读：</strong></h3><p>InnoDB 存储引擎中，<br>1.SELECT 操作的不可重复读问题 通过 MVCC 得到了解决；<br>2.UPDATE，DELETE 的不可重复读问题通过 Record Lock 解决<br>3.INSERT 的不可重复读问题是通过 Next-Key Lock（Record Lock + Gap Lock）解决<br>根据 MVCC实现，只会根据事务中第一次查询时生成的 ReadView </p>
<p><strong>MVCC：</strong> 多版本并发控制（Multi-Version Concurrency Control）<br>InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现 已提交读、可重复读 这两种隔离级别。 </p>
<p>版本号：<br>**系统版本号：是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增</p>
<p>**事务版本号：事务开始时的系统版本号</p>
<p>隐藏的列： MVCC 在每行记录后面都保存着 两个隐藏的列，用来存储两个版本号</p>
<ul>
<li>创建版本号：指示 创建一个数据行的快照时的系统版本号；</li>
<li>删除版本号：如果该快照的 删除版本号 &gt; 当前事务版本号 表示该快照有效，否则表示该快照已经被删除</li>
</ul>
<p>MVCC 使用 快照存储在 Undo 日志中，该日志通过 回滚指针把一个数据行（Record）的所有快照连接起来</p>
<img src="https://tva1.sinaimg.cn/large/008i3skNly1gurwgdnb4cj60yi0bcwf602.jpg" alt="856A41D0-5919-46E6-8477-421AFA8595D8" width="450" height="180"   />

<h3 id="快照读、当前读："><a href="#快照读、当前读：" class="headerlink" title="快照读、当前读："></a>快照读、当前读：</h3><p>问题：在可重复读级别中，通过 MVCC机制让数据变得可重复读，但读到的数据可能是历史数据，不是数据库当前的数据！<br>这在一些对于数据的 时效特别敏感 的业务中，可能出问题。<br>快照读： 读取历史数据； MVCC 的 select 操作是快照中的数据，不需要进行加锁操作。<br>当前读： 读取数据库当前版本数据； MVCC 对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行 加锁操作，从而读取最新的数据。</p>
<p>MVCC 也使用加锁，但是 避免了 SELECT 的加锁 , MySQL为了减少锁处理（包括等待其它锁）的时间，提升并发能力，引入了快照读的概念，使得 select不用加锁。<br>而 update，insert ，delete 这些 “当前读”的隔离性，就需要通过加锁来实现</p>
<p><strong>未提交读隔离级别：</strong>直接返回记录上的最新值，没有视图概念，也就是图中丙丙那一栏，脏读，幻读，不可重复读都有可能发生。</p>
<p><strong>串行化隔离级别：</strong> 直接用 加锁的方式来避免并行访问。 </p>
<p><strong>已提交读、可重复读这两种隔离级别使用了MVCC：</strong></p>
<p>事务在 执行普通的 SELECT操作， 访问记录版本链过程中，可以使不同事务的读-写，写-读操作并发执行，从而提升系统性能</p>
<p>RC，RR 隔离级别不同： RC 在每一次进行 普通 SELECT操作前都会生成一个ReadView；</p>
<p>RR 只在第一次进行普通 SELECT操作前生成一个ReadView，数据的可重复读其实就是 ReadView的重复使用</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化实践</title>
    <url>/2022/04/13/B-%E6%95%B0%E6%8D%AE%E5%BA%93/Mysql/A5-MySQL%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="MySQL优化实践"><a href="#MySQL优化实践" class="headerlink" title="MySQL优化实践"></a>MySQL优化实践</h1><h3 id="1-大数据量拆分："><a href="#1-大数据量拆分：" class="headerlink" title="1.大数据量拆分："></a>1.大数据量拆分：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update coupons </span><br><span class="line">set status = 1 </span><br><span class="line">where status= 0 and create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59&#x27;;</span><br></pre></td></tr></table></figure>

<p>问题： 一个 SQL只能使用一个 cpu core去处理，如果 SQL很复杂或执行很慢，就会阻塞后面的 SQL请求，造成活动连接数暴增，MySQL CPU 100%，相应的接口Timeout，同时对于主从复制架构，做了业务读写分离，更新500w数据需要5分钟，Master上执行了5分钟，binlog传到了slave也需要执行5分钟，那就是Slave延迟5分钟，在这期间会造成 业务脏数据，比如重复下单等。<br>1.先获取 where 条件中的 最小id  ，最大id，<br>2.然后 分批次去更新，每个批次 1000条，这样既能快速完成更新，又能保证 主从复制不会出现延迟</p>
<p>先获取要更新的 数据范围内的 最小id和最大id（表没有物理delete，所以id是连续的）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select min(id) min_id, max(id) max_id from coupons </span><br><span class="line">where status=0 </span><br><span class="line">and create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59’; </span><br><span class="line"></span><br><span class="line">current_id = min_id;</span><br><span class="line">for current_id &lt; max_id do</span><br><span class="line">    update coupons set status=1 </span><br><span class="line">    where id&gt;= current_id and id&lt;= current_id + 1000;    //通过主键id更新1000条很快</span><br><span class="line">commit;</span><br><span class="line">current_id += 1000;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<p>充分利用 辅助索引包含主键id的特性，先通过索引获取主键 id走覆盖索引扫描，不需要回表，然后再通过id去关联操作是高效的，同时根据 MySQL的特性 使用分而治之的思想既能高效完成操作，又能避免主从复制延迟产生的业务数据混乱。</p>
<h3 id="2-分解多表连接："><a href="#2-分解多表连接：" class="headerlink" title="2.分解多表连接："></a>2.分解多表连接：</h3><p>例如，使用 IN() 代替连接查询（in 等价于等值查询）可排序，让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tag</span><br><span class="line">    JOIN tag_post ON tag_post.tag_id= tag.id</span><br><span class="line">    JOIN post ON tag_post.post_id= post.id</span><br><span class="line">    WHERE tag.tag=&#x27;mysql’;</span><br><span class="line"></span><br><span class="line">SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;           --&gt; tag_id = 1234</span><br><span class="line">SELECT * FROM tag_post WHERE tag_id=1234;      —&gt; (123,456,567,9098,8904)</span><br><span class="line">SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904);</span><br></pre></td></tr></table></figure>

<h3 id="3-MRR优化："><a href="#3-MRR优化：" class="headerlink" title="3.MRR优化："></a>3.MRR优化：</h3><p><strong>应用实例一：</strong>（mysql优化器改变where 条件顺序—&gt;匹配联合索引） </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM t WHERE key_part1&gt;=1000 and key_part1&lt;2000 AND key_part2=1000;</span><br></pre></td></tr></table></figure>

<p>表 t 有 ( key_part1,  key_part2 ) 的联合索引 ，因此索引根据 key_part1,  key_part2 的位置关系进行排序。<br>没有MRR：SQL优化器会先将 key_part1&gt;1000 and key_part2&lt;2000 的数据查询出来，待取出的数据后，再根据key_part2的条件进行过滤。这会导致无用的数据被取出，如果有大量的数据是 key_part2 !&#x3D;1000，则启用MRR优化会使性能有巨大的提升.<br>启用MRR优化：优化器会先 将查询条件进行拆分，然后在进行数据查询。优化器会将查询条件拆分为(1000,1000),(1001,1000),(1002,1000),…,(1999,1000)，然后在根据这些拆分出的条件，使用索引下推进行数据查询，避免回表。</p>
<h4 id="应用实例二："><a href="#应用实例二：" class="headerlink" title="应用实例二："></a><strong>应用实例二：</strong></h4><p> 在没有MRR之前,或没有开启 MRR特性时，MySQL 针对基于辅助索引的查询策略是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select non_key_column </span><br><span class="line">from tb where key_column=x;</span><br></pre></td></tr></table></figure>

<p>MySQL 执行查询的伪代码<br>第一步 先根据 where 条件中的 辅助索引，获取辅助索引与主键的集合，结果集为 rest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select key_column, pk_column from tb </span><br><span class="line">where key_column=x order by key_column </span><br></pre></td></tr></table></figure>

<p>第二步 通过第一步获取的主键来获取 对应的值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for each pk_column value in rest do:</span><br><span class="line">select non_key_column from tb where pk_column=val</span><br></pre></td></tr></table></figure>

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guryagegrej60ko0im3zx02.jpg" alt="71AD8A06-C4D7-4035-A63F-E0978354FC50" width="450" height="350"/>

<p>由于MySQL存储数据的方式： 辅助索引的存储顺序并非与主键的顺序一致，从图中可以看出,根据辅助索引获取的主键来访问表中的数据会导致随机的IO . 不同主键不在同一个page 里面时必然导致多次IO 和随机读。<br>在使用 MRR优化特性的情况下，MySQL 针对基于辅助索引的查询策略是这样的：<br>第一步 先根据 where条件中的辅助索引获取辅助索引与主键的集合，结果集为rest</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select key_column, pk_column from tb where key_column = x order by key_column </span><br></pre></td></tr></table></figure>

<p>第二步 将结果集rest 放在buffer里面(read_rnd_buffer_size 大小直到buffer满了)，然后对结果集 rest按照pk_column排序，得到结果集是rest_sort<br>第三步 利用已经排序过的结果集，访问表中的数据，此时是顺序IO.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select non_key_column fromtb where pk_column in ( rest_sort )</span><br></pre></td></tr></table></figure>

<img src="https://tva1.sinaimg.cn/large/008i3skNly1guryaq9apaj60y80hkwge02.jpg" alt="863DB3B3-6049-45F0-B0DC-16D319E21722" width="650" height="350"/>

<p>​    从图示MRR原理，MySQL 将根据 辅助索引获取的结果集根据主键进行排序，将乱序化为有序，可以用-主键顺序访问基表，将随机读转化为顺序读，多页数据记录可一次性读入或 根据此次的主键范围分次读入，以减少IO操作，提高查询效率。<br>MRR的使用与否，是由 MySQL中的开关控制，只要设置开启，它会自动在 read_rnd_buffer_size 缓冲区 内，对primaryKey进行排序。但这个开关并不是一直开着，因为对于 大多数的单条查询，重新在中间添加一步排序，是对性能的损失，没有必要。所以Mysql 中还有一个 mrr_cost_based 开关，如果设置关闭，则完全按照 mrr 开关来执行了；如果设为开启，MySQL的优化器会通过 CBO算法确定是否开启MRR特性（进行对 primaryKey的排序）<br>​    mrr&#x3D;{on|off}<br>​    mrr_cost_based&#x3D;{on|off}</p>
<h3 id="4-大数据量下分页查询-limit-offset-batchSize"><a href="#4-大数据量下分页查询-limit-offset-batchSize" class="headerlink" title="4.大数据量下分页查询 limit offset, batchSize:"></a>4.大数据量下分页查询 limit offset, batchSize:</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select  * from trade_info </span><br><span class="line">where status = 0 and </span><br><span class="line">create_time &gt;= &#x27;2020-10-01 00:00:00&#x27; and create_time &lt;= &#x27;2020-10-07 23:59:59’ </span><br><span class="line">order by id desc </span><br><span class="line">limit 102120, 20;</span><br></pre></td></tr></table></figure>

<p>表 trade_info 上有索引 idx_status_create_time(status, create_time); 等价于索引（status, create_time,id)<br>对于典型的 分页 limit m, n来说，越往后翻页越慢( m越大会越慢);  因为要 定位 m位置需要扫描的数据越来越多，导致IO开销比较大。这里可以利用 辅助索引的覆盖扫描来进行优化，先获取id，这一步就是 索引覆盖扫描，不需要回表，然后通过 id 跟原表 trade_info进行关联<br>&#x2F;&#x2F; 改写后的SQL如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * </span><br><span class="line">from trade_info a , </span><br><span class="line">   (select id from trade_info </span><br><span class="line">    where status = 0 </span><br><span class="line">    and create_time &gt;=&#x27;2020-10-01 00:00:00&#x27; and create_time &lt;=&#x27;2020-10-07 23:59:59’ </span><br><span class="line">    order by id desc limit 102120, 20)  as b    -- 这一步走的是索引覆盖扫描，不需要回表</span><br><span class="line"> where a.id = b.id;</span><br></pre></td></tr></table></figure>

<p><strong>问题：</strong> 分页查询时，MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，而且在取offset+N 行数据时，因为是select * … 的操作，所以是需要回表的，查询到索引叶子节点数据，根据叶子节点上的主键值去聚簇索引上查询需要的全部字段值。<br>那当 offset 特别大的时候，此时使用 limit m,n 效率就非常的低下，因为回表了 M 行无用的数据，并且占用了大量的 buffer pool 缓存。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案:"></a>解决方案:</h3><p>1.控制返回的总页数；<br>2.对超过特定阈值的页数进行 SQL 改写<br>SELECT a.* FROM USER a  INNER JOIN  (SELECT id  FROM USER WHERE age &#x3D; 10 LIMIT 100000,10) b  ON a.id &#x3D; b.id;  结果0.53s<br>需要对 where条件增加索引，id 因为是主键自带索引，select返回减少回表可以提升查询性能, 所以采用查询主键字段后进行关联大幅度提升了查询效率。<br>3.使用Redis 来保存lastMaxtId, 下一次分页查询时直接拼接在 where 条件后边，直接跨过 offset 行数据。</p>
<h3 id="常见慢查询问题："><a href="#常见慢查询问题：" class="headerlink" title="常见慢查询问题："></a>常见慢查询问题：</h3><img src="https://tva1.sinaimg.cn/large/008i3skNly1guryax8sv9j61860oan1002.jpg" alt="14B56083-7EBD-4768-AD40-E3C00DFA418D" width="850" height="500" />



<p>1.确定主键，索引字段，将它们作为查询条件<br>2.数据量过大，使用 limit 做分页处理，  limit  起始id, 条数count<br>3.当 limit 起始行数很大时， 查询效率会降低， 可以考虑使用自增 id </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select *. From table limit  150000 , 5000</span><br><span class="line"></span><br><span class="line">优化： Select * from table where id&gt;150000 and id&lt;200000;  -- 速度会有提升</span><br></pre></td></tr></table></figure>

<p>4.数据导入，可尝试批量导入数据 ；<br><strong>性能：Load  &gt; insert.</strong><br>load 只操作一次，之后数据 批量插入<br>insert 每个数据操作一次，’就要遍历 一次字段索引</p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
      </tags>
  </entry>
</search>
